<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Swift Apprentice</title></head><body><div class="segment-title" id="calibre_link-32">


<h2 class="segment-title1">Swift</h2>

<h3 class="segment-title2">Apprentice</h3>

<h4 class="segment-title2">Seventh Edition</h4>

<p class="calibre1">By the raywenderlich Tutorial Team
</p>
<p class="calibre1">Ehab Amer, Alexis Gallagher, Matt Galloway, Eli Ganim,
</p>
<p class="calibre1">Ben Morrow &amp; Cosmin Pupăză
</p></div>

<div class="segment-title" id="calibre_link-10">


<h3 class="segment-title2">Swift Apprentice</h3>

<p class="calibre1">Ehab Amer, Alexis Gallagher, Matt Galloway, Eli Ganim, Ben Morrow &amp; Cosmin Pupăză
</p>
<p class="calibre1">Copyright ©2021 Razeware LLC.
</p>
<h3 class="segment-title2">Notice of Rights</h3>

<p class="calibre1">All rights reserved. No part of this book or corresponding materials (such as text, images, or source code) may be reproduced or distributed by any means without prior written permission of the copyright owner.
</p>
<h3 class="segment-title2">Notice of Liability</h3>

<p class="calibre1">This book and all corresponding materials (such as source code) are provided on an “as is” basis, without warranty of any kind, express of implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in action of contract, tort or otherwise, arising from, out of or in connection with the software or the use of other dealing in the software.
</p>
<h3 class="segment-title2">Trademarks</h3>

<p class="calibre1">All trademarks and registered trademarks appearing in this book are the property of their own respective owners.
</p></div>

<div class="segment-title" id="calibre_link-23">


<h1 class="segment-chapter">Book license</h1>

<p class="calibre1">By purchasing <i class="calibre2">Swift Apprentice</i>, you have the following license:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You are allowed to use and/or modify the source code in <i class="calibre2">Swift Apprentice</i> in as many apps as you want, with no attribution required.
</p></li>

<li class="calibre4">
<p class="calibre1">You are allowed to use and/or modify all art, images and designs that are included in <i class="calibre2">Swift Apprentice</i> in as many apps as you want, but must include this attribution line somewhere inside your app: “Artwork/images/designs: from <i class="calibre2">Swift Apprentice</i>, available at www.raywenderlich.com”.
</p></li>

<li class="calibre4">
<p class="calibre1">The source code included in <i class="calibre2">Swift Apprentice</i> is for your personal use only. You are NOT allowed to distribute or sell the source code in <i class="calibre2">Swift Apprentice</i> without prior authorization.
</p></li>

<li class="calibre4">
<p class="calibre1">This book is for your personal use only. You are NOT allowed to sell this book without prior authorization, or distribute it to friends, coworkers or students; they would need to purchase their own copies.
</p></li>
</ul>

<p class="calibre1">All materials provided with this book are provided on an “as is” basis, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.
</p>
<p class="calibre1">All trademarks and registered trademarks appearing in this guide are the properties of their respective owners.
</p></div>

<div class="segment-title" id="calibre_link-29">


<h1 class="segment-chapter">Before You Begin</h1>

<p class="calibre1">This section tells you a few things you need to know before you get started, such as what you’ll need for hardware and software, where to find the project files for this book and more.
</p></div>

<div class="segment-title" id="calibre_link-0">


<h1 class="segment-chapter">What You Need</h1>

<p class="calibre1">To follow along with the tutorials in this book, you’ll need the following:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">A Mac running macOS Big Sur 11</em><em class="calibre5">.</em><em class="calibre5">6 or later</em><em class="calibre5">.</em> with the latest point release and security patches installed. This is so you can install the latest version of the required development tool: Xcode.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Xcode 13 or later</em><em class="calibre5">.</em> Xcode is the main development tool for writing code in Swift. You need Xcode 13 at a minimum, since that version includes Swift 5.5 Xcode playgrounds. You can download the latest version of Xcode for free from the Mac App Store, here: <a href="https://itunes.apple.com/app/xcode/id497799835?mt=12" class="calibre6">apple.co/1FLn51R</a>
</p></li>
</ul>

<p class="calibre1">If you haven’t installed the latest version of Xcode, be sure to do that before continuing with the book. The code covered in this book depends on Swift 5.5 and Xcode 13 &mdash; you may get lost if you try to work with an older version or work outside the playground environment that this book assumes.
</p></div>

<div class="segment-title" id="calibre_link-4">


<h1 class="segment-chapter">Book Source Code &amp; Forums</h1>

<h3 class="segment-title2">Book source code</h3>

<p class="calibre1">The materials for this book are all available in the GitHub repository here:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><a href="https://github.com/raywenderlich/sa-materials/tree/editions/7.0" class="calibre6">https://github.com/raywenderlich/sa-materials/tree/editions/7.0</a>
</p></li>
</ul>

<p class="calibre1">You can download the entire set of materials for the book from that page.
</p>
<h3 class="segment-title2">Forum</h3>

<p class="calibre1">We’ve also set up an official forum for the book at <a href="https://forums.raywenderlich.com/c/books/swift-apprentice" class="calibre6">https://forums.raywenderlich.com/c/books/swift-apprentice</a>. This is a great place to ask questions about the book or to submit any errors you may find.
</p></div>

<div class="segment-title" id="calibre_link-7">


<h1 class="segment-chapter">Dedications</h1>

<p class="calibre1">“Thanks to my family for their unconditional support, and my beautiful Merche for being a wonderful blessing.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Ehab Amer</i>
</p>
<p class="calibre1">“To my wife and kids &ndash; Ringae, Odysseus, and Kallisto.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Alexis Gallagher</i>
</p>
<p class="calibre1">“To my amazing family who keep putting up with me spending my spare hours writing books like this.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Matt Galloway</i>
</p>
<p class="calibre1">“To my loved ones: Moriah, Lia and Ari.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Eli Ganim</i>
</p>
<p class="calibre1">“For MawMaw. A talented cook, a loving smooch, a worthy opponent in chicken foot; a home weaver. Her blessing abides beyond her time.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Ben Morrow</i>
</p>
<p class="calibre1">“To my awesome girlfriend Oana, my sweet dogs Sclip and Nori and my lovely cats Grisi and Porto for believing in me all the way.”
</p>
<p class="calibre1">&mdash; <i class="calibre2">Cosmin Pupăză</i>
</p></div>

<div class="segment-title" id="calibre_link-15">


<h2 class="segment-title1">About the Authors</h2>
<div class="author-figure"><img src="images/000062.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Ehab Amer</em> is an author of this book. He is a very enthusiastic Lead iOS developer with a very diverse experience, from building games to enterprise applications and POCs, especially when exploring new technologies. In his spare time, TV shows take the majority, followed by video games. When away from the screen, he goes with his friends for escape room experiences or to explore the underwater world through diving.
</p><div class="author-figure"><img src="images/000072.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Alexis Gallagher</em> is an author of this book. He’s worked in consulting, science, iOS development, startup management, and theater. Perhaps the only software engineer in San Francisco who was born there, he lives there now with his family, and works at Google on machine learning research and applications.
</p><div class="author-figure"><img src="images/000084.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Matt Galloway</em> is an author of this book. He is a software engineer with a passion for excellence. He stumbled into iOS programming when it first was a thing, and he has never looked back. When not coding, he likes to brew his own beer.
</p><div class="author-figure"><img src="images/000107.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Eli Ganim</em> is an author of this book. He is a Software Engineer who’s passionate about teaching, writing and sharing knowledge with others. He lives in Israel with his wife and kids.
</p><div class="author-figure"><img src="images/000096.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Ben Morrow</em> is an author of this book. He delights in discovering the unspoken nature of the world. He’ll tell you the surprising bits while on a walk. He produces beauty by drawing out the raw wisdom that exists within each of us.
</p><div class="author-figure"><img src="images/000002.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Cosmin Pupăză</em> is an author of this book. He is a tutorial writer from Romania. He has worked with more than a dozen programming languages over the years, but none has made such a great impact on himself as Swift. When not coding, he either plays the guitar or studies WWII history.
</p>
<h2 class="segment-title1">About the Editors</h2>
<div class="author-figure"><img src="images/000014.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Sandra Grauschopf</em> is an editor of this book. Sandra is a freelance writer, editor, and content strategist as well as the Editing Team Lead at <a href="https://raywenderlich.com/" class="calibre6">raywenderlich.com</a>. She loves to untangle tortured sentences and to travel the world with a trusty book in her hand. You can follow her on Twitter at @SGrauschopf (<a href="https://twitter.com/sgrauschopf" class="calibre6">https://twitter.com/sgrauschopf</a>) or learn more about her at <a href="http://grauschopf.com" class="calibre6">grauschopf.com</a>.
</p><div class="author-figure"><img src="images/000028.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Steven Van Impe</em> is the technical editor of this book. Steven is a computer science author and lecturer at the HOGENT University of Applied Sciences in Belgium. You can find Steven on Twitter as @pwsacademy (<a href="https://twitter.com/pwsacademy" class="calibre6">https://twitter.com/pwsacademy</a>).
</p><div class="author-figure"><img src="images/000042.jpg" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><em class="calibre5">Ray Fix</em> is the final pass editor of this book. During the day, Ray works on next-generation microscopes made for iPad at Discover Echo Inc. in San Diego, California. He enjoys learning new things and is excited about math, data, visualization, machine learning and computer vision. Swift is his problem-solving language of choice and he has been using it and teaching others about it since its 2014 public release. Twitter: @rayfix (<a href="https://twitter.com/rayfix" class="calibre6">https://twitter.com/rayfix</a>).
</p></div>

<div class="segment-title" id="calibre_link-17">


<h1 class="segment-chapter">Introduction</h1>

<p class="calibre1">Welcome to the Swift Apprentice, fully updated for Xcode 13 and Swift 5.5!
</p>
<p class="calibre1">In the last seven years, Swift has gone from a secret project at Apple, Inc. to a full-blown, open-source, community-driven language. It continues to refine its core goal of being a general-purpose language that supports safety, speed and expressiveness.
</p>
<p class="calibre1">Despite its progressive, industrial-strength nature, Swift is an excellent choice for the beginning programmer since Xcode offers a sandbox-type environment where you can directly execute Swift statements to try out various language features without creating a whole app first.
</p>
<p class="calibre1">Developers worldwide use Swift to build thousands of amazing apps for iOS, iPadOS, macOS, tvOS and watchOS. Swift is also in server-side technology on non-Apple platforms. That means what you learn in this book will be extremely useful as you expand your development skills and possibly work as a developer someday.
</p>
<p class="calibre1">You’ll learn about basic things like constants, values, operations and types, and move up to more intermediate concepts like data structures, classes and enumerations. Finally, you’ll finish off by getting in-depth knowledge about protocol extensions, custom operators, protocol-oriented programming and generics. Swift lets you create beautiful abstractions to solve real-world problems that you will learn about in this book.
</p>
<p class="calibre1">Swift is also a lot of fun! It’s easy to try out small snippets of code as you test new ideas. Programming is a hands-on experience, and Swift makes it fast and easy to follow along with this book and explore on your own.
</p>
<div class="calibre8"></div><h2 class="segment-chapter1">Who this book is for</h2>

<p class="calibre1">If you’re a complete beginner at programming, this is the book for you! There are short exercises and challenges throughout the book to give you some programming practice and test your knowledge along the way.
</p>
<p class="calibre1">If you want to get right into iOS app development while learning bits of the Swift language as you go, we recommend <i class="calibre2">SwiftUI by Tutorials</i> by the raywenderlich.com team. SwiftUI is so approachable that you may have even <i class="calibre2">built</i> a simple app or two with some sample code. As you go through this book, you may be wondering why you don’t see some of the syntaxes that appear in an elementary SwiftUI app. These include <code class="calibre9">@State</code> and <code class="calibre9">@ObservedObject</code> property wrappers, opaque return types and result builders. While property wrappers and opaque return types are eventually covered, they are advanced language features and require quite a bit of background to understand their inner workings. Using them, fortunately, is easy, and <i class="calibre2">SwiftUI by Tutorials</i> will show you how to do that.
</p>
<h2 class="segment-chapter1">How to use this book</h2>

<p class="calibre1">Each chapter of this book presents theory and Swift code to demonstrate the practical applications of what you’re learning.
</p>
<p class="calibre1">Since this is a book for beginners, we suggest reading it in order the first time. After that, the book will make an excellent reference for you to return to and refresh your memory on particular topics.
</p>
<p class="calibre1">All the code in this book is platform-neutral; it isn’t specific to iOS, macOS or any other platform. The code runs in <em class="calibre5">playgrounds</em>, which you’ll learn about in the very first chapter.
</p>
<p class="calibre1">As you read through the book, you can follow along and type the code into a playground. That means you’ll be able to experiment with the code by making changes and see the results immediately.
</p>
<p class="calibre1">Throughout the book, you’ll find <em class="calibre5">mini</em><em class="calibre5">-</em><em class="calibre5">exercises</em>, which are short exercises about the topic at hand. At the end of each chapter, there are also <em class="calibre5">challenges</em>.  These are either programming questions or more extended coding exercises to test your knowledge. You’ll get the most out of this book if you follow along with these exercises and challenges.
</p>
<h2 class="segment-chapter1">What’s in store</h2>

<p class="calibre1">This book consists of four sections. Each section has a short introduction that describes its chapters, their topics and the overarching themes of the section. Here’s a brief overview of the book’s sections:
</p>
<h3 class="segment-title2">Section I: Swift Basics</h3>

<p class="calibre1">The book’s first section starts at the beginning of the computing environment: first, how computers work, and then, how Swift’s playgrounds feature works. With those logistics out of the way, you’ll take a tour of the fundamentals of the Swift language and learn the basics of managing data, structuring your code, performing simple operations and calculations, working with types.
</p>
<h3 class="segment-title2">Section II: Collection Types</h3>

<p class="calibre1">Stored data is a core component of any app, whether it’s a list of friends in your social networking app or a set of unlockable characters in your hit game. In this section, you’ll learn how to store collections of data in Swift.
</p>
<h3 class="segment-title2">Section III: Building Your Own Types</h3>

<p class="calibre1">Swift comes with basic building blocks, but its real power is in the custom things you can build to model parts of your app. Swift has no idea about playable characters and monsters and power-ups &mdash; these are things you need to build yourself! You’ll learn how to do that in this section.
</p>
<h3 class="segment-title2">Section IV: Advanced Topics</h3>

<p class="calibre1">The final section of the book covers more advanced topics in Swift. You’ll learn about specific things, such as how to handle problems that come up as your code runs, as well as about more general things such as memory management, which will help you understand some of Swift’s behind-the-scenes mechanisms. You’ll learn more advanced ways to use the type system with protocols and generics and use cutting-edge features such as results builders and property wrappers. The book concludes with an extensive chapter on the new concurrency features that are now part of the language.
</p>
<h2 class="segment-chapter1">Acknowledgments</h2>

<p class="calibre1">We want to thank many people for their assistance in making this book possible:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Janie Clayton</em> For her previous work on the first, second and third editions of <i class="calibre2">Swift Apprentice</i>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Erik Kerber</em> For his previous work on the first and second editions of <i class="calibre2">Swift Apprentice</i>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Our families:</em> For bearing with us in this crazy time as we worked all hours of the night to get this book ready for publication!
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Everyone at Apple:</em> For creating an exciting new programming language that we can use everywhere!
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">The Swift Community</em>: For all the people, both inside and outside of Apple, who have worked very hard to make Swift the best computer language in the world.
</p></li>

<li class="calibre4">
<p class="calibre1">And most importantly, <em class="calibre5">the readers of raywenderlich</em><em class="calibre5">.</em><em class="calibre5">com &mdash; especially you</em><em class="calibre5">!</em> Thank you so much for reading our site and purchasing this book. Your continued readership and support are what make all of this possible!
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-19">


<h1 class="segment-chapter">Section I: Swift Basics</h1>

<p class="calibre1">The chapters in this section will introduce you to the very basics of programming in Swift. From the fundamentals of how computers work up to language structures, you’ll cover enough of the language to be able to work with data and organize your code’s behavior.
</p>
<p class="calibre1">The section begins with some groundwork to get you started.Once you have the basic data types in your head, it’ll be time to <i class="calibre2">do</i> things with that data, and finally, you’ll learn about an essential data type, optionals, that let you express potentially missing data.
</p>
<p class="calibre1">These fundamentals will get you Swiftly on your way, and before you know it, you’ll be ready for the more advanced topics that follow. Let’s get started!
</p></div>

<div class="segment-title" id="calibre_link-24">


<h1 class="segment-chapter">Chapter 1: Expressions, Variables &amp; Constants</h1>

<p class="calibre1">Welcome to the book! In this first chapter, you’re going to learn a few basics. You’ll learn how code works first. Then you’ll learn about the tools you’ll be using to write Swift code.
</p>
<p class="calibre1">You’ll then start your adventure into Swift by learning some basics such as code comments, arithmetic operations, constants and variables. These are some of the fundamental building blocks of any language, and Swift is no different.
</p>
<p class="calibre1">First of all, you’ll cover the basic workings of computers because it pays to have a grounding before you get into more complicated aspects of programming.
</p>
<h2 class="segment-chapter1">How a computer works</h2>

<p class="calibre1">You may not believe me when I say it, but a computer is not very smart on its own. The power of a computer comes mostly from how it’s programmed by people like you and me. If you want to successfully harness the power of a computer &mdash; and I assume you do, if you’re reading this book &mdash; it’s important to understand how computers work.
</p>
<p class="calibre1">It may also surprise you to learn that computers themselves are rather simple machines. At the heart of a computer is a <em class="calibre5">Central Processing Unit</em> (<em class="calibre5">CPU</em>). This is essentially a math machine. It performs addition, subtraction, and other arithmetical operations on numbers. Everything you see when you operate your computer is built upon a CPU crunching numbers many millions of times per second. Isn’t it amazing what can come from just numbers?
</p>
<p class="calibre1">The CPU stores the numbers it acts upon in small memory units called <em class="calibre5">registers</em>. The CPU can read numbers into registers from the computer’s main memory, known as <em class="calibre5">Random Access Memory</em> (<em class="calibre5">RAM</em>). It’s also able to write the number stored in a register back into RAM. This allows the CPU to work with large amounts of data that wouldn’t all fit in the bank of registers.
</p>
<p class="calibre1">Here is a diagram of how this works:
</p><div class="image"><img src="images/000088.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">As the CPU pulls values from RAM into its registers, it uses those values in its math unit and stores the results back in another register.
</p>
<p class="calibre1">Each time the CPU makes an addition, a subtraction, a read from RAM or a write to RAM, it’s executing a single <em class="calibre5">instruction</em>. Each computer program does its work by running thousands to millions of simple instructions. A complex computer program such as your operating system, macOS (yes, that’s a computer program too!), consists of many millions of instructions.
</p>
<p class="calibre1">It’s entirely possible to write individual instructions to tell a computer what to do, but for all but the simplest programs, it would be immensely time-consuming and tedious. This is because most computer programs aim to do much more than simple math &mdash; computer programs let you surf the Internet, manipulate images, and chat with your friends.
</p>
<p class="calibre1">Instead of writing individual instructions, you write <em class="calibre5">source code</em> (or just code) in a specific <em class="calibre5">programming language</em>, which in your case will be Swift. This code is put through a computer program called a <em class="calibre5">compiler</em>, which converts the code into those small machine instructions the CPU knows how to execute. Each line of code you write will turn into many instructions &mdash; some lines could end up being tens of instructions!
</p>
<h3 class="segment-title2">Representing numbers</h3>

<p class="calibre1">As you know by now, numbers are a computer’s bread and butter, the fundamental basis of everything it does. Whatever information you send to the compiler will eventually become a number. For example, each character within a block of text is represented by a number. You’ll learn more about this in Chapter 2, “Types &amp; Operations”, which delves into types, including <em class="calibre5">strings</em>, the computer term for a block of text.
</p>
<p class="calibre1">Images are no exception. In a computer, each image is also represented by a series of numbers. An image is split into many thousands, or even millions, of picture elements called <em class="calibre5">pixels</em>, where each pixel is a solid color. If you look closely at your computer screen, you may be able to make out these blocks. That is unless you have a particularly high-resolution display where the pixels are incredibly small! Each of these solid color pixels is usually represented by three numbers: one for the amount of red, one for the amount of green and one for the amount of blue. For example, an entirely red pixel would be 100% red, 0% green and 0% blue.
</p>
<p class="calibre1">The numbers the CPU works with are notably different from those you are used to. When dealing with numbers in day-to-day life, you work with them in <em class="calibre5">base 10</em>, otherwise known as the <em class="calibre5">decimal</em> system. Having used this numerical system for so long, you intuitively understand how it works. So that you can appreciate the CPU’s point of view, consider how base 10 works.
</p>
<p class="calibre1">The decimal or base 10 number <em class="calibre5">423</em> contains <em class="calibre5">three units</em>, <em class="calibre5">two tens</em> and <em class="calibre5">four hundreds</em>:
</p><div class="image1"><img src="images/000098.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">In the base 10 system, each digit of a number can have a value of 0, 1, 2, 3, 4, 5, 6, 7, 8 or 9, giving a total of 10 possible values for each digit. Yep, that’s why it’s called base 10! But the actual value of each digit depends on its position within the number. Moving from right to left, each digit gets multiplied by an increasing power of 10. So the multiplier for the far-right position is 10 to the power of 0, which is 1. Moving to the left, the next multiplier is 10 to the power of 1, which is 10. Moving again to the left, the next multiplier is 10 to the power of 2, which is 100. And so on.
</p>
<p class="calibre1">This means each digit has a value ten times that of the digit to its right. The number <em class="calibre5">423</em> is equal to the following:
</p><pre class="code-block">(<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">1000</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">4</span> <span class="hljs-operator">*</span> <span class="hljs-number">100</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-number">10</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">3</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">423</span></pre>
<h4 class="segment-title2">Binary numbers</h4>

<p class="calibre1">Because you’ve been trained to operate in base 10, you don’t have to think about how to read most numbers &mdash; it feels quite natural. But to a computer, base 10 is way too complicated! Computers are simple-minded, remember? They like to work with base 2.
</p>
<p class="calibre1"><em class="calibre5">Base 2</em> is often called <em class="calibre5">binary</em>, which you’ve likely heard of before. It follows that base 2 has only two options for each digit: 0 or 1.
</p>
<p class="calibre1">Almost all modern computers use binary because, at the physical level, it’s easiest to handle only two options for each digit. In digital electronic circuitry, which is mostly what comprises a computer, the presence of an electrical voltage is 1 and the absence is 0 &mdash; that’s base 2!
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: There have been computers both real and imagined that use the ternary numeral system, which has three possible values instead of two. Computer scientists, engineers and dedicated hackers continue to explore the possibilities of a base-3 computer. See <a href="https://en.wikipedia.org/wiki/Ternary_computer" class="calibre6">https://en.wikipedia.org/wiki/Ternary_computer</a> and <a href="http://hackaday.com/tag/ternary-computer/" class="calibre6">http://hackaday.com/tag/ternary-computer/</a>.
</p></div>

<p class="calibre1">Here’s a representation of the base 2 number 1101:
</p><div class="image2"><img src="images/000110.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">In the base 10 number system, the place values increase by a factor of 10: 1, 10, 100, 1000, etc. In base 2, they increase by a factor of 2: 1, 2, 4, 8, 16, etc. The general rule is to multiply each digit by an increasing power of the base number &mdash; in this case, powers of 2 &mdash; moving from right to left.
</p>
<p class="calibre1">So the far-right digit represents (1 * 2^0), which is (1 * 1), which is 1. The next digit to the left represents (0 * 2^1), which is (0 * 2), which is 0. In the illustration above, you can see the powers of 2 on top of the blocks.
</p>
<p class="calibre1">Put another way, every power of 2 either is (1) or isn’t (0) present as a component of a binary number. The decimal version of a binary number is the sum of all the powers of 2 that make up that number. So the binary number 1101 is equal to:
</p><pre class="code-block">(<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">8</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">13</span></pre>
<p class="calibre1">And if you wanted to convert the base 10 number 423 into binary, you would simply need to break down 423 into its component powers of 2. You would wind up with the following:
</p><pre class="code-block">(<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">256</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">128</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">64</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">32</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">16</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">8</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">4</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">423</span></pre>
<p class="calibre1">As you can see by scanning the binary digits in the above equation, the resulting binary number is 110100111. You can prove to yourself that this is equal to 423 by doing the math!
</p>
<p class="calibre1">The computer term given to each digit of a binary number is a <em class="calibre5">bit</em> (a contraction of “binary digit”). Eight bits make up a <em class="calibre5">byte</em>. Four bits is called a <em class="calibre5">nibble</em>, a play on words that shows even old-school computer scientists had a sense of humor.
</p>
<p class="calibre1">A computer’s limited memory means it can normally deal with numbers up to a certain length. Each register, for example, is usually 32 or 64 bits in length, which is why we speak of 32-bit and 64-bit CPUs.
</p>
<p class="calibre1">Therefore, a 32-bit CPU can handle a maximum base-number of 4,294,967,295, which is the base 2 number <code class="calibre9">11111111111111111111111111111111</code>. That is 32 ones&mdash;count them!
</p>
<p class="calibre1">A computer can handle numbers larger than the CPU maximum, but the calculations must be split up and managed in a special and longer way, much like the long multiplication you performed in school.
</p>
<h4 class="segment-title2">Hexadecimal numbers</h4>

<p class="calibre1">As you can imagine, working with binary numbers can become quite tedious because it can take a long time to write or type them. For this reason, in computer programming, we often use another number format known as <em class="calibre5">hexadecimal</em> or <em class="calibre5">hex</em> for short. This is <em class="calibre5">base 16</em>.
</p>
<p class="calibre1">Of course, there aren’t 16 distinct numbers to use for digits; there are only 10. To supplement these, we use the first six letters, <em class="calibre5">a</em> through <em class="calibre5">f</em>.
</p>
<p class="calibre1">They are equivalent to decimal numbers like so:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">a</code> = <code class="calibre9">10</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">b</code> = <code class="calibre9">11</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">c</code> = <code class="calibre9">12</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">d</code> = <code class="calibre9">13</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">e</code> = <code class="calibre9">14</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">f</code> = <code class="calibre9">15</code>
</p></li>
</ul>

<p class="calibre1">Here’s a base 16 example using the same format as before:
</p><div class="image2"><img src="images/000119.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Notice first that you can make hexadecimal numbers look like words. That means you can have a little bit of fun. :]
</p>
<p class="calibre1">Now the values of each digit refer to powers of 16. In the same way as before, you can convert this number to decimal like so:
</p><pre class="code-block">(<span class="hljs-number">12</span> <span class="hljs-operator">*</span> <span class="hljs-number">4096</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">0</span> <span class="hljs-operator">*</span> <span class="hljs-number">256</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">13</span> <span class="hljs-operator">*</span> <span class="hljs-number">16</span>) <span class="hljs-operator">+</span> (<span class="hljs-number">14</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">49374</span></pre>
<p class="calibre1">You translate the letters to their decimal equivalents and then perform the usual calculations.
</p>
<p class="calibre1">But why bother with this?
</p>
<p class="calibre1">Hexadecimal is useful because each hexadecimal digit can represent precisely four binary digits. The binary number <code class="calibre9">1111</code> is equivalent to hexadecimal <code class="calibre9">f</code>. It follows that you can simply concatenate the binary digits representing each hexadecimal digit, creating a hexadecimal number that is shorter than its binary or decimal equivalents.
</p>
<p class="calibre1">For example, consider the number <code class="calibre9">c0de</code> from above:
</p><pre class="code-block">c = 1100
0 = 0000
d = 1101
e = 1110

c0de = 1100 0000 1101 1110</pre>
<p class="calibre1">This turns out to be rather helpful, given how computers use long 32-bit or 64-bit binary numbers. Recall that the longest 32-bit number in decimal is 4,294,967,295. In hexadecimal, it is <code class="calibre9">ffffffff</code>. That’s much more compact and clear.
</p>
<h3 class="segment-title2">How code works</h3>

<p class="calibre1">Computers have many constraints, and by themselves, they can only do a small number of things. The power that the computer programmer adds through coding is putting these small things together in the correct order to produce something much bigger.
</p>
<p class="calibre1">Coding is much like writing a recipe. You assemble ingredients (the data) and give the computer a step-by-step recipe for using them.
</p>
<p class="calibre1">Here’s an example:
</p><pre class="code-block">Step 1. Load photo from the hard drive.
Step 2. Resize photo to 400 pixels wide by 300 pixels high.
Step 3. Apply sepia filter to photo.
Step 4. Print photo.</pre>
<p class="calibre1">This set of steps is what’s known as <em class="calibre5">pseudo</em><em class="calibre5">-</em><em class="calibre5">code</em>. It isn’t written in a valid computer programming language, but it represents the <em class="calibre5">algorithm</em> that you want to use. In this case, the algorithm takes a photo, resizes it, applies a filter and then prints it. It’s a relatively straightforward algorithm, but it’s an algorithm nonetheless!
</p>
<p class="calibre1">Swift code is just like this: a step-by-step list of instructions for the computer. These instructions will get more complex as you read through this book, but the principle is the same: You are simply telling the computer what to do, one step at a time.
</p>
<p class="calibre1">Each programming language is a high-level, pre-defined way of expressing these steps. The compiler knows how to interpret the code you write and convert it into instructions that the CPU can execute.
</p>
<p class="calibre1">There are many different programming languages, each with its own advantages and disadvantages. Swift is an extremely modern language. It incorporates the strengths of many other languages while ironing out some of their weaknesses. In years to come, programmers may look back on Swift as being old and crusty, too. But for now, it continues to improve and evolve.
</p>
<p class="calibre1">This has been a brief tour of computer hardware, number representation and code, and how they all work together to create a modern program. That was a lot to cover in one section! Now it’s time to learn about the tools you’ll use to write in Swift as you follow along with this book.
</p>
<h2 class="segment-chapter1">Playgrounds</h2>

<p class="calibre1">The set of tools you use to write software is called a <em class="calibre5">toolchain</em>. The part of the toolchain into which you write your code is known as the <em class="calibre5">Integrated Development Environment</em> (<em class="calibre5">IDE</em>). The most commonly used IDE for Swift is called Xcode, and that’s what you’ll be using.
</p>
<p class="calibre1">Xcode includes a handy document type called a <em class="calibre5">playground</em>, which allows you to quickly write and test code without building a complete app. You’ll use playgrounds throughout the book to practice coding, so it’s important to understand how they work. That’s what you’ll learn during the rest of this chapter.
</p>
<h3 class="segment-title2">Creating a playground</h3>

<p class="calibre1">To get started with a playground, click <em class="calibre5">File ▸ New ▸ Playground</em>. Xcode will present you with a choice of templates:
</p><div class="image1"><img src="images/000006.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The platform you choose simply defines which version of the template Xcode will use to create the playground. Currently, your options are <em class="calibre5">iOS</em> or <em class="calibre5">macOS</em>. Each platform comes with its own environment set up and ready for you to begin playing around with code.
</p>
<p class="calibre1">For this book, choose whichever platform you wish. You won’t be writing any platform-specific code; instead, you’ll be learning the core principles of the Swift language.
</p>
<p class="calibre1">Select the <em class="calibre5">Blank</em> template and click <em class="calibre5">Next</em>. Xcode will now ask you to name the playground and select a location to save it.
</p>
<p class="calibre1">The name is merely cosmetic and for your own use; when you create your playgrounds, feel free to choose names that will help you remember what they’re about. For example, while you’re working through Chapter 1,“Expressions, Variables &amp; Constants”, you may want to name your playground <em class="calibre5">Chapter1</em>.
</p>
<p class="calibre1">Click <em class="calibre5">Create</em> to create and save the playground. Xcode then presents you with the playground, like so:
</p><div class="image3"><img src="images/000020.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Even blank playgrounds don’t start empty but have some basic starter code to get you going. Don’t worry &mdash; you’ll soon learn what this code means.
</p>
<h3 class="segment-title2">Playgrounds overview</h3>

<p class="calibre1">At first glance, a playground may look like a rather fancy text editor. Well, here’s some news for you: It is essentially just that!
</p><div class="image3"><img src="images/000033.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The previous screenshot highlights the first and most important things to know about:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Source editor</em>: This is the area in which you’ll write your Swift code. It’s much like a text editor such as Notepad or TextEdit. You’ll notice the use of what’s known as a monospaced font, meaning all characters are the same width. This makes the code much easier to read and format.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Results sidebar</em>: This area shows the results of your code. You’ll learn more about how code executes as you read through the book. The results sidebar will be the main place you’ll look to confirm your code is working as expected.
</p></li>
</ol>

<ol start="3" class="calibre11">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Resources tree</em>: This shows the list of resources contained within the playground. Here you’ll find a tree of resources for the playground, starting with the main playground file, then additional sources and resources. This allows you to build very complex playgrounds that split up the sources into multiple files.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Execution control</em>: This control lets you run the entire playground file or clear state so you can run it again. By default, playgrounds do not execute automatically. You can change this setting to execute with every change by long pressing on it and selecting “Automatically Run”.
</p></li>
</ol>

<ol start="5" class="calibre11">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Activity viewer</em>: This shows the status of the playground. In the screenshot, it shows that the playground has finished executing and is ready to handle more code in the source editor. When the playground is executing, this viewer will indicate this with a spinner.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Left panel control</em>: This toggles the left panel where the resources tree is. Keep this closed for now.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Right panel control</em>: This toggles the right panel. Here you’ll find information about the source file that’s open. You’ll usually keep this closed.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Bottom panel control</em>: This toggles the bottom panel. In here, you’ll find output from the running playground. You’ll open this later.
</p></li>
</ol>

<p class="calibre1">You can turn on line numbers on the left side of the source editor by clicking <em class="calibre5">Xcode ▸ Preferences</em><em class="calibre5">…</em><em class="calibre5"> ▸ Text Editing ▸ Line Numbers</em>. Line numbers can be handy when you want to refer to parts of your code.
</p>
<p class="calibre1">Playgrounds execute the code in the source editor from top to bottom. The play button floats next to each line as you move the cursor over it and lets you run from the beginning of the file up to and including the line you click. To force a re-execution, you can click on the <em class="calibre5">Execution control</em> button twice&ndash;once to stop and clear it and again to rerun.
</p>
<p class="calibre1">Once the playground execution is finished, Xcode updates the results sidebar to show the results of the corresponding line in the source editor. You’ll see how to interpret the results of your code as you work through the examples in this book.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Under certain conditions, you may find Xcode incorrectly disables line-based execution. In these cases, just use the execution control button to run the entire playground.
</p></div>

<h2 class="segment-chapter1">Getting started with Swift</h2>

<p class="calibre1">Now that you know how computers work and what this “playground” thing is, it’s time to start writing some Swift!
</p>
<p class="calibre1">You may wish to follow along with your own playground. Simply create one and type in the code as you go!
</p>
<p class="calibre1">First up is something that helps you organize your code. Read on!
</p>
<h3 class="segment-title2">Code comments</h3>

<p class="calibre1">The Swift compiler generates executable code from your source code. To accomplish this, it uses a detailed set of rules you will learn about in this book. Sometimes these details can obscure the big picture of <i class="calibre2">why</i> you wrote your code a certain way or even what problem you are solving. To prevent this, it’s good to document what you wrote so that the next human who passes by will be able to make sense of your work. That next human, after all, may be a future you.
</p>
<p class="calibre1">Swift, like most other programming languages, allows you to document your code through the use of what are called <em class="calibre5">comments</em>. These allow you to write any text directly alongside your code and are ignored by the compiler.
</p>
<p class="calibre1">The first way to write a comment is like so:
</p><pre class="code-block"><span class="hljs-comment">// This is a comment. It is not executed.</span></pre>
<p class="calibre1">This is a <em class="calibre5">single</em><em class="calibre5">-</em><em class="calibre5">line comment</em>.
</p>
<p class="calibre1">You could stack these up like so to allow you to write paragraphs:
</p><pre class="code-block"><span class="hljs-comment">// This is also a comment.</span>
<span class="hljs-comment">// Over multiple lines.</span></pre>
<p class="calibre1">However, there is a better way to write comments which span multiple lines. Like so:
</p><pre class="code-block"><span class="hljs-comment">/* This is also a comment.
   Over many..
   many...
   many lines. */</span></pre>
<p class="calibre1">This is a <em class="calibre5">multi</em><em class="calibre5">-</em><em class="calibre5">line comment</em>. The start is denoted by <code class="calibre9">/*</code> and the end is denoted by <code class="calibre9">*/</code>. Simple!
</p>
<p class="calibre1">Swift also allows you to nest comments, like so:
</p><pre class="code-block"><span class="hljs-comment">/* This is a comment.
 
 <span class="hljs-comment">/* And inside it 
 is 
 another comment.
 */</span>
 
 Back to the first.
 */</span></pre>
<p class="calibre1">This might not seem particularly interesting, but it may be if you have seen other programming languages. Many do not allow you to nest comments like this as when it sees the first <code class="calibre9">*/</code>; it thinks you are closing the first comment. You should use code comments where necessary to document your code, explain your reasoning, or simply leave jokes for your colleagues. :]
</p>
<h2 class="segment-chapter1">Printing out</h2>

<p class="calibre1">It’s also useful to see the results of what your code is doing. In Swift, you can achieve this through the use of the <code class="calibre9">print</code> command.
</p>
<p class="calibre1"><code class="calibre9">print</code> will output whatever you want to the <em class="calibre5">debug area</em> (sometimes referred to as the console).
</p>
<p class="calibre1">For example, consider the following code:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, Swift Apprentice reader!"</span>)</pre>
<p class="calibre1">This will output a nice message to the debug area, like so:
</p><div class="image3"><img src="images/000046.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can hide or show the debug area using the button highlighted with the box in the above screenshot. You can also click <em class="calibre5">View ▸ Debug Area ▸ Show Debug Area</em> to do the same thing.
</p>
<h2 class="segment-chapter1">Arithmetic operations</h2>

<p class="calibre1">When you take one or more pieces of data and turn them into another piece of data, this is known as an <em class="calibre5">operation</em>.
</p>
<p class="calibre1">The simplest way to understand operations is to think about arithmetic. The addition operation takes two numbers and converts them into the sum of the two numbers. The subtraction operation takes two numbers and converts them into the difference between the two numbers.
</p>
<p class="calibre1">You’ll find simple arithmetic all over your apps; from tallying the number of “likes” on a post, to calculating the correct size and position of a button or a window, numbers are indeed everywhere!
</p>
<p class="calibre1">In this section, you’ll learn about the various arithmetic operations that Swift has to offer by considering how they apply to numbers. In later chapters, you see operations for types other than numbers.
</p>
<h3 class="segment-title2">Simple operations</h3>

<p class="calibre1">All operations in Swift use a symbol known as the <em class="calibre5">operator</em> to denote the type of operation they perform. Consider the four arithmetic operations you learned in your early school days: addition, subtraction, multiplication and division. For these simple operations, Swift uses the following operators:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Add: <code class="calibre9">+</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Subtract: <code class="calibre9">-</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Multiply: <code class="calibre9">*</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Divide: <code class="calibre9">/</code>
</p></li>
</ul>

<p class="calibre1">These operators are used like so:
</p><pre class="code-block"><span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-number">6</span>
<span class="hljs-number">10</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span>
<span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-number">4</span>
<span class="hljs-number">24</span> <span class="hljs-operator">/</span> <span class="hljs-number">3</span></pre>
<p class="calibre1">Each of these lines is an <em class="calibre5">expression</em>, meaning each has a value. In these cases, all four expressions have the same value: 8. Notice how the code looks similar to how you would write the operations out on pen and paper. You can enter these straight into your playground.
</p><div class="image3"><img src="images/000058.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The line numbers in light blue have not yet run. To run your code, click on the light blue play button on the last line next to the cursor.
</p>
<p class="calibre1">Upon running, the playground removes the blue sidebar from the lines that have run; you can also see the values of these expressions in the right-hand bar, known as the <em class="calibre5">results sidebar</em>.
</p><div class="image3"><img src="images/000070.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">If you want, you can remove the whitespace surrounding the operator:
</p><pre class="code-block"><span class="hljs-number">2</span><span class="hljs-operator">+</span><span class="hljs-number">6</span></pre>
<p class="calibre1">When you make this change, the blue sidebar reappears to indicate which lines need to be rerun. You can run again by clicking on the blue arrow or by using the shortcut <em class="calibre5">Shift</em><em class="calibre5">-</em><em class="calibre5">Enter</em>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Shift-Enter runs all statements up to the current cursor and advances to the next line. This makes it easy to keep hitting Shift-Enter and run the whole playground step-by-step, and it’s a great shortcut to commit to muscle memory.
</p></div>

<p class="calibre1">Removing the whitespace is all or nothing; you can’t mix styles. For example:
</p><pre class="code-block"><span class="hljs-number">2</span><span class="hljs-operator">+</span><span class="hljs-number">6</span>   <span class="hljs-comment">// OK</span>
<span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-number">6</span> <span class="hljs-comment">// OK</span>
<span class="hljs-number">2</span> <span class="hljs-operator">+</span><span class="hljs-number">6</span>  <span class="hljs-comment">// ERROR</span>
<span class="hljs-number">2</span><span class="hljs-operator">+</span> <span class="hljs-number">6</span>  <span class="hljs-comment">// ERROR</span></pre>
<p class="calibre1">The first error will be:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Consecutive statements on a line must be separated by ';'</code>
</p></div>

<p class="calibre1">And for the second error, you’ll see:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">'+' is not a postfix unary operator</code>
</p></div>

<p class="calibre1">You don’t need to understand these error messages at the moment. Just be aware that you must have whitespace on both sides of the operator or no whitespace on either side!
</p>
<p class="calibre1">It’s often easier to read expressions when you have white space on either side.
</p>
<h3 class="segment-title2">Decimal numbers</h3>

<p class="calibre1">All of the operations above have used whole numbers, more formally known as <em class="calibre5">integers</em>. However, as you will know, not every number is whole.
</p>
<p class="calibre1">As an example, consider the following:
</p><pre class="code-block"><span class="hljs-number">22</span> <span class="hljs-operator">/</span> <span class="hljs-number">7</span></pre>
<p class="calibre1">This, you may be surprised to know, results in the number 3. This is because if you only use integers in your expression, Swift makes the result an integer also. In this case, the result is rounded down to the next integer.
</p>
<p class="calibre1">You can tell Swift to use decimal numbers by changing it to the following:
</p><pre class="code-block"><span class="hljs-number">22.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">7.0</span></pre>
<p class="calibre1">This time, the result is 3.142857142857143 as expected.
</p>
<h3 class="segment-title2">The remainder operation</h3>

<p class="calibre1">The four operations you’ve seen so far are easy to understand because you’ve been doing them for most of your life. Swift also has more complex operations you can use, all of them standard mathematical operations, just less common ones. Let’s turn to them now.
</p>
<p class="calibre1">The first of these is the <em class="calibre5">remainder</em> operation, also called the modulo operation. In division, the denominator goes into the numerator a whole number of times, plus a remainder. This remainder is exactly what the remainder operation gives. For example, 10 modulo 3 equals 1 because 3 goes into 10 three times, with a remainder of 1.
</p>
<p class="calibre1">In Swift, the remainder operator is the <code class="calibre9">%</code> symbol, and you use it like so:
</p><pre class="code-block"><span class="hljs-number">28</span> <span class="hljs-operator">%</span> <span class="hljs-number">10</span></pre>
<p class="calibre1">In this case, the result equals <code class="calibre9">8</code> because 10 goes into 28 twice with a remainder of 8. If you want to compute the same thing using decimal numbers, you do it like so:
</p><pre class="code-block">(<span class="hljs-number">28.0</span>).truncatingRemainder(dividingBy: <span class="hljs-number">10.0</span>)</pre>
<p class="calibre1">This computes 28 divided by 10 and then <em class="calibre5">truncates</em> the result, chopping off any extra decimals and returns the remainder of that. The result is identical to <code class="calibre9">%</code> when there are no decimals.
</p>
<h3 class="segment-title2">Shift operations</h3>

<p class="calibre1">The <em class="calibre5">shift left</em> and <em class="calibre5">shift right</em> operations take the binary form of a decimal number and shift the digits left or right, respectively. Then they return the decimal form of the new binary number.
</p>
<p class="calibre1">For example, the decimal number 14 in binary, padded to 8 digits, is <code class="calibre9">00001110</code>. Shifting this left by two places results in <code class="calibre9">00111000</code>, which is 56 in decimal.
</p>
<p class="calibre1">Here’s an illustration of what happens during this shift operation:
</p><div class="image4"><img src="images/000081.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The digits that come in to fill the empty spots on the right become <code class="calibre9">0</code>. The digits that fall off the end on the left are lost. Shifting right is the same, but the digits move to the right.
</p>
<p class="calibre1">The operators for these two operations are as follows:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Shift left: <code class="calibre9">&lt;&lt;</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Shift right: <code class="calibre9">&gt;&gt;</code>
</p></li>
</ul>

<p class="calibre1">These are the first operators you’ve seen that contain more than one character. Operators can contain any number of characters.
</p>
<p class="calibre1">Here’s an example that uses both of these operators:
</p><pre class="code-block"><span class="hljs-number">1</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-number">3</span>

<span class="hljs-number">32</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">2</span></pre>
<p class="calibre1">Both of these values equal the number 8.
</p>
<p class="calibre1">One reason for using shifts is to make multiplying or dividing by powers of two easy. Notice that shifting left by one is the same as multiplying by two, shifting left by two is the same as multiplying by four, and so on.
</p>
<p class="calibre1">Likewise, shifting right by one is the same as dividing by two, shifting right by two is the same as dividing by four, and so on.
</p>
<p class="calibre1">In the old days, code often used this trick because shifting bits is much simpler for a CPU to do than complex multiplication and division arithmetic. Therefore the code was quicker if it used shifting.
</p>
<p class="calibre1">However, these days, CPUs are much faster and compilers can even convert multiplication and division by powers of two into shifts for you. So you’ll see shifting only for binary twiddling, which you probably won’t see unless you become an embedded systems programmer!
</p>
<h3 class="segment-title2">Order of operations</h3>

<p class="calibre1">Of course, it’s likely that when you calculate a value, you’ll want to use multiple operators. Here’s an example of how to do this in Swift:
</p><pre class="code-block">((<span class="hljs-number">8000</span> <span class="hljs-operator">/</span> (<span class="hljs-number">5</span> <span class="hljs-operator">*</span> <span class="hljs-number">10</span>)) <span class="hljs-operator">-</span> <span class="hljs-number">32</span>) <span class="hljs-operator">&gt;&gt;</span> (<span class="hljs-number">29</span> <span class="hljs-operator">%</span> <span class="hljs-number">5</span>)</pre>
<p class="calibre1">Note the use of parentheses, which in Swift serve two purposes: to make it clear to anyone reading the code &mdash; including yourself &mdash; what you meant, and to disambiguate. For example, consider the following:
</p><pre class="code-block"><span class="hljs-number">350</span> <span class="hljs-operator">/</span> <span class="hljs-number">5</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span></pre>
<p class="calibre1">Does this equal 72 (350 divided by 5, plus 2) or 50 (350 divided by 7)? Those of you who paid attention in school will be screaming, “72!” And you would be right!
</p>
<p class="calibre1">Swift uses the same reasoning and achieves this through what’s known as <em class="calibre5">operator precedence</em>. The division operator (<code class="calibre9">/</code>) has higher precedence than the addition operator (<code class="calibre9">+</code>), so in this example, the code executes the division operation first.
</p>
<p class="calibre1">If you wanted Swift to do the addition first &mdash; that is, to return 50 &mdash; then you could use parentheses like so:
</p><pre class="code-block"><span class="hljs-number">350</span> <span class="hljs-operator">/</span> (<span class="hljs-number">5</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span>)</pre>
<p class="calibre1">The precedence rules follow the same that you learned in math at school. Multiply and divide have the same precedence, higher than add and subtract, which also have the same precedence.
</p>
<h2 class="segment-chapter1">Math functions</h2>

<p class="calibre1">Swift also has a vast range of math functions for you to use when necessary. You never know when you need to pull out some trigonometry, especially when you’re a pro at Swift and writing those complex games!
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> Not all of these functions are part of Swift. The operating system provides some. Don’t remove the import statement that comes as part of the playground template or Xcode will tell you it can’t find these functions.
</p></div>

<p class="calibre1">For example, consider the following:
</p><pre class="code-block">sin(<span class="hljs-number">45</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">Double</span>.pi <span class="hljs-operator">/</span> <span class="hljs-number">180</span>)
<span class="hljs-comment">// 0.7071067811865475</span>

cos(<span class="hljs-number">135</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">Double</span>.pi <span class="hljs-operator">/</span> <span class="hljs-number">180</span>)
<span class="hljs-comment">// -0.7071067811865475</span></pre>
<p class="calibre1">These convert an angle from degrees to radians and then compute the sine and cosine, respectively. Notice how both make use of <code class="calibre9">Double.pi</code>, which is a constant Swift provides us, ready-made with pi to as much precision as is possible by the computer. Neat!
</p>
<p class="calibre1">Then there’s this:
</p><pre class="code-block">(<span class="hljs-number">2.0</span>).squareRoot()
<span class="hljs-comment">// 1.414213562373095</span></pre>
<p class="calibre1">This computes the square root of 2. Did you know that the sine of 45° equals 1 over the square root of 2?  Try it out!
</p>
<p class="calibre1">Not mentioning these would be a shame:
</p><pre class="code-block"><span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">// 10</span>

<span class="hljs-built_in">min</span>(<span class="hljs-operator">-</span><span class="hljs-number">5</span>, <span class="hljs-operator">-</span><span class="hljs-number">10</span>)
<span class="hljs-comment">// -10</span></pre>
<p class="calibre1">These compute the maximum and minimum of two numbers, respectively.
</p>
<p class="calibre1">If you’re particularly adventurous you can even combine these functions like so:
</p><pre class="code-block"><span class="hljs-built_in">max</span>((<span class="hljs-number">2.0</span>).squareRoot(), <span class="hljs-built_in">Double</span>.pi <span class="hljs-operator">/</span> <span class="hljs-number">2</span>)
<span class="hljs-comment">// 1.570796326794897</span></pre>
<h2 class="segment-chapter1">Naming data</h2>

<p class="calibre1">At its simplest, computer programming is all about manipulating data. Remember, everything you see on your screen can be reduced to numbers you send to the CPU. Sometimes you represent and work with this data as various types of numbers, but other times the data comes in more complex forms such as text, images and collections.
</p>
<p class="calibre1">In your Swift code, you can give each piece of data a name you can refer to later. The name carries with it a <em class="calibre5">type annotation</em> that denotes what sort of data the name refers to, such as text, numbers, or a date. You’ll learn about some of the basic types in this chapter, and you’ll encounter many other types throughout this book.
</p>
<h3 class="segment-title2">Constants</h3>

<p class="calibre1">Take a look at this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> number: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span></pre>
<p class="calibre1">This declares a constant called <code class="calibre9">number</code>, which is of type <code class="calibre9">Int</code>. Then it sets the value of the constant to the number <code class="calibre9">10</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Thinking back to operators, here’s another one. The equals sign, <code class="calibre9">=</code>, is known as the <em class="calibre5">assignment operator</em>.
</p></div>

<p class="calibre1">The type <code class="calibre9">Int</code> can store integers. The way you store decimal numbers is like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> pi: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159</span></pre>
<p class="calibre1">This is similar to the <code class="calibre9">Int</code> constant, except the name and the type are different. This time, the constant is a <code class="calibre9">Double</code>, a type that can store decimals with high precision.
</p>
<p class="calibre1">There’s also a type called <code class="calibre9">Float</code>, short for floating-point, that stores decimals with lower precision than <code class="calibre9">Double</code>. In fact, <code class="calibre9">Double</code> has about double the precision of <code class="calibre9">Float</code>, which is why it’s called <code class="calibre9">Double</code> in the first place. A <code class="calibre9">Float</code> takes up less memory than a <code class="calibre9">Double</code>, but generally, memory use for numbers isn’t a huge issue and you’ll see <code class="calibre9">Double</code> used in most places.
</p>
<p class="calibre1">Once you’ve declared a constant, you can’t change its data. For example, consider the following code:
</p><pre class="code-block">number <span class="hljs-operator">=</span> <span class="hljs-number">0</span></pre>
<p class="calibre1">This code produces an error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Cannot assign to value: 'number' is a 'let' constant</code>
</p></div>

<p class="calibre1">In Xcode, you would see the error represented this way:
</p><div class="image3"><img src="images/000093.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Constants are useful for values that aren’t going to change. For example, if you were modeling an airplane and needed to refer to the total number of seats installed, you could use a constant.
</p>
<p class="calibre1">You might even use a constant for something like a person’s age. Even though their age will change as their birthday comes, you might only be concerned with their age at this particular instant.
</p>
<h3 class="segment-title2">Variables</h3>

<p class="calibre1">Often you want to change the data behind a name. For example, if you were keeping track of your bank account balance with deposits and withdrawals, you might use a variable rather than a constant.
</p>
<p class="calibre1">If your program’s data never changed, then it would be a rather boring program! But as you’ve seen, it’s not possible to change the data behind a constant.
</p>
<p class="calibre1">When you know you’ll need to change some data, you should use a variable to represent that data instead of a constant. You declare a variable in a similar way, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> variableNumber: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span></pre>
<p class="calibre1">Only the first part of the statement is different: You declare constants using <code class="calibre9">let</code>, whereas you declare variables using <code class="calibre9">var</code>.
</p>
<p class="calibre1">Once you’ve declared a variable, you’re free to change it to whatever you wish, as long as the type remains the same. For example, to change the variable declared above, you could do this:
</p><pre class="code-block">variableNumber <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
variableNumber <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000</span></pre>
<p class="calibre1">To change a variable, you simply assign it a new value.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> In Swift, you can optionally use underscores to make larger numbers more human-readable. The quantity and placement of the underscores is up to you.
</p></div>

<p class="calibre1">This is a good time to take a closer look at the results sidebar of the playground. When you type the code above into a playground, you’ll see that the results sidebar on the right shows the current value of <code class="calibre9">variableNumber</code> at each line:
</p><div class="image4"><img src="images/000104.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The results sidebar will show a relevant result for each line if one exists. In the case of a variable or constant, the result will be the new value, whether you’ve just declared a constant or declared or reassigned a variable.
</p>
<h3 class="segment-title2">Using meaningful names</h3>

<p class="calibre1">Always try to choose meaningful names for your variables and constants. Good names act as documentation and make your code easy to read. A good name <i class="calibre2">specifically</i> describes the role of a variable or constant. Here are some examples of good names:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">personAge</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">numberOfPeople</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">gradePointAverage</code>
</p></li>
</ul>

<p class="calibre1">Often a bad name is simply not descriptive enough. Here are some examples of bad names:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">a</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">temp</code>
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">average</code>
</p></li>
</ul>

<p class="calibre1">The key is to ensure that you’ll understand what the variable or constant refers to when you read it again later. Don’t make the mistake of thinking you have an infallible memory! It’s common in computer programming to look back at your own code as early as a day or two later and have forgotten what it does. Make it easier for yourself by giving your variables and constants intuitive, precise names.
</p>
<p class="calibre1">Also, note how the names above are written. In Swift, it is common to <em class="calibre5">camel case</em> names. For variables and constants, follow these rules to case your names properly:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Start with a lowercase letter.
</p></li>

<li class="calibre4">
<p class="calibre1">If the name is made up of multiple words, join them together and start the other words with an uppercase letter.
</p></li>

<li class="calibre4">
<p class="calibre1">If one of these words is an abbreviation, write the entire abbreviation in the same case (e.g.: <code class="calibre9">sourceURL</code> and <code class="calibre9">urlDescription</code>)
</p></li>
</ul>

<p class="calibre1">In Swift, you can even use the full range of Unicode characters. For example, you could declare a variable like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> 🐶💩: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span></pre>
<p class="calibre1">That might make you laugh, but use caution with special characters like these. They are harder to type and likely to bring you more pain than amusement.
</p>
<p class="calibre1">Special characters like these probably make more sense in <i class="calibre2">data</i> that you store rather than in Swift code; you’ll learn more about Unicode in Chapter 9, “Strings.”
</p>
<h2 class="segment-chapter1">Increment and decrement</h2>

<p class="calibre1">A common operation that you will need is to be able to increment or decrement a variable. In Swift, you achieve it like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> counter: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

counter <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
<span class="hljs-comment">// counter = 1</span>

counter <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>
<span class="hljs-comment">// counter = 0</span></pre>
<p class="calibre1">The <code class="calibre9">counter</code> variable begins as <code class="calibre9">0</code>. The increment sets its value to <code class="calibre9">1</code>, and then the decrement sets its value back to <code class="calibre9">0</code>.
</p>
<p class="calibre1">These operators are similar to the assignment operator (<code class="calibre9">=</code>), except they also perform an addition or subtraction. They take the current value of the variable, add or subtract the given value and assign the result to the variable.
</p>
<p class="calibre1">In other words, the code above is shorthand for the following:
</p><pre class="code-block"><span class="hljs-keyword">var</span> counter: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
counter <span class="hljs-operator">=</span> counter <span class="hljs-operator">+</span> <span class="hljs-number">1</span>
counter <span class="hljs-operator">=</span> counter <span class="hljs-operator">-</span> <span class="hljs-number">1</span></pre>
<p class="calibre1">Similarly, the <code class="calibre9">*=</code> and <code class="calibre9">/=</code> operators do the equivalent for multiplication and division, respectively:
</p><pre class="code-block">counter <span class="hljs-operator">=</span> <span class="hljs-number">10</span>

counter <span class="hljs-operator">*=</span> <span class="hljs-number">3</span>  <span class="hljs-comment">// same as counter = counter * 3</span>
<span class="hljs-comment">// counter = 30</span>

counter <span class="hljs-operator">/=</span> <span class="hljs-number">2</span>  <span class="hljs-comment">// same as counter = counter / 2</span>
<span class="hljs-comment">// counter = 15</span></pre>
<h3 class="segment-title2">Mini-exercises</h3>

<p class="calibre1">If you haven’t been following along with the code in Xcode, now’s the time to create a new playground and try some exercises to test yourself!
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Declare a constant of type <code class="calibre9">Int</code> called <code class="calibre9">myAge</code> and set it to your age.
</p></li>

<li class="calibre4">
<p class="calibre1">Declare a variable of type <code class="calibre9">Double</code> called <code class="calibre9">averageAge</code>. Initially, set it to your own age. Then, set it to the average of your age and my own age of <code class="calibre9">30</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant called <code class="calibre9">testNumber</code> and initialize it with whatever integer you’d like. Next, create another constant called <code class="calibre9">evenOdd</code> and set it equal to <code class="calibre9">testNumber</code> modulo 2. Now change <code class="calibre9">testNumber</code> to various numbers. What do you notice about <code class="calibre9">evenOdd</code>?
</p></li>

<li class="calibre4">
<p class="calibre1">Create a variable called <code class="calibre9">answer</code> and initialize it with the value <code class="calibre9">0</code>. Increment it by <code class="calibre9">1</code>. Add <code class="calibre9">10</code> to it. Multiply it by <code class="calibre9">10</code>. Then, shift it to the right by <code class="calibre9">3</code>. After all of these operations, what’s the answer?
</p></li>
</ol>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of variables and constants. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Variables</h3>

<p class="calibre1">Declare a constant <code class="calibre9">Int</code> called <code class="calibre9">myAge</code> and set it equal to your age. Also, declare an <code class="calibre9">Int</code> variable called <code class="calibre9">dogs</code> and set it equal to the number of dogs you own. Then imagine you bought a new puppy and increment the <code class="calibre9">dogs</code> variable by one.
</p>
<h3 class="segment-title2">Challenge 2: Make it compile</h3>

<p class="calibre1">Given the following code:
</p><pre class="code-block">age: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>
<span class="hljs-built_in">print</span>(age)
age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>
<span class="hljs-built_in">print</span>(age)</pre>
<p class="calibre1">Modify the first line so that it compiles.  Did you use <code class="calibre9">var</code> or <code class="calibre9">let</code>?
</p>
<h3 class="segment-title2">Challenge 3: Compute the answer</h3>

<p class="calibre1">Consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">46</span>
<span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span></pre>
<p class="calibre1">Work out what <code class="calibre9">answer</code> equals when you add the following lines of code:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">let</span> answer1: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> (x <span class="hljs-operator">*</span> <span class="hljs-number">100</span>) <span class="hljs-operator">+</span> y 
<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">let</span> answer2: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> (x <span class="hljs-operator">*</span> <span class="hljs-number">100</span>) <span class="hljs-operator">+</span> (y <span class="hljs-operator">*</span> <span class="hljs-number">100</span>)  
<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">let</span> answer3: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> (x <span class="hljs-operator">*</span> <span class="hljs-number">100</span>) <span class="hljs-operator">+</span> (y <span class="hljs-operator">/</span> <span class="hljs-number">10</span>)</pre>
<h3 class="segment-title2">Challenge 4: Add parentheses</h3>

<p class="calibre1">Add as many parentheses to the following calculation, ensuring that it doesn’t change the result of the calculation.
</p><pre class="code-block"><span class="hljs-number">8</span> <span class="hljs-operator">-</span> <span class="hljs-number">4</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-number">6</span> <span class="hljs-operator">/</span> <span class="hljs-number">3</span> <span class="hljs-operator">*</span> <span class="hljs-number">4</span></pre>
<h3 class="segment-title2">Challenge 5: Average rating</h3>

<p class="calibre1">Declare three constants called <code class="calibre9">rating1</code>, <code class="calibre9">rating2</code> and <code class="calibre9">rating3</code> of type <code class="calibre9">Double</code> and assign each a value. Calculate the average of the three and store the result in a constant named <code class="calibre9">averageRating</code>.
</p>
<h3 class="segment-title2">Challenge 6: Electrical power</h3>

<p class="calibre1">The power of an electrical appliance is calculated by multiplying the voltage by the current. Declare a constant named <code class="calibre9">voltage</code> of type <code class="calibre9">Double</code> and assign it a value. Then declare a constant called <code class="calibre9">current</code> of type <code class="calibre9">Double</code> and assign it a value. Finally, calculate the power of the electrical appliance you’ve just created, storing it in a constant called <code class="calibre9">power</code> of type <code class="calibre9">Double</code>.
</p>
<h3 class="segment-title2">Challenge 7: Electrical resistance</h3>

<p class="calibre1">The resistance of such an appliance can then be calculated (in a long-winded way) as the power divided by the current squared. Calculate the resistance and store it in a constant called <code class="calibre9">resistance</code> of type <code class="calibre9">Double</code>.
</p>
<h3 class="segment-title2">Challenge 8: Random integer</h3>

<p class="calibre1">You can create a random integer number by using the function <code class="calibre9">arc4random()</code>. This picks a number anywhere between 0 and 4294967295. You can use the modulo operator to truncate this random number to whatever range you want. Declare a constant <code class="calibre9">randomNumber</code> and assign it a random number generated with <code class="calibre9">arc4random()</code>. Then calculate a constant called <code class="calibre9">diceRoll</code> and use the random number you just found to create a random number between 1 and 6.  (<em class="calibre5">Hint</em>: You will need to include the line <code class="calibre9">import Foundation</code> to get access to <code class="calibre9">arc4random()</code>. If this method of creating a random number seems primitive, you are right! There is an easier, more clear and expressive way to generate random numbers you will learn about in Chapter 4, “Advanced Control Flow”.)
</p>
<h3 class="segment-title2">Challenge 9: Quadratic equations</h3>

<p class="calibre1">A quadratic equation is something of the form <code class="calibre9">a⋅x² + b⋅x + c = 0</code>. The values of <code class="calibre9">x</code> which satisfy this can be solved by using the equation <code class="calibre9">x = (-b ± sqrt(b² - 4⋅a⋅c)) / (2⋅a)</code>. Declare three constants named <code class="calibre9">a</code>, <code class="calibre9">b</code> and <code class="calibre9">c</code> of type <code class="calibre9">Double</code>.  Then calculate the two values for <code class="calibre9">x</code> using the equation above (noting that the ± means plus or minus &mdash; so one value of <code class="calibre9">x</code> for each). Store the results in constants called <code class="calibre9">root1</code> and <code class="calibre9">root2</code> of type <code class="calibre9">Double</code>.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Computers, at their most fundamental level, perform simple mathematics.
</p></li>

<li class="calibre4">
<p class="calibre1">A programming language allows you to write code, which the compiler converts into instructions that the CPU can execute.
</p></li>

<li class="calibre4">
<p class="calibre1">Computers operate on numbers in base 2 form, otherwise known as binary.
</p></li>

<li class="calibre4">
<p class="calibre1">The IDE you use to write Swift code is named Xcode.
</p></li>

<li class="calibre4">
<p class="calibre1">By providing immediate feedback about how code is executing, playgrounds allow you to write and test Swift code quickly and efficiently.
</p></li>

<li class="calibre4">
<p class="calibre1">Code comments are denoted by a line starting with <code class="calibre9">//</code> or multiple lines bookended with <code class="calibre9">/*</code> and <code class="calibre9">*/</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">You use comments to document your code.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use <code class="calibre9">print</code> to output information to the debug area.
</p></li>

<li class="calibre4">
<p class="calibre1">The arithmetic operators are:
</p><pre class="code-block"><span class="hljs-built_in">Add</span>: <span class="hljs-operator">+</span>
<span class="hljs-built_in">Subtract</span>: <span class="hljs-operator">-</span>
<span class="hljs-built_in">Multiply</span>: <span class="hljs-operator">*</span>
<span class="hljs-built_in">Divide</span>: <span class="hljs-operator">/</span>
<span class="hljs-built_in">Remainder</span>: <span class="hljs-operator">%</span></pre></li>

<li class="calibre4">
<p class="calibre1">Swift makes many functions <code class="calibre9">min()</code>, <code class="calibre9">max()</code>, <code class="calibre9">squareRoot()</code>, <code class="calibre9">sin()</code> and <code class="calibre9">cos()</code>.  You will learn many more throughout this book.
</p></li>

<li class="calibre4">
<p class="calibre1">Constants and variables give names to data.
</p></li>

<li class="calibre4">
<p class="calibre1">Once you’ve declared a constant, you can’t change its data, but you can change a variable’s data at any time.
</p></li>

<li class="calibre4">
<p class="calibre1">Always give variables and constants meaningful names to save yourself and your colleagues headaches later.
</p></li>

<li class="calibre4">
<p class="calibre1">Operators to perform arithmetic and then assign back to the variable:
</p><pre class="code-block"><span class="hljs-built_in">Add</span> and assign: <span class="hljs-operator">+=</span>
<span class="hljs-built_in">Subtract</span> and assign: <span class="hljs-operator">-=</span>
<span class="hljs-built_in">Multiply</span> and assign: <span class="hljs-operator">*=</span>
<span class="hljs-built_in">Divide</span> and assign: <span class="hljs-operator">/=</span></pre></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-39">


<h1 class="segment-chapter">Chapter 2: Types &amp; Operations</h1>

<p class="calibre1">Now that you know how to perform basic operations and manipulate data using these operations, it’s time to learn more about <em class="calibre5">types</em>.  Formally, a <em class="calibre5">type</em> describes a set of values and the operations that can be performed on them. In this chapter, you’ll learn about handling different types, including strings that allow you to represent text. You’ll learn about converting between types, and you’ll also be introduced to type inference which makes your life as a programmer a lot simpler. Finally, you’ll learn about tuple types, which allow you to group values of any type together.
</p>
<h2 class="segment-chapter1">Type conversion</h2>

<p class="calibre1">Sometimes you’ll have data in one format and need to convert it to another. The naïve way to attempt this would be like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> integer: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">var</span> decimal: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.5</span>
integer <span class="hljs-operator">=</span> decimal</pre>
<p class="calibre1">Swift will complain if you try to do this and spit out an error on the third line:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Cannot assign value of type 'Double' to type 'Int'</code>
</p></div>

<p class="calibre1">Some programming languages aren’t as strict and will perform conversions like this silently. Experience shows this kind of silent, automatic conversion is a source of software bugs and often hurts performance. Swift disallows you from assigning a value of one type to another and avoids these issues.
</p>
<p class="calibre1">Remember, computers rely on us programmers to tell them what to do. In Swift, that includes being explicit about type conversions. If you want the conversion to happen, you have to say so!
</p>
<p class="calibre1">Instead of simply assigning, you need to say that you want to convert the type explicitly. You do it like so:
</p><pre class="code-block">integer <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>(decimal)</pre>
<p class="calibre1">The assignment on the third line now tells Swift unequivocally that you want to convert from the original type, <code class="calibre9">Double</code>, to the new type, <code class="calibre9">Int</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In this case, assigning the decimal value to the integer results in a loss of precision: The <code class="calibre9">integer</code> variable ends up with the value <code class="calibre9">12</code> instead of <code class="calibre9">12.5</code>. This is why it’s important to be explicit. Swift wants to make sure you know what you’re doing and that you may end up losing data by performing the type conversion.
</p></div>

<h3 class="segment-title2">Operators with mixed types</h3>

<p class="calibre1">So far, you’ve only seen operators acting independently on integers or doubles. But what if you have an integer that you want to multiply by a double?
</p>
<p class="calibre1">You might think you could do it like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> hourlyRate: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">19.5</span>
<span class="hljs-keyword">let</span> hoursWorked: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">let</span> totalCost: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> hourlyRate <span class="hljs-operator">*</span> hoursWorked</pre>
<p class="calibre1">If you try that, you’ll get an error on the final line:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Binary operator '*' cannot be applied to operands of type 'Double' and 'Int'</code>
</p></div>

<p class="calibre1">This is because, in Swift, you can’t apply the <code class="calibre9">*</code> operator to mixed types. This rule also applies to the other arithmetic operators. It may seem surprising at first, but Swift is being rather helpful.
</p>
<p class="calibre1">Swift forces you to be explicit about what you mean when you want an <code class="calibre9">Int</code> multiplied by a <code class="calibre9">Double</code> because the result can be only <i class="calibre2">one</i> type. Do you want the result to be an <code class="calibre9">Int</code>, converting the <code class="calibre9">Double</code> to an <code class="calibre9">Int</code> before performing the multiplication? Or do you want the result to be a <code class="calibre9">Double</code>, converting the <code class="calibre9">Int</code> to a <code class="calibre9">Double</code> before performing the multiplication?
</p>
<p class="calibre1">In this example, you want the result to be a <code class="calibre9">Double</code>. You don’t want an <code class="calibre9">Int</code> because in that case, Swift would convert the <code class="calibre9">hourlyRate</code> constant into an <code class="calibre9">Int</code> to perform the multiplication, rounding it down to 19 and losing the precision of the <code class="calibre9">Double</code>.
</p>
<p class="calibre1">You need to tell Swift you want it to consider the <code class="calibre9">hoursWorked</code> constant to be a <code class="calibre9">Double</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> totalCost: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> hourlyRate <span class="hljs-operator">*</span> <span class="hljs-built_in">Double</span>(hoursWorked)</pre>
<p class="calibre1">Now, each of the operands will be a <code class="calibre9">Double</code> when Swift multiplies them, so <code class="calibre9">totalCost</code> is a <code class="calibre9">Double</code> as well.
</p>
<h3 class="segment-title2">Type inference</h3>

<p class="calibre1">Every variable or constant you’ve seen in this book so far includes a type annotation. You may be asking yourself why you need to bother writing the <code class="calibre9">: Int</code> and <code class="calibre9">: Double</code>, since the right-hand side of the assignment <i class="calibre2">is already</i> an <code class="calibre9">Int</code> or a <code class="calibre9">Double</code>. It’s redundant, to be sure; your crazy-clever brain can see this without too much work.
</p>
<p class="calibre1">It turns out the Swift compiler can deduce this as well. It doesn’t need you to tell it the type all the time &mdash; it can figure it out on its own. This is done through a process called <em class="calibre5">type inference</em>. Not all programming languages have this, but Swift does, and it’s a key component of Swift’s power as a language.
</p>
<p class="calibre1">So, you can simply drop the type in most places where you see one.
</p>
<p class="calibre1">For example, consider the following constant declaration:
</p><pre class="code-block"><span class="hljs-keyword">let</span> typeInferredInt <span class="hljs-operator">=</span> <span class="hljs-number">42</span></pre>
<p class="calibre1">Sometimes it’s useful to check the inferred type of a variable or constant. You can do this in a playground by holding down the <em class="calibre5">Option</em> key and clicking on the variable or constant’s name. Xcode will display a popover like this:
</p><div class="image1"><img src="images/000000.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Xcode tells you the inferred type by giving you the declaration you would have used without type inference. In this case, the type is <code class="calibre9">Int</code>.
</p>
<p class="calibre1">It works for other types, too:
</p><pre class="code-block"><span class="hljs-keyword">let</span> typeInferredDouble <span class="hljs-operator">=</span> <span class="hljs-number">3.14159</span></pre>
<p class="calibre1">Option-clicking on this reveals the following:
</p><div class="image1"><img src="images/000011.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can see from this that type inference isn’t magic. Swift is simply doing what your brain does very easily. Programming languages that don’t use type inference can often feel verbose because you must specify the often obvious type each time you declare a variable or constant.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In later chapters, you’ll learn about more complex types where sometimes Swift can’t infer the type. That’s a pretty rare case, though, and you’ll see type inference used for most of the code examples in this book &mdash; except in cases where we want to highlight the type for you.
</p></div>

<p class="calibre1">Sometimes you want to define a constant or variable and ensure it’s a certain type, even though what you’re assigning to it is a different type. You saw earlier how you could convert from one type to another. For example, consider the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> wantADouble <span class="hljs-operator">=</span> <span class="hljs-number">3</span></pre>
<p class="calibre1">Here, Swift infers the type of <code class="calibre9">wantADouble</code> as <code class="calibre9">Int</code>. But what if you wanted <code class="calibre9">Double</code> instead?
</p>
<p class="calibre1">The first thing you could do is the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> actuallyDouble <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(<span class="hljs-number">3</span>)</pre>
<p class="calibre1">This is like you saw before with type conversion.
</p>
<p class="calibre1">Another option would be to not use type inference at all and do the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> actuallyDouble: <span class="hljs-built_in">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span></pre>
<p class="calibre1">There is a third option, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> actuallyDouble <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">Double</span></pre>
<p class="calibre1">This uses a new keyword you haven’t seen before, <code class="calibre9">as</code>. It also performs a type conversion, and you’ll see it again later in this book.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Literal values like <code class="calibre9">3</code> don’t have a type, and it’s only when using them in an expression or assigning them to a constant or variable that Swift infers a type for them.
</p></div>

<div class="note">
<p class="calibre10">A literal number value that doesn’t contain a decimal point can be used as an <code class="calibre9">Int</code> as well as a <code class="calibre9">Double</code>. This is why you’re allowed to assign the value <code class="calibre9">3</code> to constant <code class="calibre9">actuallyDouble</code>.
</p>
<p class="calibre10">Literal number values that <i class="calibre2">do</i> contain a decimal point cannot be integers. This means we could have avoided this entire discussion had we started with:
</p>
<p class="calibre10"><code class="calibre9">let wantADouble = 3.0</code>
</p>
<p class="calibre10">Sorry! :]
</p></div>

<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant called <code class="calibre9">age1</code> and set it equal to <code class="calibre9">42</code>. Create a constant called <code class="calibre9">age2</code> and set it equal to <code class="calibre9">21</code>. Check using Option-click that the type for both has been inferred correctly as <code class="calibre9">Int</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant called <code class="calibre9">avg1</code> and set it equal to the average of <code class="calibre9">age1</code> and <code class="calibre9">age2</code> using the naïve operation <code class="calibre9">(age1 + age2) / 2</code>. Use Option-click to check the type and check the result of <code class="calibre9">avg1</code>. Why is it wrong?
</p></li>

<li class="calibre4">
<p class="calibre1">Correct the mistake in the above exercise by converting <code class="calibre9">age1</code> and <code class="calibre9">age2</code> to type <code class="calibre9">Double</code> in the formula. Use Option-click to check the type and check the result of <code class="calibre9">avg1</code>. Why is it now correct?
</p></li>
</ol>

<h2 class="segment-chapter1">Strings</h2>

<p class="calibre1">Numbers are essential in programming, but they aren’t the only type of data you need to work within your apps. Text is also an extremely common data type used to represent things like people’s names, addresses, or even the words of a book. All of these are examples of text that an app might need to handle.
</p>
<p class="calibre1">Most computer programming languages store text in a data type called a <em class="calibre5">string</em>. This chapter introduces you to strings, first by giving you background on the concept of strings and then showing you how to use them in Swift.
</p>
<h3 class="segment-title2">How computers represent strings</h3>

<p class="calibre1">Computers think of strings as a collection of individual <em class="calibre5">characters</em>. In Chapter 1, “Expressions, Variables &amp; Constants”, you learned that numbers are the language of CPUs, and all code, in whatever programming language, can be reduced to raw numbers. Strings are no different!
</p>
<p class="calibre1">That may sound very strange. How can characters be numbers? At its base, a computer needs to translate a character into the computer’s language, and it does so by assigning each character a different number. This forms a two-way mapping from character to number that is called a <em class="calibre5">character set</em>.
</p>
<p class="calibre1">When you press a character key on your keyboard, you are actually communicating the number of the character to the computer. Your word processor application converts that number into a picture of the character or glyph, which gets presented to you.
</p>
<h3 class="segment-title2">Unicode</h3>

<p class="calibre1">In isolation, a computer is free to choose whatever character set mapping it likes. If the computer wants the letter <em class="calibre5">a</em> to equal the number 10, then so be it. But when computers start talking to each other, they need to use a common character set.
</p>
<p class="calibre1">If two computers used different character sets, then when one computer transferred a string to the other, they would end up thinking the strings contained different characters.
</p>
<p class="calibre1">There have been several standards over the years, but the most modern standard is <em class="calibre5">Unicode</em>, and it defines the character set mapping that almost all computers use today.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can read more about Unicode at its official website, <a href="http://unicode.org/" class="calibre6">http://unicode.org/</a>.
</p></div>

<p class="calibre1">As an example, consider the word <em class="calibre5">cafe</em>. The Unicode standard tells us that the letters of this word should be mapped to numbers like so:
</p><div class="image2"><img src="images/000024.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The number associated with each character is called a <em class="calibre5">code point</em>. So in the example above, <em class="calibre5">c</em> uses code point 99, <em class="calibre5">a</em> uses code point 97, and so on.
</p>
<p class="calibre1">Of course, Unicode is not just for the simple Latin characters used in English, such as <em class="calibre5">c</em>, <em class="calibre5">a</em>, <em class="calibre5">f</em> and <em class="calibre5">e</em>. It also lets you map characters from languages around the world. The word <em class="calibre5">cafe</em>, as you’re probably aware, is derived from French, in which it’s written as <em class="calibre5">café</em>. Unicode maps these characters like so:
</p><div class="image2"><img src="images/000038.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">And here’s an example using Chinese characters (this, according to Google translate, means “Computer Programming”):
</p><div class="image2"><img src="images/000051.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You’ve probably heard of emojis, which are small pictures you can use in your text. These pictures are, in fact, just normal characters and are also mapped by Unicode. For example:
</p><div class="image2"><img src="images/000063.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">This is only two characters. The code points for these are very large numbers, but each is still only a single code point. The computer considers these as no different than any other two characters.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The word “emoji” comes from Japanese, where “e” means picture and “moji” means character.
</p></div>

<h2 class="segment-chapter1">Strings in Swift</h2>

<p class="calibre1">Swift, like any reasonable programming language, can work directly with characters and strings. It does so through the data types <code class="calibre9">Character</code> and <code class="calibre9">String</code>, respectively. In this section, you’ll learn about these data types and how to work with them.
</p>
<h3 class="segment-title2">Characters and strings</h3>

<p class="calibre1">The <code class="calibre9">Character</code> data type can store a single character. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> characterA: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span></pre>
<p class="calibre1">This stores the character <em class="calibre5">a</em>. It can hold any character &mdash; even an emoji:
</p><pre class="code-block"><span class="hljs-keyword">let</span> characterDog: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"🐶"</span></pre>
<p class="calibre1">But this data type is designed to hold only single characters. The <code class="calibre9">String</code> data type, on the other hand, stores multiple characters. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> stringDog: <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span></pre>
<p class="calibre1">It’s as simple as that! The right-hand side of this expression is known as a <em class="calibre5">string literal</em>; it’s the Swift syntax for representing a string.
</p>
<p class="calibre1">Of course, type inference applies here as well. If you remove the type in the above declaration, then Swift does the right thing and makes the <code class="calibre9">stringDog</code> a <code class="calibre9">String</code> constant:
</p><pre class="code-block"><span class="hljs-keyword">let</span> stringDog <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span> <span class="hljs-comment">// Inferred to be of type String</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: There’s no such thing as a character literal in Swift. A character is simply a string of length one. However, Swift infers the type of any string literal to be <code class="calibre9">String</code>, so if you want a <code class="calibre9">Character</code> instead, you must make the type explicit.
</p></div>

<h3 class="segment-title2">Concatenation</h3>

<p class="calibre1">You can do much more than create simple strings. Sometimes you need to manipulate a string, and one common way to do so is to combine it with another string.
</p>
<p class="calibre1">In Swift, you do this in a rather simple way: by using the addition operator. Just as you can add numbers, you can add strings:
</p><pre class="code-block"><span class="hljs-keyword">var</span> message <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span> <span class="hljs-operator">+</span> <span class="hljs-string">" my name is "</span>
<span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Matt"</span>
message <span class="hljs-operator">+=</span> name <span class="hljs-comment">// "Hello my name is Matt"</span></pre>
<p class="calibre1">You need to declare <code class="calibre9">message</code> as a variable rather than a constant because you want to modify it. You can add string literals together, as in the first line, and add string variables or constants together, as in the last line.
</p>
<p class="calibre1">It’s also possible to add characters to a string. However, Swift’s strictness with types means you have to be explicit when doing so, just as you have to be when you work with numbers if one is an <code class="calibre9">Int</code> and the other is a <code class="calibre9">Double</code>.
</p>
<p class="calibre1">To add a character to a string, you do this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> exclamationMark: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"!"</span>
message <span class="hljs-operator">+=</span> <span class="hljs-built_in">String</span>(exclamationMark) <span class="hljs-comment">// "Hello my name is Matt!"</span></pre>
<p class="calibre1">With this code, you explicitly convert the <code class="calibre9">Character</code> to a <code class="calibre9">String</code> before adding it to <code class="calibre9">message</code>.
</p>
<h3 class="segment-title2">Interpolation</h3>

<p class="calibre1">You can also build up a string by using <em class="calibre5">interpolation</em>, which is a special Swift syntax that lets you build a string in a way that’s easy to read:
</p><pre class="code-block">message <span class="hljs-operator">=</span> <span class="hljs-string">"Hello my name is <span class="hljs-subst">\(name)</span>!"</span> <span class="hljs-comment">// "Hello my name is Matt!"</span></pre>
<p class="calibre1">As I’m sure you’ll agree, this is much more readable than the previous section’s example. It’s an extension of the string literal syntax, whereby you replace certain parts of the string with other values. You enclose the value you want to insert in parentheses preceded by a backslash.
</p>
<p class="calibre1">This syntax works, in the same way, to build a string from other data types, such as numbers:
</p><pre class="code-block"><span class="hljs-keyword">let</span> oneThird <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">3.0</span>
<span class="hljs-keyword">let</span> oneThirdLongString <span class="hljs-operator">=</span> <span class="hljs-string">"One third is <span class="hljs-subst">\(oneThird)</span> as a decimal."</span></pre>
<p class="calibre1">Here, you use a <code class="calibre9">Double</code> in the interpolation. At the end of this code, your <code class="calibre9">oneThirdLongString</code> constant will contain the following:
</p>
<div class="note">
<p class="calibre10">One third is 0.3333333333333333 as a decimal.
</p></div>

<p class="calibre1">Of course, it would take infinite characters to represent one-third as a decimal because it’s a repeating decimal. String interpolation with a <code class="calibre9">Double</code> gives you no way to control the precision of the resulting string. This is an unfortunate consequence of using string interpolation: It’s simple to use but offers no ability to customize the output.
</p>
<h3 class="segment-title2">Multi-line strings</h3>

<p class="calibre1">Swift has a neat way to express strings that contain multiple lines. This can be rather useful when you need to put a very long string in your code.
</p>
<p class="calibre1">You do it like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> bigString <span class="hljs-operator">=</span> <span class="hljs-string">"""
  You can have a string
  that contains multiple
  lines
  by
  doing this.
  """</span>
<span class="hljs-built_in">print</span>(bigString)</pre>
<p class="calibre1">The three double-quotes signify that this is a multiline string. Handily, the first and final newlines do not become part of the string. This makes it more flexible as you don’t have to have the three double-quotes on the same line as the string.
</p>
<p class="calibre1">In the case above, it will print the following:
</p><pre class="code-block"><span class="hljs-built_in">You</span> can have a string
that contains multiple
lines
by
doing this.</pre>
<p class="calibre1">Notice that the two-space margin in the multiline string literal is stripped out of the result. Swift looks at the number of leading spaces on the final three double-quotes line. Using this as a baseline, Swift requires that all lines above it have at least that much space so it can remove it from each line. This lets you format your code with pretty indentation without affecting the output.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a string constant called <code class="calibre9">firstName</code> and initialize it to your first name. Also, create a string constant called <code class="calibre9">lastName</code> and initialize it to your last name.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a string constant called <code class="calibre9">fullName</code> by adding the <code class="calibre9">firstName</code> and <code class="calibre9">lastName</code> constants together, separated by a space.
</p></li>

<li class="calibre4">
<p class="calibre1">Using interpolation, create a string constant called <code class="calibre9">myDetails</code> that uses the <code class="calibre9">fullName</code> constant to create a string introducing yourself. For example, my string would read: <code class="calibre9">"Hello, my name is Matt Galloway."</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Tuples</h2>

<p class="calibre1">Sometimes data comes in pairs or triplets. An example of this is a pair of (x, y) coordinates on a 2D grid. Similarly, a set of coordinates on a 3D grid is comprised of an x-value, a y-value and a z-value. In Swift, you can represent such related data in a straightforward way through the use of a <i class="calibre2">tuple</i>.
</p>
<p class="calibre1">A tuple is a type that represents data composed of more than one value of any type. You can have as many values in your tuple as you like. For example, you can define a pair of 2D coordinates where each axis value is an integer, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) <span class="hljs-operator">=</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</pre>
<p class="calibre1">The type of <code class="calibre9">coordinates</code> is <code class="calibre9">(Int, Int)</code>. The types of the values within the tuple, in this case, <code class="calibre9">Int</code>, are separated by commas and surrounded by parentheses. The code for creating the tuple is much the same, with each value separated by commas and surrounded by parentheses.
</p>
<p class="calibre1">Type inference can infer tuple types too:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</pre>
<p class="calibre1">You could similarly create a tuple of <code class="calibre9">Double</code> values, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinatesDoubles <span class="hljs-operator">=</span> (<span class="hljs-number">2.1</span>, <span class="hljs-number">3.5</span>)
<span class="hljs-comment">// Inferred to be of type (Double, Double)</span></pre>
<p class="calibre1">Or you could mix and match the types comprising the tuple, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinatesMixed <span class="hljs-operator">=</span> (<span class="hljs-number">2.1</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// Inferred to be of type (Double, Int)</span></pre>
<p class="calibre1">And here’s how to access the data inside a tuple:
</p><pre class="code-block"><span class="hljs-keyword">let</span> x1 <span class="hljs-operator">=</span> coordinates.<span class="hljs-number">0</span>
<span class="hljs-keyword">let</span> y1 <span class="hljs-operator">=</span> coordinates.<span class="hljs-number">1</span></pre>
<p class="calibre1">You can reference each item by its position in the tuple, starting with zero. So in this example, <code class="calibre9">x1</code> will equal <code class="calibre9">2</code> and <code class="calibre9">y1</code> will equal <code class="calibre9">3</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Starting with zero is a common convention in computer programming called <em class="calibre5">zero indexing</em>. You’ll see this again in Chapter 7, “Arrays, Dictionaries &amp; Sets.”
</p></div>

<p class="calibre1">In the previous example, it may not be immediately obvious that the first value, at index <code class="calibre9">0</code>, is the x-coordinate, and the second value, at index <code class="calibre9">1</code>, is the y-coordinate. This is another demonstration of why it’s important to <i class="calibre2">always</i> name your variables in a way that avoids confusion.
</p>
<p class="calibre1">Fortunately, Swift allows you to name the individual parts of a tuple, and you can be explicit about what each part represents. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinatesNamed <span class="hljs-operator">=</span> (x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span>)
<span class="hljs-comment">// Inferred to be of type (x: Int, y: Int)</span></pre>
<p class="calibre1">Here, the code annotates the values of <code class="calibre9">coordinatesNamed</code> to contain a label for each part of the tuple.
</p>
<p class="calibre1">Then, when you need to access each part of the tuple, you can access it by its name:
</p><pre class="code-block"><span class="hljs-keyword">let</span> x2 <span class="hljs-operator">=</span> coordinatesNamed.x
<span class="hljs-keyword">let</span> y2 <span class="hljs-operator">=</span> coordinatesNamed.y</pre>
<p class="calibre1">This is much clearer and easier to understand. More often than not, it’s helpful to name the components of your tuples.
</p>
<p class="calibre1">If you want to access multiple parts of the tuple at the same time, as in the examples above, you can also use a shorthand syntax to make it easier:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates3D <span class="hljs-operator">=</span> (x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span>, z: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> (x3, y3, z3) <span class="hljs-operator">=</span> coordinates3D</pre>
<p class="calibre1">This declares three new constants, <code class="calibre9">x3</code>, <code class="calibre9">y3</code> and <code class="calibre9">z3</code>, and assigns each part of the tuple to them in turn. The code is equivalent to the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates3D <span class="hljs-operator">=</span> (x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span>, z: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> x3 <span class="hljs-operator">=</span> coordinates3D.x
<span class="hljs-keyword">let</span> y3 <span class="hljs-operator">=</span> coordinates3D.y
<span class="hljs-keyword">let</span> z3 <span class="hljs-operator">=</span> coordinates3D.z</pre>
<p class="calibre1">If you want to ignore a certain element of the tuple, you can replace the corresponding part of the declaration with an underscore. For example, if you were performing a 2D calculation and wanted to ignore the z-coordinate of <code class="calibre9">coordinates3D</code>, you’d write the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> (x4, y4, <span class="hljs-keyword">_</span>) <span class="hljs-operator">=</span> coordinates3D</pre>
<p class="calibre1">This line of code only declares <code class="calibre9">x4</code> and <code class="calibre9">y4</code>. The <code class="calibre9">_</code> is special and simply means you’re ignoring this part for now.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You’ll find that you can use the underscore (also called the wildcard operator) throughout Swift to ignore a value.
</p></div>

<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Declare a constant tuple that contains three <code class="calibre9">Int</code> values followed by a <code class="calibre9">Double</code>. Use this to represent a date (month, day, year) followed by an average temperature for that date.
</p></li>
</ol>

<ol start="2" class="calibre11">
<li class="calibre4">
<p class="calibre1">Change the tuple to name the constituent components. Give them names related to the data they contain: <code class="calibre9">month</code>, <code class="calibre9">day</code>, <code class="calibre9">year</code> and <code class="calibre9">averageTemperature</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">In one line, read the day and average temperature values into two constants. You’ll need to employ the underscore to ignore the month and year.
</p></li>

<li class="calibre4">
<p class="calibre1">Up until now, you’ve only seen constant tuples. But you can create variable tuples, too. Change the tuple you created in the exercises above to a variable by using <code class="calibre9">var</code> instead of <code class="calibre9">let</code>. Now change the average temperature to a new value.
</p></li>
</ol>

<h2 class="segment-chapter1">A whole lot of number types</h2>

<p class="calibre1">You’ve been using <code class="calibre9">Int</code> to represent whole numbers. An <code class="calibre9">Int</code> is represented with 64 bits on most modern hardware and with 32 bits on older or more resource-constrained systems. Swift provides many more number types that use different amounts of storage.  For whole numbers, you can use the explicit <em class="calibre5">signed</em> types <code class="calibre9">Int8</code>, <code class="calibre9">Int16</code>, <code class="calibre9">Int32</code>, <code class="calibre9">Int64</code>.  These types consume 1, 2, 4, and 8 bytes of storage, respectively.  Each of these types use 1 bit to represent the sign.
</p>
<p class="calibre1">If you are only dealing with non-negative values, there is a set of explicit <em class="calibre5">unsigned</em> types that you can use. These include <code class="calibre9">UInt8</code>, <code class="calibre9">UInt16</code>, <code class="calibre9">UInt32</code> and <code class="calibre9">UInt64</code>. While you cannot represent negative values with these, the extra 1 bit lets you represent values twice as big as their <em class="calibre5">signed</em> counterparts.
</p>
<p class="calibre1">Here is a summary of the different integer types and their storage size in bytes. Most of the time, you will just want to use an <code class="calibre9">Int</code>.
</p>
<p class="calibre1">These become useful if your code interacts with another piece of software that uses one of these more exact sizes or needs to optimize for storage size.
</p><div class="image4"><img src="images/000073.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You’ve been using <code class="calibre9">Double</code> to represent fractional numbers. Swift offers a <code class="calibre9">Float</code> type with less range and precision than <code class="calibre9">Double</code> but requires half as much storage. Modern hardware has been optimized for <code class="calibre9">Double</code>, so it should be your go-to unless there is good reason to use a <code class="calibre9">Float</code>.
</p><div class="image4"><img src="images/000085.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Most of the time, you will just use <code class="calibre9">Int</code> and <code class="calibre9">Double</code> to represent numbers, but you might encounter the other types every once in a while.
</p>
<p class="calibre1">For example, suppose you need to add together an <code class="calibre9">Int16</code> with a <code class="calibre9">UInt8</code> and an <code class="calibre9">Int32</code>. You can do that like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">Int16</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>
<span class="hljs-keyword">let</span> b: <span class="hljs-built_in">UInt8</span> <span class="hljs-operator">=</span> <span class="hljs-number">255</span>
<span class="hljs-keyword">let</span> c: <span class="hljs-built_in">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">100000</span>

<span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>(a) <span class="hljs-operator">+</span> <span class="hljs-built_in">Int</span>(b) <span class="hljs-operator">+</span> <span class="hljs-built_in">Int</span>(c)  <span class="hljs-comment">// answer is an Int</span></pre>
<h2 class="segment-chapter1">Type aliases</h2>

<p class="calibre1">A useful feature of Swift is being able to create your own type which is an alias of another type. What this means you can do is give a more useful name to your type that describes what it is, but underneath, it’s just another type. This is known as a <em class="calibre5">type alias</em>.
</p>
<p class="calibre1">It’s simple to create a type alias, like so:
</p><pre class="code-block"><span class="hljs-keyword">typealias</span> <span class="hljs-built_in">Animal</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span></pre>
<p class="calibre1">This creates a new type called <code class="calibre9">Animal</code>. When the compiler sees this type, it simply treats it as a <code class="calibre9">String</code>. Therefore you could do something like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> myPet: <span class="hljs-built_in">Animal</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span></pre>
<p class="calibre1">This might not seem useful right now, but sometimes types can become complex and creating an alias for them can give them a simpler and more explicit name. For example, you might do the following:
</p><pre class="code-block"><span class="hljs-keyword">typealias</span> <span class="hljs-built_in">Coordinates</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">let</span> xy: <span class="hljs-built_in">Coordinates</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</pre>
<p class="calibre1">This creates a type called <code class="calibre9">Coordinates</code>, a tuple containing two <code class="calibre9">Int</code>s and then uses it.
</p>
<p class="calibre1">As you see more and more Swift, you’ll see how type aliases can be very powerful and simplify code.
</p>
<h2 class="segment-chapter1">A peek behind the curtains: Protocols</h2>

<p class="calibre1">Even though there are a dozen different numeric types, they are easy to understand and use because they all roughly support the same operations. In other words, once you know how to use an <code class="calibre9">Int</code>, using any one of the flavors is straightforward.
</p>
<p class="calibre1">One of Swift’s truly great features is that it formalizes the idea of type commonality using what are known as <em class="calibre5">protocols</em>. By learning the protocol, you instantly understand how an entire family of types using that protocol work.
</p>
<p class="calibre1">In the case of integers, the functionality can be diagrammed like so:
</p><div class="image"><img src="images/000108.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The arrows indicate conformance to (sometimes called <i class="calibre2">adoption of</i>) a protocol. While this graph does not show all of the protocols that integer types conform to &mdash; it gives you insight into how things are organized.
</p>
<p class="calibre1">Swift is the first protocol-based language. As you begin to understand the protocols that underlie the types, you can leverage the system in ways not possible with other languages.
</p>
<p class="calibre1">By the end of this book, you’ll be hooking into existing protocols and even creating new ones of your own.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of types and operations. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Coordinates</h3>

<p class="calibre1">Create a constant called <code class="calibre9">coordinates</code> and assign a tuple containing two and three to it.
</p>
<h3 class="segment-title2">Challenge 2: Named coordinate</h3>

<p class="calibre1">Create a constant called <code class="calibre9">namedCoordinate</code> with a <code class="calibre9">row</code> and <code class="calibre9">column</code> component.
</p>
<h3 class="segment-title2">Challenge 3: Which are valid?</h3>

<p class="calibre1">Which of the following are valid statements?
</p><pre class="code-block"><span class="hljs-keyword">let</span> character: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span>
<span class="hljs-keyword">let</span> character: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"🐶"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span>
<span class="hljs-keyword">let</span> string: <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">"🐶"</span></pre>
<h3 class="segment-title2">Challenge 4. Does it compile?</h3>
<pre class="code-block"><span class="hljs-keyword">let</span> tuple <span class="hljs-operator">=</span> (day: <span class="hljs-number">15</span>, month: <span class="hljs-number">8</span>, year: <span class="hljs-number">2015</span>)
<span class="hljs-keyword">let</span> day <span class="hljs-operator">=</span> tuple.<span class="hljs-built_in">Day</span></pre>
<h3 class="segment-title2">Challenge 5: Find the error</h3>

<p class="calibre1">What is wrong with the following code?
</p><pre class="code-block"><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Matt"</span>
name <span class="hljs-operator">+=</span> <span class="hljs-string">" Galloway"</span></pre>
<h3 class="segment-title2">Challenge 6: What is the type of <code class="calibre12">value</code>?</h3>

<p class="calibre1">What is the type of the constant named <code class="calibre9">value</code>?
</p><pre class="code-block"><span class="hljs-keyword">let</span> tuple <span class="hljs-operator">=</span> (<span class="hljs-number">100</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>)
<span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> tuple.<span class="hljs-number">1</span></pre>
<h3 class="segment-title2">Challenge 7: What is the value of month?</h3>

<p class="calibre1">What is the value of the constant named <code class="calibre9">month</code>?
</p><pre class="code-block"><span class="hljs-keyword">let</span> tuple <span class="hljs-operator">=</span> (day: <span class="hljs-number">15</span>, month: <span class="hljs-number">8</span>, year: <span class="hljs-number">2015</span>)
<span class="hljs-keyword">let</span> month <span class="hljs-operator">=</span> tuple.month</pre>
<h3 class="segment-title2">Challenge 8: What is the value of <code class="calibre12">summary</code>?</h3>

<p class="calibre1">What is the value of the constant named <code class="calibre9">summary</code>?
</p><pre class="code-block"><span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">let</span> multiplier <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> summary <span class="hljs-operator">=</span> <span class="hljs-string">"<span class="hljs-subst">\(number)</span> multiplied by <span class="hljs-subst">\(multiplier)</span> equals <span class="hljs-subst">\(number <span class="hljs-operator">*</span> multiplier)</span>"</span></pre>
<h3 class="segment-title2">Challenge 9: Compute the value</h3>

<p class="calibre1">What is the sum of <code class="calibre9">a</code> and <code class="calibre9">b</code>, minus <code class="calibre9">c</code>?
</p><pre class="code-block"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">4</span>
<span class="hljs-keyword">let</span> b: <span class="hljs-built_in">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">let</span> c: <span class="hljs-built_in">UInt8</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span></pre>
<h3 class="segment-title2">Challenge 10: Different precision 𝜋s</h3>

<p class="calibre1">What is the numeric difference between <code class="calibre9">Double.pi</code> and <code class="calibre9">Float.pi</code>?
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Type conversion allows you to convert values of one type into another.
</p></li>

<li class="calibre4">
<p class="calibre1">Type conversion is required when using an operator, such as the basic arithmetic operators (<code class="calibre9">+</code>, <code class="calibre9">-</code>, <code class="calibre9">*</code>, <code class="calibre9">/</code>), with mixed types.
</p></li>

<li class="calibre4">
<p class="calibre1">Type inference allows you to omit the type when Swift already knows it.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Unicode</em> is the standard for mapping characters to numbers.
</p></li>

<li class="calibre4">
<p class="calibre1">A single mapping in Unicode is called a <em class="calibre5">code point</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">Character</code> data type stores single characters, and the <code class="calibre9">String</code> data type stores collections of characters or strings.
</p></li>

<li class="calibre4">
<p class="calibre1">You can combine strings by using the addition operator.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use <em class="calibre5">string interpolation</em> to build a string in-place.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use tuples to group data into a single data type.
</p></li>

<li class="calibre4">
<p class="calibre1">Tuples can either be unnamed or named. Their elements are accessed with index numbers for unnamed tuples or programmer-given names for named tuples.
</p></li>

<li class="calibre4">
<p class="calibre1">There are many kinds of numeric types with different storage and precision capabilities.
</p></li>

<li class="calibre4">
<p class="calibre1">Type aliases can be used to create a new type that is simply a new name for another type.
</p></li>

<li class="calibre4">
<p class="calibre1">Protocols are how types are organized in Swift, and they describe the operations that multiple types share.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-11">


<h1 class="segment-chapter">Chapter 3: Basic Control Flow</h1>

<p class="calibre1">When writing a computer program, you need to tell the computer what to do in different scenarios. For example, a calculator app would need to do one thing if the user taps the addition button and another thing if the user taps the subtraction button.
</p>
<p class="calibre1">In computer programming terms, this concept is known as <em class="calibre5">control flow</em>, named so because the flow of the program is controlled by various methods. This chapter will teach you how to make decisions and repeat tasks in your programs by using syntax to control the flow. You’ll also learn about <em class="calibre5">Booleans</em>, which represent true and false values, and how you can use these to compare data.
</p>
<h2 class="segment-chapter1">Comparison operators</h2>

<p class="calibre1">You’ve seen a few types now, such as <code class="calibre9">Int</code>, <code class="calibre9">Double</code> and <code class="calibre9">String</code>. Here you’ll learn about another type that lets you compare values through the <em class="calibre5">comparison operators</em>.
</p>
<p class="calibre1">When you perform a comparison, such as looking for the greater of two numbers, the answer is either <i class="calibre2">true</i> or <i class="calibre2">false</i>. Swift has a data type just for this! It’s called a <code class="calibre9">Bool</code>, which is short for Boolean, after a rather clever man named George Boole who invented an entire field of mathematics around the concept of true and false.
</p>
<p class="calibre1">This is how you use a Boolean in Swift:
</p><pre class="code-block"><span class="hljs-keyword">let</span> yes: <span class="hljs-built_in">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">let</span> no: <span class="hljs-built_in">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span></pre>
<p class="calibre1">And because of Swift’s type inference, you can leave off the type annotation:
</p><pre class="code-block"><span class="hljs-keyword">let</span> yes <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">let</span> no <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span></pre>
<p class="calibre1">A Boolean can only be true or false, denoted by the keywords <code class="calibre9">true</code> and <code class="calibre9">false</code>. In the code above, you use the keywords to set the state of each constant.
</p>
<h3 class="segment-title2">Boolean operators</h3>

<p class="calibre1">Booleans are commonly used to compare values. For example, you may have two values, and you want to know if they’re equal: either they are (true), or they aren’t (false).
</p>
<p class="calibre1">In Swift, you do this using the <em class="calibre5">equality operator</em>, which is denoted by <code class="calibre9">==</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> doesOneEqualTwo <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> <span class="hljs-operator">==</span> <span class="hljs-number">2</span>)</pre>
<p class="calibre1">Swift infers that <code class="calibre9">doesOneEqualTwo</code> is a <code class="calibre9">Bool</code>. Clearly, 1 does not equal 2, and therefore <code class="calibre9">doesOneEqualTwo</code> will be <code class="calibre9">false</code>.
</p>
<p class="calibre1">Similarly, you can find out if two values are <i class="calibre2">not</i> equal using the <code class="calibre9">!=</code> operator:
</p><pre class="code-block"><span class="hljs-keyword">let</span> doesOneNotEqualTwo <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> <span class="hljs-operator">!=</span> <span class="hljs-number">2</span>)</pre>
<p class="calibre1">This time, the comparison is true because 1 does not equal 2, so <code class="calibre9">doesOneNotEqualTwo</code> will be <code class="calibre9">true</code>.
</p>
<p class="calibre1">The prefix <code class="calibre9">!</code> operator, also called the not-operator, toggles true to false and false to true.  Another way to write the above is:
</p><pre class="code-block"><span class="hljs-keyword">let</span> alsoTrue <span class="hljs-operator">=</span> <span class="hljs-operator">!</span>(<span class="hljs-number">1</span> <span class="hljs-operator">==</span> <span class="hljs-number">2</span>)</pre>
<p class="calibre1">Because 1 does not equal 2, <code class="calibre9">(1 == 2)</code> is <code class="calibre9">false</code>, and then <code class="calibre9">!</code> flips it to <code class="calibre9">true</code>.
</p>
<p class="calibre1">Two more operators let you determine if a value is greater than (<code class="calibre9">&gt;</code>) or less than (<code class="calibre9">&lt;</code>) another value. You’ll likely know these from mathematics:
</p><pre class="code-block"><span class="hljs-keyword">let</span> isOneGreaterThanTwo <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> isOneLessThanTwo <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span>)</pre>
<p class="calibre1">And it’s not rocket science to work out that <code class="calibre9">isOneGreaterThanTwo</code> will equal <code class="calibre9">false</code> and <code class="calibre9">isOneLessThanTwo</code> will equal <code class="calibre9">true</code>.
</p>
<p class="calibre1">There’s also an operator that lets you test if a value is less than <i class="calibre2">or</i> equal to another value: <code class="calibre9">&lt;=</code>. It’s a combination of <code class="calibre9">&lt;</code> and <code class="calibre9">==</code>, and will therefore return <code class="calibre9">true</code> if the first value is either less than the second value or equal to it.
</p>
<p class="calibre1">Similarly, there’s an operator that lets you test if a value is greater than or equal to another &mdash; you may have guessed that it’s <code class="calibre9">&gt;=</code>.
</p>
<h3 class="segment-title2">Boolean logic</h3>

<p class="calibre1">Each of the examples above tests just one condition. When George Boole invented the Boolean, he had much more planned for it than these humble beginnings. He invented Boolean logic, which lets you combine multiple conditions to form a result.
</p>
<p class="calibre1">One way to combine conditions is by using <em class="calibre5">AND</em>. When you AND together two Booleans, the result is another Boolean. If both input Booleans are <code class="calibre9">true</code>, then the result is <code class="calibre9">true</code>. Otherwise, the result is <code class="calibre9">false</code>.
</p><div class="image5"><img src="images/000015.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">In Swift, the operator for Boolean AND is <code class="calibre9">&amp;&amp;</code>, used like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> and <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">true</span></pre>
<p class="calibre1">In this case, <code class="calibre9">and</code> will be <code class="calibre9">true</code>. If either of the values on the right were <code class="calibre9">false</code>, then <code class="calibre9">and</code> would be <code class="calibre9">false</code>.
</p>
<p class="calibre1">Another way to combine conditions is by using <em class="calibre5">OR</em>. When you OR together two Booleans, the result is <code class="calibre9">true</code> if <i class="calibre2">either</i> of the input Booleans is <code class="calibre9">true</code>. Only if <i class="calibre2">both</i> input Booleans are <code class="calibre9">false</code> will the result be <code class="calibre9">false</code>.
</p>
<p class="calibre1">In Swift, the operator for Boolean OR is <code class="calibre9">||</code>, used like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> or <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">false</span></pre>
<p class="calibre1">In this case, <code class="calibre9">or</code> will be <code class="calibre9">true</code>. If both values on the right were <code class="calibre9">false</code>, then <code class="calibre9">or</code> would be <code class="calibre9">false</code>. If both were <code class="calibre9">true</code>, then <code class="calibre9">or</code> would still be <code class="calibre9">true</code>.
</p>
<p class="calibre1">Swift uses boolean logic to evaluate multiple conditions. Maybe you want to determine if two conditions are true; in that case, you’d use AND. If you only care about whether one of two conditions is true, then you’d use OR.
</p>
<p class="calibre1">For example, consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> andTrue <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> andFalse <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>

<span class="hljs-keyword">let</span> orTrue <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">||</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>
<span class="hljs-keyword">let</span> orFalse <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-operator">==</span> <span class="hljs-number">2</span> <span class="hljs-operator">||</span> <span class="hljs-number">3</span> <span class="hljs-operator">==</span> <span class="hljs-number">4</span></pre>
<p class="calibre1">Each of these tests two separate conditions, combining them with either AND or OR.
</p>
<p class="calibre1">It’s also possible to use Boolean logic to combine more than two comparisons. For example, you can form a complex comparison like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> andOr <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>) <span class="hljs-operator">||</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">4</span></pre>
<p class="calibre1">The parentheses disambiguates the expression. First, Swift evaluates the sub-expression inside the parentheses, and then it evaluates the entire expression, following these steps:
</p><pre class="code-block"><span class="hljs-number">1</span>. (<span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>) <span class="hljs-operator">||</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">4</span>
<span class="hljs-number">2</span>. (<span class="hljs-keyword">true</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">false</span>) <span class="hljs-operator">||</span> <span class="hljs-keyword">true</span>
<span class="hljs-number">3</span>. <span class="hljs-keyword">false</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">true</span>
<span class="hljs-number">4</span>. <span class="hljs-keyword">true</span></pre>
<h3 class="segment-title2">String equality</h3>

<p class="calibre1">Sometimes you want to determine if two strings are equal. For example, a children’s game of naming an animal in a photo would need to determine if the player answered correctly.
</p>
<p class="calibre1">In Swift, you can compare strings using the standard equality operator, <code class="calibre9">==</code>, in exactly the same way you compare numbers. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> guess <span class="hljs-operator">=</span> <span class="hljs-string">"dog"</span>
<span class="hljs-keyword">let</span> dogEqualsCat <span class="hljs-operator">=</span> guess <span class="hljs-operator">==</span> <span class="hljs-string">"cat"</span></pre>
<p class="calibre1">Here, <code class="calibre9">dogEqualsCat</code> is a Boolean that in this case equals <code class="calibre9">false</code>, because <code class="calibre9">"dog"</code> does not equal <code class="calibre9">"cat"</code>. Simple!
</p>
<p class="calibre1">Just as with numbers, you can compare not just for equality but also to determine if one value is greater than or less than another value. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-string">"cat"</span> <span class="hljs-operator">&lt;</span> <span class="hljs-string">"dog"</span></pre>
<p class="calibre1">This syntax checks if one string comes before another alphabetically. In this case, <code class="calibre9">order</code> equals <code class="calibre9">true</code> because <code class="calibre9">"cat"</code> comes before <code class="calibre9">"dog"</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You will learn more about string equality in Chapter 9, “Strings”. Some interesting things crop up when strings contain special characters.
</p></div>

<h3 class="segment-title2">Toggling a Bool</h3>

<p class="calibre1">A <code class="calibre9">Bool</code> often represents the state of something being “on” or “off”. In those cases, it’s common for the state to toggle between states. For example, you could use a <code class="calibre9">Bool</code> to represent the state of a light switch in your application and toggle between the states “on” and “off”.
</p>
<p class="calibre1">For these situations, there is a handy way to flip a <code class="calibre9">Bool</code> from <code class="calibre9">true</code> to <code class="calibre9">false</code> and back again. Like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> switchState <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
switchState.toggle() <span class="hljs-comment">// switchState = false</span>
switchState.toggle() <span class="hljs-comment">// switchState = true</span></pre>
<p class="calibre1">Here, the variable called <code class="calibre9">switchState</code> starts as <code class="calibre9">true</code>. Then, after one <code class="calibre9">toggle</code>, it becomes <code class="calibre9">false</code>. After another <code class="calibre9">toggle</code>, it’s set to <code class="calibre9">true</code> again.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The <code class="calibre9">toggle()</code> here is a call to a <em class="calibre5">function</em>. You’ll see more about these in Chapter 5, “Functions”, and how they apply to types in Chapter 12, “Methods”.
</p></div>

<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant called <code class="calibre9">myAge</code> and set it to your age. Then, create a constant named <code class="calibre9">isTeenager</code> that uses Boolean logic to determine if the age denotes someone in the age range of 13 to 19.
</p></li>

<li class="calibre4">
<p class="calibre1">Create another constant named <code class="calibre9">theirAge</code> and set it to my age, which is 30. Then, create a constant named <code class="calibre9">bothTeenagers</code> that uses Boolean logic to determine if both you and I are teenagers.
</p></li>
</ol>

<ol start="3" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant named <code class="calibre9">reader</code> and set it to your name as a string. Create a constant named <code class="calibre9">author</code> and set it to my name, Matt Galloway. Create a constant named <code class="calibre9">authorIsReader</code> that uses string equality to determine if <code class="calibre9">reader</code> and <code class="calibre9">author</code> are equal.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant named <code class="calibre9">readerBeforeAuthor</code> which uses string comparison to determine if <code class="calibre9">reader</code> comes before <code class="calibre9">author</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">The if statement</h2>

<p class="calibre1">The first and most common way of controlling the flow of a program is through the use of an <code class="calibre9"><em class="calibre13">if</em></code><em class="calibre5"> statement</em>, which allows the program to do something only <i class="calibre2">if</i> a certain condition is true. For example, consider the following:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Yes, 2 is greater than 1."</span>)
}</pre>
<p class="calibre1">This is a simple <code class="calibre9">if</code> statement. If the condition is true, then the statement will execute the code between the braces. If the condition is false, then the statement won’t execute the code between the braces. It’s as simple as that!
</p>
<p class="calibre1">At the heart of the <code class="calibre9">if</code> statement is the <em class="calibre5">condition</em>. The condition is the thing being checked, and then the code in the braces either runs or doesn’t. An <code class="calibre9">if</code> statement is, therefore, a form of <em class="calibre5">conditional statement</em>. You’ll see that term crop up again in this chapter.
</p>
<p class="calibre1">You can extend an <code class="calibre9">if</code> statement to provide code to run if the condition turns out to be false. This is known as the <em class="calibre5">else clause</em>. Here’s an example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> animal <span class="hljs-operator">=</span> <span class="hljs-string">"Fox"</span>

<span class="hljs-keyword">if</span> animal <span class="hljs-operator">==</span> <span class="hljs-string">"Cat"</span> <span class="hljs-operator">||</span> animal <span class="hljs-operator">==</span> <span class="hljs-string">"Dog"</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Animal is a house pet."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Animal is not a house pet."</span>)
}</pre>
<p class="calibre1">Here, if <code class="calibre9">animal</code> equals either <code class="calibre9">"Cat"</code> or <code class="calibre9">"Dog"</code>, the statement will run the first code block. If <code class="calibre9">animal</code> does not equal either <code class="calibre9">"Cat"</code> or <code class="calibre9">"Dog"</code>, then the statement will run the block inside the <code class="calibre9">else</code> part of the <code class="calibre9">if</code> statement, printing the following to the debug area:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Animal is not a house pet.</code>
</p></div>

<p class="calibre1">But you can go even further than that with <code class="calibre9">if</code> statements. Sometimes you want to check one condition, then another. This is where <code class="calibre9"><em class="calibre13">else-if</em></code> comes into play, nesting another <code class="calibre9">if</code> statement in the <code class="calibre9">else</code> clause of a previous <code class="calibre9">if</code> statement.
</p>
<p class="calibre1">You can use it like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> hourOfDay <span class="hljs-operator">=</span> <span class="hljs-number">12</span>
<span class="hljs-keyword">var</span> timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

<span class="hljs-keyword">if</span> hourOfDay <span class="hljs-operator">&lt;</span> <span class="hljs-number">6</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Early morning"</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> hourOfDay <span class="hljs-operator">&lt;</span> <span class="hljs-number">12</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Morning"</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> hourOfDay <span class="hljs-operator">&lt;</span> <span class="hljs-number">17</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Afternoon"</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> hourOfDay <span class="hljs-operator">&lt;</span> <span class="hljs-number">20</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Evening"</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> hourOfDay <span class="hljs-operator">&lt;</span> <span class="hljs-number">24</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Late evening"</span>
} <span class="hljs-keyword">else</span> {
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"INVALID HOUR!"</span>
}
<span class="hljs-built_in">print</span>(timeOfDay)</pre>
<p class="calibre1">These nested <code class="calibre9">if</code> statements test multiple conditions one by one until a true condition is found. Only the code associated with that first true condition is executed, regardless of whether subsequent <code class="calibre9">else-if</code> conditions are true. In other words, the order of your conditions matters!
</p>
<p class="calibre1">You can add an <code class="calibre9">else</code> clause at the end to handle the case where none of the conditions are true. This <code class="calibre9">else</code> clause is optional if you don’t need it; in this example, you <i class="calibre2">do</i> need it to ensure that <code class="calibre9">timeOfDay</code> has a valid value by the time you print it out.
</p>
<p class="calibre1">In this example, the <code class="calibre9">if</code> statement takes a number representing an hour of the day and converts it to a string representing the part of the day to which the hour belongs. Working with a 24-hour clock, the statements are checked in order, one at a time:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The first check is to see if the hour is less than 6. If so, that means it’s early morning.
</p></li>

<li class="calibre4">
<p class="calibre1">If the hour is not less than 6, the statement continues to the first <code class="calibre9">else-if</code>, where it checks the hour to see if it’s less than 12.
</p></li>

<li class="calibre4">
<p class="calibre1">Then, in turn, as conditions prove false, the statement checks the hour to see if it’s less than 17, then less than 20, then less than 24.
</p></li>

<li class="calibre4">
<p class="calibre1">Finally, if the hour is out of range, the statement prints that information to the console.
</p></li>
</ul>

<p class="calibre1">In the code above, the <code class="calibre9">hourOfDay</code> constant is <code class="calibre9">12</code>. Therefore, the code will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Afternoon</code>
</p></div>

<p class="calibre1">Notice that even though both the <code class="calibre9">hourOfDay &lt; 20</code> and <code class="calibre9">hourOfDay &lt; 24</code> conditions are also true, the statement only executes the first block whose condition is true; in this case, the block with the <code class="calibre9">hourOfDay &lt; 17</code> condition.
</p>
<h3 class="segment-title2">Short-circuiting</h3>

<p class="calibre1">An important fact about <code class="calibre9">if</code> statements is what happens when there are multiple Boolean conditions separated by ANDs (<code class="calibre9">&amp;&amp;</code>) or ORs (<code class="calibre9">||</code>).
</p>
<p class="calibre1">Consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">&amp;&amp;</span> name <span class="hljs-operator">==</span> <span class="hljs-string">"Matt Galloway"</span> {
  <span class="hljs-comment">// ...</span>
}</pre>
<p class="calibre1">The first condition of the <code class="calibre9">if</code> statement, <code class="calibre9">1 &gt; 2</code> is <code class="calibre9">false</code>. Therefore the whole expression cannot ever be <code class="calibre9">true</code>.
</p>
<p class="calibre1">So Swift will not even bother to check the second part of the expression, namely the check of <code class="calibre9">name</code>. Similarly, consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">||</span> name <span class="hljs-operator">==</span> <span class="hljs-string">"Matt Galloway"</span> {
  <span class="hljs-comment">// ...</span>
}</pre>
<p class="calibre1">Since <code class="calibre9">1 &lt; 2</code> is <code class="calibre9">true</code>, the whole expression must be <code class="calibre9">true</code> no matter what the value of <code class="calibre9">name</code> is. Therefore, once again, the check of <code class="calibre9">name</code> is not executed. This will come in handy later on when you start dealing with more complex data types.
</p>
<h3 class="segment-title2">Encapsulating variables</h3>

<p class="calibre1"><code class="calibre9">if</code> statements introduce a new concept <em class="calibre5">scope</em>, which is a way to encapsulate variables through the use of braces. Imagine you want to calculate the fee to charge your client. Here’s the deal you’ve made:
</p>
<div class="note">
<p class="calibre10">You earn $25 for every hour up to 40 hours and $50 for every hour after that.
</p></div>

<p class="calibre1">Using Swift, you can calculate your fee in this way:
</p><pre class="code-block"><span class="hljs-keyword">var</span> hoursWorked <span class="hljs-operator">=</span> <span class="hljs-number">45</span>

<span class="hljs-keyword">var</span> price <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">if</span> hoursWorked <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span> {
  <span class="hljs-keyword">let</span> hoursOver40 <span class="hljs-operator">=</span> hoursWorked <span class="hljs-operator">-</span> <span class="hljs-number">40</span>
  price <span class="hljs-operator">+=</span> hoursOver40 <span class="hljs-operator">*</span> <span class="hljs-number">50</span>
  hoursWorked <span class="hljs-operator">-=</span> hoursOver40
}
price <span class="hljs-operator">+=</span> hoursWorked <span class="hljs-operator">*</span> <span class="hljs-number">25</span>

<span class="hljs-built_in">print</span>(price)</pre>
<p class="calibre1">This code takes the number of hours and checks if it’s over 40. If so, the code calculates the number of hours over 40, multiplies that by $50 and then adds the result to the price. The code then subtracts the number of hours over 40 from the hours worked. It multiplies the remaining hours worked by $25 and adds that to the total price.
</p>
<p class="calibre1">In the example above, the result is as follows:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">1250</code>
</p></div>

<p class="calibre1">The interesting thing here is the code inside the <code class="calibre9">if</code> statement. There is a declaration of a new constant, <code class="calibre9">hoursOver40</code>, to store the number of hours over 40. Clearly, you can use it inside the <code class="calibre9">if</code> statement. But what happens if you try to use it at the end of the above code?
</p><pre class="code-block"><span class="hljs-operator">...</span>

<span class="hljs-built_in">print</span>(price)
<span class="hljs-built_in">print</span>(hoursOver40)</pre>
<p class="calibre1">This would result in the following error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Use of unresolved identifier 'hoursOver40'</code>
</p></div>

<p class="calibre1">This error informs you that you’re only allowed to use the <code class="calibre9">hoursOver40</code> constant within the scope it was created. In this case, the <code class="calibre9">if</code> statement introduced a new scope, so when that scope is finished, you can no longer use the constant.
</p>
<p class="calibre1">However, each scope can use variables and constants from its parent scope. In the example above, the scope inside the <code class="calibre9">if</code> statement uses the <code class="calibre9">price</code> and <code class="calibre9">hoursWorked</code> variables, which you created in the parent scope.
</p>
<h3 class="segment-title2">The ternary conditional operator</h3>

<p class="calibre1">Now I want to introduce a new operator, one you didn’t see in Chapter 2, “Types &amp; Operations”. It’s called the <em class="calibre5">ternary conditional operator</em> and it’s related to <code class="calibre9">if</code> statements.
</p>
<p class="calibre1">If you wanted to determine the minimum and maximum of two variables, you could use <code class="calibre9">if</code> statements, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">10</span>

<span class="hljs-keyword">let</span> min: <span class="hljs-built_in">Int</span>
<span class="hljs-keyword">if</span> a <span class="hljs-operator">&lt;</span> b {
  min <span class="hljs-operator">=</span> a
} <span class="hljs-keyword">else</span> {
  min <span class="hljs-operator">=</span> b
}

<span class="hljs-keyword">let</span> max: <span class="hljs-built_in">Int</span>
<span class="hljs-keyword">if</span> a <span class="hljs-operator">&gt;</span> b {
  max <span class="hljs-operator">=</span> a
} <span class="hljs-keyword">else</span> {
  max <span class="hljs-operator">=</span> b
}</pre>
<p class="calibre1">By now, you know how this works, but it’s a lot of code. Wouldn’t it be nice if you could shrink this to just a couple of lines? Well, you can, thanks to the ternary conditional operator!
</p>
<p class="calibre1">The ternary conditional operator takes a condition and returns one of two values, depending on whether the condition was true or false. The syntax is as follows:
</p><pre class="code-block">(<span class="hljs-operator">&lt;</span><span class="hljs-built_in">CONDITION</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">?</span> <span class="hljs-operator">&lt;</span><span class="hljs-built_in">TRUE</span> <span class="hljs-built_in">VALUE</span><span class="hljs-operator">&gt;</span> : <span class="hljs-operator">&lt;</span><span class="hljs-built_in">FALSE</span> <span class="hljs-built_in">VALUE</span><span class="hljs-operator">&gt;</span></pre>
<p class="calibre1">You can use this operator to rewrite your long code block above, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">10</span>

<span class="hljs-keyword">let</span> min <span class="hljs-operator">=</span> a <span class="hljs-operator">&lt;</span> b <span class="hljs-operator">?</span> a : b
<span class="hljs-keyword">let</span> max <span class="hljs-operator">=</span> a <span class="hljs-operator">&gt;</span> b <span class="hljs-operator">?</span> a : b</pre>
<p class="calibre1">In the first example, the condition is <code class="calibre9">a &lt; b</code>. If this is true, the result assigned back to <code class="calibre9">min</code> will be the value of <code class="calibre9">a</code>; if it’s false, the result will be the value of <code class="calibre9">b</code>.
</p>
<p class="calibre1">I’m sure you’ll agree that’s much simpler! This is a useful operator that you’ll find yourself using regularly.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Because finding the greater or smaller of two numbers is such a common operation, the Swift standard library provides two functions for this purpose: <code class="calibre9">max</code> and <code class="calibre9">min</code>. If you were paying attention earlier in the book, then you’ll recall you’ve already seen these.
</p></div>

<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant named <code class="calibre9">myAge</code> and initialize it with your age. Write an <code class="calibre9">if</code> statement to print out <code class="calibre9">Teenager</code> if your age is between 13 and 19 and <code class="calibre9">Not a teenager</code> if your age is not between 13 and 19.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant named <code class="calibre9">answer</code> and use a ternary condition to set it equal to the result you print out for the same cases in the above exercise. Then print out <code class="calibre9">answer</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Loops</h2>

<p class="calibre1">Loops are Swift’s way of executing code multiple times. In this section, you’ll learn about one type of loop: the <code class="calibre9">while</code> loop. If you know another programming language, you’ll find the concepts and maybe even the syntax to be familiar.
</p>
<h3 class="segment-title2">While loops</h3>

<p class="calibre1">A <code class="calibre9"><em class="calibre13">while</em></code><em class="calibre5"> loop</em> repeats a block of code while a condition is true. You create a <code class="calibre9">while</code> loop this way:
</p><pre class="code-block"><span class="hljs-keyword">while</span> <span class="hljs-operator">&lt;</span><span class="hljs-built_in">CONDITION</span><span class="hljs-operator">&gt;</span> {
  <span class="hljs-operator">&lt;</span><span class="hljs-built_in">LOOP</span> <span class="hljs-built_in">CODE</span><span class="hljs-operator">&gt;</span>
}</pre>
<p class="calibre1">The loop checks the condition for every iteration. If the condition is <code class="calibre9">true</code>, then the loop executes and moves on to another iteration. If the condition is <code class="calibre9">false</code>, then the loop stops. Just like <code class="calibre9">if</code> statements, <code class="calibre9">while</code> loops introduce a scope.
</p>
<p class="calibre1">The simplest <code class="calibre9">while</code> loop takes this form:
</p><pre class="code-block"><span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> {  }</pre>
<p class="calibre1">This <code class="calibre9">while</code> loop never ends because the condition is always <code class="calibre9">true</code>. Of course, you would never write such a <code class="calibre9">while</code> loop because your program would spin forever! This situation is known as an <em class="calibre5">infinite loop</em>, and while it might not cause your program to crash, it will likely cause your computer to freeze.
</p>
<p class="calibre1">Here’s a more useful example of a <code class="calibre9">while</code> loop:
</p><pre class="code-block"><span class="hljs-keyword">var</span> sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">while</span> sum <span class="hljs-operator">&lt;</span> <span class="hljs-number">1000</span> {
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> (sum <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)
}</pre>
<p class="calibre1">This code calculates a mathematical sequence to the point where the value is greater than <code class="calibre9">1000</code>.
</p>
<p class="calibre1">The loop executes as follows:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Before iteration 1:</em> <code class="calibre9">sum</code> = 1, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 1:</em> <code class="calibre9">sum</code> = 3, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 2:</em> <code class="calibre9">sum</code> = 7, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 3:</em> <code class="calibre9">sum</code> = 15, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 4:</em> <code class="calibre9">sum</code> = 31, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 5:</em> <code class="calibre9">sum</code> = 63, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 6:</em> <code class="calibre9">sum</code> = 127, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 7:</em> <code class="calibre9">sum</code> = 255, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 8:</em> <code class="calibre9">sum</code> = 511, loop condition = true
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 9:</em> <code class="calibre9">sum</code> = 1023, loop condition = false
</p></li>
</ul>

<p class="calibre1">After the ninth iteration, the <code class="calibre9">sum</code> variable is <code class="calibre9">1023</code>, and therefore the loop condition of <code class="calibre9">sum &lt; 1000</code> becomes false. At this point, the loop stops.
</p>
<h3 class="segment-title2">Repeat-while loops</h3>

<p class="calibre1">A variant of the <code class="calibre9">while</code> loop is called the <em class="calibre5">repeat</em><em class="calibre5">-</em><em class="calibre5">while loop</em>. It differs from the <code class="calibre9">while</code> loop in that the condition is evaluated <i class="calibre2">at the end</i> of the loop rather than at the beginning. You construct a <code class="calibre9">repeat-while</code> loop like this:
</p><pre class="code-block"><span class="hljs-keyword">repeat</span> {
  <span class="hljs-operator">&lt;</span><span class="hljs-built_in">LOOP</span> <span class="hljs-built_in">CODE</span><span class="hljs-operator">&gt;</span>
} <span class="hljs-keyword">while</span> <span class="hljs-operator">&lt;</span><span class="hljs-built_in">CONDITION</span><span class="hljs-operator">&gt;</span></pre>
<p class="calibre1">Here’s the example from the last section, but using a <code class="calibre9">repeat-while</code> loop:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">repeat</span> {
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> (sum <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)
} <span class="hljs-keyword">while</span> sum <span class="hljs-operator">&lt;</span> <span class="hljs-number">1000</span></pre>
<p class="calibre1">In this example, the outcome is the same as before. However, that isn’t always the case &mdash; you might get a different result with a different condition.
</p>
<p class="calibre1">Consider the following <code class="calibre9">while</code> loop:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">while</span> sum <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span> {
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> (sum <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)
}</pre>
<p class="calibre1">Consider the corresponding <code class="calibre9">repeat-while</code> loop, which uses the same condition:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">repeat</span> {
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> (sum <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)
} <span class="hljs-keyword">while</span> sum <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span></pre>
<p class="calibre1">In the case of the regular <code class="calibre9">while</code> loop, the condition <code class="calibre9">sum &lt; 1</code> is <code class="calibre9">false</code> right from the start. That means the body of the loop won’t be reached! The value of <code class="calibre9">sum</code> will equal <code class="calibre9">1</code> because the loop won’t execute any iterations.
</p>
<p class="calibre1">In the case of the <code class="calibre9">repeat-while</code> loop, <code class="calibre9">sum</code> will equal <code class="calibre9">3</code> because the loop executes once.
</p>
<h3 class="segment-title2">Breaking out of a loop</h3>

<p class="calibre1">Sometimes you want to break out of a loop early. You can do this using the <code class="calibre9">break</code> statement, which immediately stops the loop’s execution and continues on to the code after the loop.
</p>
<p class="calibre1">For example, consider the following code:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> {
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> (sum <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)
  <span class="hljs-keyword">if</span> sum <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span> {
    <span class="hljs-keyword">break</span>
  }
}</pre>
<p class="calibre1">Here, the loop condition is <code class="calibre9">true</code>, so the loop would normally iterate forever. However, the <code class="calibre9">break</code> means the <code class="calibre9">while</code> loop will exit once the sum is greater than or equal to <code class="calibre9">1000</code>.
</p>
<p class="calibre1">You’ve seen how to write the same loop in different ways, demonstrating that there are often many ways to achieve the same result in computer programming.
</p>
<p class="calibre1">You should choose the method that’s easiest to read and conveys your intent in the best way possible. This is an approach you’ll internalize with enough time and practice.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a variable named <code class="calibre9">counter</code> and set it equal to <code class="calibre9">0</code>. Create a while loop with the condition <code class="calibre9">counter &lt; 10</code>, which prints out <code class="calibre9">counter is X</code> (where <code class="calibre9">X</code> is replaced with <code class="calibre9">counter</code> value) and then increments <code class="calibre9">counter</code> by <code class="calibre9">1</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a variable named <code class="calibre9">counter</code> and set it equal to <code class="calibre9">0</code>. Create another variable named <code class="calibre9">roll</code> and set it equal to <code class="calibre9">0</code>. Create a <code class="calibre9">repeat-while</code> loop. Inside the loop, set <code class="calibre9">roll</code> equal to <code class="calibre9">Int.random(in: 0...5)</code> which means to pick a random number between <code class="calibre9">0</code> and <code class="calibre9">5</code>. Then increment <code class="calibre9">counter</code> by <code class="calibre9">1</code>. Finally, print <code class="calibre9">After X rolls, roll is Y</code> where <code class="calibre9">X</code> is the value of <code class="calibre9">counter</code> and <code class="calibre9">Y</code> is the value of <code class="calibre9">roll</code>. Set the loop condition such that the loop finishes when the first <code class="calibre9">0</code> is rolled.
</p></li>
</ol>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of basic control flow. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Find the error</h3>

<p class="calibre1">What’s wrong with the following code?
</p><pre class="code-block"><span class="hljs-keyword">let</span> firstName <span class="hljs-operator">=</span> <span class="hljs-string">"Matt"</span>

<span class="hljs-keyword">if</span> firstName <span class="hljs-operator">==</span> <span class="hljs-string">"Matt"</span> {
  <span class="hljs-keyword">let</span> lastName <span class="hljs-operator">=</span> <span class="hljs-string">"Galloway"</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> firstName <span class="hljs-operator">==</span> <span class="hljs-string">"Ray"</span> {
  <span class="hljs-keyword">let</span> lastName <span class="hljs-operator">=</span> <span class="hljs-string">"Wenderlich"</span>
}
<span class="hljs-keyword">let</span> fullName <span class="hljs-operator">=</span> firstName <span class="hljs-operator">+</span> <span class="hljs-string">" "</span> <span class="hljs-operator">+</span> lastName</pre>
<h3 class="segment-title2">Challenge 2: Boolean challenge</h3>

<p class="calibre1">In each of the following statements, what is the value of the Boolean <code class="calibre9">answer</code> constant?
</p><pre class="code-block"><span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">false</span>
<span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> (<span class="hljs-keyword">true</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">1</span> <span class="hljs-operator">!=</span> <span class="hljs-number">2</span>) <span class="hljs-operator">||</span> (<span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-number">100</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> ((<span class="hljs-number">10</span> <span class="hljs-operator">/</span> <span class="hljs-number">2</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>) <span class="hljs-operator">&amp;&amp;</span> ((<span class="hljs-number">10</span> <span class="hljs-operator">%</span> <span class="hljs-number">2</span>) <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)</pre>
<h3 class="segment-title2">Challenge 3: Snakes and ladders</h3>

<p class="calibre1">Imagine you’re playing a game of snakes &amp; ladders that goes from position 1 to position 20. On it, there are ladders at positions 3 and 7, which take you to 15 and 12, respectively. Then there are snakes at positions 11 and 17, which take you to 2 and 9, respectively.
</p>
<p class="calibre1">Create a constant called <code class="calibre9">currentPosition</code>, which you can set to whatever position between 1 and 20 you like. Then create a constant called <code class="calibre9">diceRoll</code>, which you can set to whatever roll of the dice you want. Finally, calculate the final position considering the ladders and snakes, calling it <code class="calibre9">nextPosition</code>.
</p>
<h3 class="segment-title2">Challenge 4: Number of days in a month</h3>

<p class="calibre1">Given a month (represented with a <code class="calibre9">String</code> in all lowercase) and the current year (represented with an <code class="calibre9">Int</code>), calculate the number of days in the month. Remember that because of leap years, “february” has 29 days when the year is a multiple of 4 but not a multiple of 100.  February also has 29 days when the year is a multiple of 400.
</p>
<h3 class="segment-title2">Challenge 5: Next power of two</h3>

<p class="calibre1">Given a number, determine the next power of two above or equal to that number.
</p>
<h3 class="segment-title2">Challenge 6: Triangular number</h3>

<p class="calibre1">Given a number, print the triangular number of that depth. You can get a refresher of triangular numbers here: https://en.wikipedia.org/wiki/Triangular_number
</p>
<h3 class="segment-title2">Challenge 7: Fibonacci</h3>

<p class="calibre1">Calculate the nth Fibonacci number. Remember that Fibonacci numbers start their sequence with 1 and 1, and then subsequent numbers in the sequence are equal to the previous two values added together. You can get a refresher here: https://en.wikipedia.org/wiki/Fibonacci_number
</p>
<h3 class="segment-title2">Challenge 8: Make a loop</h3>

<p class="calibre1">Use a loop to print out the times table up to 12 of a given factor.
</p>
<h3 class="segment-title2">Challenge 9: Dice roll table</h3>

<p class="calibre1">Print a table showing the number of combinations to create each number from 2 to 12, given two six-sided dice rolls. You should not use a formula but rather compute the number of combinations exhaustively by considering each possible dice roll.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You use the Boolean data type <code class="calibre9">Bool</code> to represent true and false.
</p></li>

<li class="calibre4">
<p class="calibre1">The comparison operators, all of which return a Boolean, are:
</p></li>
</ul>
<div class="image3"><img src="images/000029.png" alt="" title="" class="calibre7" /></div>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You can use Boolean logic (<code class="calibre9">&amp;&amp;</code> and <code class="calibre9">||</code>) to combine comparison conditions.
</p></li>

<li class="calibre4">
<p class="calibre1">You use <code class="calibre9">if</code> statements to make simple decisions based on a condition.
</p></li>

<li class="calibre4">
<p class="calibre1">You use <code class="calibre9">else</code> and <code class="calibre9">else-if</code> within an <code class="calibre9">if</code> statement to extend the decision-making beyond a single condition.
</p></li>

<li class="calibre4">
<p class="calibre1">Short-circuiting ensures that only the minimal required parts of a Boolean expression are evaluated.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use the ternary operator <code class="calibre9">(a ? b : c)</code> instead of a simple <code class="calibre9">if</code> statement.
</p></li>

<li class="calibre4">
<p class="calibre1">Variables and constants belong to a certain scope, beyond which you cannot use them. A scope inherits visible variables and constants from its parent.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">while</code> loops allow you to perform a particular task zero or more times until a condition is met.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">repeat</code> loops always execute the loop at least once.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">break</code> statement lets you break out of a loop.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-12">


<h1 class="segment-chapter">Chapter 4: Advanced Control Flow</h1>

<p class="calibre1">In Chapter 3, “Basic Control Flow”, you learned how to control the flow of execution using the decision-making powers of <code class="calibre9">if</code> statements and the <code class="calibre9">while</code> loop. In this chapter, you’ll continue to learn how to control the flow of execution. You’ll learn about another loop known as the <code class="calibre9">for</code> loop.
</p>
<p class="calibre1">Loops may not sound very interesting, but they’re very common in computer programs. For example, you might have code to download an image from the cloud; with a loop, you could run that multiple times to download your entire photo library. Or, if you have a game with multiple computer-controlled characters, you might need a loop to go through each one and make sure it knows what to do next.
</p>
<p class="calibre1">You’ll also learn about <code class="calibre9">switch</code> statements, which are particularly powerful in Swift. They let you inspect a value and decide what to do based on that value, and they’re incredibly powerful when used with some advanced Swift features such as pattern matching.
</p>
<h2 class="segment-chapter1">Countable ranges</h2>

<p class="calibre1">Before you dive into the <code class="calibre9">for</code> loop statement, you need to know about the <em class="calibre5">Countable Range</em> data types, which let you represent a sequence of countable integers. Let’s look at two types of ranges.
</p>
<p class="calibre1">First, there’s <em class="calibre5">countable closed range</em>, which you represent like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> closedRange <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">5</span></pre>
<p class="calibre1">The three dots (<code class="calibre9">...</code>) indicate that this range is closed, which means the range goes from 0 to 5 inclusive. That’s the numbers <code class="calibre9">(0, 1, 2, 3, 4, 5)</code>.
</p>
<p class="calibre1">Second, there’s <em class="calibre5">countable half</em><em class="calibre5">-</em><em class="calibre5">open range</em>, which you represent like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> halfOpenRange <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">5</span></pre>
<p class="calibre1">Here, you replace the three dots with two dots and a less-than sign (<code class="calibre9">..&lt;</code>). Half-open means the range goes from 0 up to, but not including, 5. That’s the numbers <code class="calibre9">(0, 1, 2, 3, 4)</code>.
</p>
<p class="calibre1">Both open and half-open ranges must always be increasing. In other words, the second number must always be greater than or equal to the first. Countable ranges are commonly used in both <code class="calibre9">for</code> loops and <code class="calibre9">switch</code> statements, which means that throughout the rest of the chapter, you’ll use ranges as well!
</p>
<h3 class="segment-title2">A random interlude</h3>

<p class="calibre1">A common need in programming is to be able to generate random numbers. And Swift provides the functionality built into the language, which is pretty handy!
</p>
<p class="calibre1">As an example, imagine an application that needs to simulate rolling a die. You may want to do something until the code rolls a six. Now that you know about <code class="calibre9">while</code> loops, you can do that with the <code class="calibre9">random</code> feature. You could do that like so:
</p><pre class="code-block"><span class="hljs-keyword">while</span> <span class="hljs-built_in">Int</span>.random(in: <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">6</span>) <span class="hljs-operator">!=</span> <span class="hljs-number">6</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Not a six"</span>)
}</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The <code class="calibre9">random(in:)</code> here is a call to a <em class="calibre5">function</em>. You’ll see more about these in Chapter 5, “Functions”, and how they apply to types in Chapter 12, “Methods”.
</p></div>

<h2 class="segment-chapter1">For loops</h2>

<p class="calibre1">In Chapter 3, “Basic Control Flow”, you looked at <code class="calibre9">while</code> loops. Now that you know about ranges, it’s time to look at another type of loop: the <code class="calibre9"><em class="calibre13">for</em></code><em class="calibre5"> loop</em>. This is probably the most common loop you’ll see, and you’ll use it to run code a certain number of times.
</p>
<p class="calibre1">You construct a <code class="calibre9">for</code> loop like this:
</p><pre class="code-block"><span class="hljs-keyword">for</span> <span class="hljs-operator">&lt;</span><span class="hljs-built_in">CONSTANT</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">in</span> <span class="hljs-operator">&lt;</span><span class="hljs-built_in">COUNTABLE</span> <span class="hljs-built_in">RANGE</span><span class="hljs-operator">&gt;</span> {
  <span class="hljs-operator">&lt;</span><span class="hljs-built_in">LOOP</span> <span class="hljs-built_in">CODE</span><span class="hljs-operator">&gt;</span>
}</pre>
<p class="calibre1">The loop begins with the <code class="calibre9">for</code> keyword, followed by a name given to the loop constant (more on that shortly), followed by <code class="calibre9">in</code>, followed by the range to loop through. Here’s an example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> count <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">var</span> sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>count {
  sum <span class="hljs-operator">+=</span> i
}</pre>
<p class="calibre1">In the code above, the <code class="calibre9">for</code> loop iterates through the range 1 to <code class="calibre9">count</code>. At the first iteration, <code class="calibre9">i</code> will equal the first element in the range: 1. Each time around the loop, <code class="calibre9">i</code> will increment until it’s equal to <code class="calibre9">count</code>; the loop will execute one final time and then finish.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you’d used a half-open range, the last iteration would see <code class="calibre9">i</code> equal to <code class="calibre9">count - 1</code>.
</p></div>

<p class="calibre1">Inside the loop, you add <code class="calibre9">i</code> to the <code class="calibre9">sum</code> variable; it runs 10 times to calculate the sequence <code class="calibre9">1 + 2 + 3 + 4 + 5 + ...</code> all the way up to 10.
</p>
<p class="calibre1">Here are the values of the constant <code class="calibre9">i</code> and variable <code class="calibre9">sum</code> for each iteration:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 1:</em> <code class="calibre9">i</code> = 1, <code class="calibre9">sum</code> = 0
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 2:</em> <code class="calibre9">i</code> = 2, <code class="calibre9">sum</code> = 1
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 3:</em> <code class="calibre9">i</code> = 3, <code class="calibre9">sum</code> = 3
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 4:</em> <code class="calibre9">i</code> = 4, <code class="calibre9">sum</code> = 6
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 5:</em> <code class="calibre9">i</code> = 5, <code class="calibre9">sum</code> = 10
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 6:</em> <code class="calibre9">i</code> = 6, <code class="calibre9">sum</code> = 15
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 7:</em> <code class="calibre9">i</code> = 7, <code class="calibre9">sum</code> = 21
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 8:</em> <code class="calibre9">i</code> = 8, <code class="calibre9">sum</code> = 28
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 9:</em> <code class="calibre9">i</code> = 9, <code class="calibre9">sum</code> = 36
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Start of iteration 10:</em> <code class="calibre9">i</code> = 10, <code class="calibre9">sum</code> = 45
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">After iteration 10:</em> <code class="calibre9">sum</code> = 55
</p></li>
</ul>

<p class="calibre1">In terms of scope, the <code class="calibre9">i</code> constant is only visible inside the scope of the <code class="calibre9">for</code> loop, which means it’s not available outside of the loop.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you’re mathematically astute, you might notice that this example computes <em class="calibre5">triangle numbers</em>. Here’s a quick explanation: <a href="http://bbc.in/1O89TGP" class="calibre6">http://bbc.in/1O89TGP</a>
</p></div>

<p class="calibre1">Xcode’s playground gives you a handy way to visualize such an iteration. Look at the <code class="calibre9">sum += i</code> line in the results pane. You will notice a box on the right. Click on it:
</p><div class="image3"><img src="images/000054.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Xcode will display a graph underneath the line within the playground code editor:
</p><div class="image3"><img src="images/000067.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">This graph lets you visualize the <code class="calibre9">sum</code> variable as the loop iterates.
</p>
<p class="calibre1">Finally, sometimes you only want to loop a certain number of times, so you don’t need to use the loop constant at all.
</p>
<p class="calibre1">In that case, you can employ the underscore to indicate you’re ignoring it, like so:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> lastSum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>count {
  <span class="hljs-keyword">let</span> temp <span class="hljs-operator">=</span> sum
  sum <span class="hljs-operator">=</span> sum <span class="hljs-operator">+</span> lastSum
  lastSum <span class="hljs-operator">=</span> temp
}</pre>
<p class="calibre1">This code doesn’t require a loop constant; the loop simply needs to run a certain number of times. In this case, the range is 0 up to, but not including, <code class="calibre9">count</code> and is half-open. This is the usual way of writing loops that run a certain number of times. It’s also possible to only perform the iteration under certain conditions. For example, imagine you wanted to compute a sum similar to that of triangle numbers, but only for odd numbers:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>count <span class="hljs-keyword">where</span> i <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">1</span> {
  sum <span class="hljs-operator">+=</span> i
}</pre>
<p class="calibre1">The previous loop has a <code class="calibre9">where</code> clause in the <code class="calibre9">for</code> loop statement. The loop still runs through all values in the range 1 to <code class="calibre9">count</code>, but it will only execute the loop’s code block when the <code class="calibre9">where</code> condition is true; in this case, where <code class="calibre9">i</code> is odd.
</p>
<h3 class="segment-title2">Continue and labeled statements</h3>

<p class="calibre1">Sometimes you’d like to skip a loop iteration for a particular case without breaking out of the loop entirely. You can do this with the <code class="calibre9">continue</code> statement, which immediately ends the current iteration of the loop and starts the next iteration.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In many cases, you can use the simpler <code class="calibre9">where</code> clause you just learned about. The <code class="calibre9">continue</code> statement gives you a higher level of control, letting you decide where and when you want to skip an iteration.
</p></div>

<p class="calibre1">Take the example of an eight-by-eight grid, where each cell holds a row value multiplied by the column. It looks much like a multiplication table, doesn’t it?
</p><div class="image2"><img src="images/000077.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Let’s say you wanted to calculate the sum of all cells but exclude all even rows, as shown below:
</p><div class="image2"><img src="images/000089.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Using a <code class="calibre9">for</code> loop, you can achieve this as follows:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
  <span class="hljs-keyword">if</span> row <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> {
    <span class="hljs-keyword">continue</span>
  }

  <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
    sum <span class="hljs-operator">+=</span> row <span class="hljs-operator">*</span> column
  }
}</pre>
<p class="calibre1">When the row modulo 2 equals 0, the row is even. In this case, <code class="calibre9">continue</code> makes the <code class="calibre9">for</code> loop skip to the next row. Just like <code class="calibre9">break</code>, <code class="calibre9">continue</code> works with both <code class="calibre9">for</code> loops and <code class="calibre9">while</code> loops.
</p>
<p class="calibre1">The second code example will calculate the sum of all cells, excluding those where the column is greater than or equal to the row.
</p>
<p class="calibre1">To illustrate, it should sum the following cells:
</p><div class="image2"><img src="images/000099.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Using a <code class="calibre9">for</code> loop, you can achieve this as follows:
</p><pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

rowLoop: <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
  columnLoop: <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
    <span class="hljs-keyword">if</span> row <span class="hljs-operator">==</span> column {
      <span class="hljs-keyword">continue</span> rowLoop
    }
    sum <span class="hljs-operator">+=</span> row <span class="hljs-operator">*</span> column
  }
}</pre>
<p class="calibre1">The previous code block uses <em class="calibre5">labeled statements</em>, labeling the two loops as <code class="calibre9">rowLoop</code> and the <code class="calibre9">columnLoop</code>, respectively. When the row equals the column inside the inner <code class="calibre9">columnLoop</code>, the outer <code class="calibre9">rowLoop</code> will continue.
</p>
<p class="calibre1">You can use labeled statements like these with <code class="calibre9">break</code> to break out of a certain loop. Normally, <code class="calibre9">break</code> and <code class="calibre9">continue</code> work on the innermost loop, so you need to use labeled statements to act on the outer loop.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant named <code class="calibre9">range</code> and set it equal to a range starting at 1 and ending with 10 inclusive. Write a <code class="calibre9">for</code> loop that iterates over this range and prints the square of each number.
</p></li>

<li class="calibre4">
<p class="calibre1">Write a <code class="calibre9">for</code> loop to iterate over the same range as in the exercise above and print the square root of each number. You’ll need to type convert your loop constant.
</p></li>
</ol>

<ol start="3" class="calibre11">
<li class="calibre4">
<p class="calibre1">Above, you saw a <code class="calibre9">for</code> loop that iterated over only the even rows like so:
</p></li>
</ol>
<pre class="code-block">sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
  <span class="hljs-keyword">if</span> row <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span> {
    <span class="hljs-keyword">continue</span>
  }
  <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">8</span> {
    sum <span class="hljs-operator">+=</span> row <span class="hljs-operator">*</span> column
  }
}</pre>
<p class="calibre1">Change this to use a <code class="calibre9">where</code> clause on the first <code class="calibre9">for</code> loop to skip even rows instead of using <code class="calibre9">continue</code>. Check that the sum is 448, as in the initial example.
</p>
<h2 class="segment-chapter1">Switch statements</h2>

<p class="calibre1">You can also control flow via the <code class="calibre9">switch</code> statement. It executes different code depending on the value of a variable or constant. Here’s a <code class="calibre9">switch</code> statement that acts on an integer:
</p><pre class="code-block"><span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> <span class="hljs-number">10</span>

<span class="hljs-keyword">switch</span> number {
<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Zero"</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Non-zero"</span>)
}</pre>
<p class="calibre1">In this example, the code will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Non-zero</code>
</p></div>

<p class="calibre1">The purpose of this <code class="calibre9">switch</code> statement is to determine whether or not a number is zero. It will get more complex &mdash; I promise!
</p>
<p class="calibre1">To handle a specific case, you use <code class="calibre9">case</code> followed by the value you want to check for, which in this case is <code class="calibre9">0</code>. Then, you use <code class="calibre9">default</code> to signify what should happen for all other values.
</p>
<p class="calibre1">Here’s another example:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> number {
<span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"It’s ten!"</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-keyword">break</span>
}</pre>
<p class="calibre1">This time you check for 10, in which case, you print a message. Nothing should happen for other values. When you want nothing to happen for a case, you use the <code class="calibre9">break</code> statement. This tells Swift that you <i class="calibre2">meant</i> to not write any code here and that nothing should happen. Cases can never be empty, so you <i class="calibre2">must</i> write some code, even if it’s just a <code class="calibre9">break</code>!
</p>
<p class="calibre1">Of course, <code class="calibre9">switch</code> statements also work with data types other than integers. They work with any data type!
</p>
<p class="calibre1">Here’s an example of switching on a string:
</p><pre class="code-block"><span class="hljs-keyword">let</span> string <span class="hljs-operator">=</span> <span class="hljs-string">"Dog"</span>

<span class="hljs-keyword">switch</span> string {
<span class="hljs-keyword">case</span> <span class="hljs-string">"Cat"</span>, <span class="hljs-string">"Dog"</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Animal is a house pet."</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Animal is not a house pet."</span>)
}</pre>
<p class="calibre1">This will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Animal is a house pet.</code>
</p></div>

<p class="calibre1">In this example, you provide two values for the case, meaning that if the value is equal to either <code class="calibre9">"Cat"</code> or <code class="calibre9">"Dog"</code>, then the statement will execute the case.
</p>
<h3 class="segment-title2">Advanced switch statements</h3>

<p class="calibre1">You can also give your <code class="calibre9">switch</code> statements more than one case. In Chapter 3, “Basic Control Flow”, you saw an <code class="calibre9">if</code> statement that used multiple <code class="calibre9">else</code> clauses to convert an hour of the day to a string describing that part of the day.
</p>
<p class="calibre1">You could rewrite that more succinctly with a <code class="calibre9">switch</code> statement, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> hourOfDay <span class="hljs-operator">=</span> <span class="hljs-number">12</span>
<span class="hljs-keyword">var</span> timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

<span class="hljs-keyword">switch</span> hourOfDay {
<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Early morning"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Morning"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Afternoon"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Evening"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Late evening"</span>
<span class="hljs-keyword">default</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"INVALID HOUR!"</span>
}

<span class="hljs-built_in">print</span>(timeOfDay)</pre>
<p class="calibre1">This code will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Afternoon</code>
</p></div>

<p class="calibre1">Remember ranges?
</p>
<p class="calibre1">Well, you can use ranges to simplify this <code class="calibre9">switch</code> statement. You can rewrite the above code using ranges:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> hourOfDay {
<span class="hljs-keyword">case</span> <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">5</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Early morning"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">6</span><span class="hljs-operator">...</span><span class="hljs-number">11</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Morning"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">12</span><span class="hljs-operator">...</span><span class="hljs-number">16</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Afternoon"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">17</span><span class="hljs-operator">...</span><span class="hljs-number">19</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Evening"</span>
<span class="hljs-keyword">case</span> <span class="hljs-number">20</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">24</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"Late evening"</span>
<span class="hljs-keyword">default</span>:
  timeOfDay <span class="hljs-operator">=</span> <span class="hljs-string">"INVALID HOUR!"</span>
}</pre>
<p class="calibre1">This code is more concise than writing out each value individually for all cases.
</p>
<p class="calibre1">When there are multiple cases, the statement will execute the first one that matches. You’ll probably agree that this is more concise and clear than using an <code class="calibre9">if</code> statement for this example.
</p>
<p class="calibre1">It’s slightly more precise as well because the <code class="calibre9">if</code> statement method didn’t address negative numbers, which here are correctly deemed to be invalid.
</p>
<p class="calibre1">It’s also possible to match a case to a condition based on a property of the value. As you learned in Chapter 2, “Types &amp; Operations” you can use the modulo operator to determine if an integer is even or odd.
</p>
<p class="calibre1">Consider this code:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> number {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> x <span class="hljs-keyword">where</span> x <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Even"</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Odd"</span>)
}</pre>
<p class="calibre1">This will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Even</code>
</p></div>

<p class="calibre1">This <code class="calibre9">switch</code> statement uses the <code class="calibre9">let-where</code> syntax, meaning the case will match only when a certain condition is true. The <code class="calibre9">let</code> part binds a value to a name, while the <code class="calibre9">where</code> part provides a Boolean condition that must be true for the case to match.
</p>
<p class="calibre1">In this example, you’ve designed the case to match if the value is even &mdash; that is if the value modulo 2 equals 0.
</p>
<p class="calibre1">The method by which you can match values based on conditions is known as <em class="calibre5">pattern matching</em>.
</p>
<p class="calibre1">In the previous example, the binding introduced an unnecessary constant <code class="calibre9">x</code>; it’s merely another name for <code class="calibre9">number</code>.
</p>
<p class="calibre1">You can use <code class="calibre9">number</code> in the <code class="calibre9">where</code> clause and replace the binding with an underscore to ignore it.
</p><pre class="code-block"><span class="hljs-keyword">switch</span> number {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">where</span> number <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Even"</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Odd"</span>)
}</pre>
<h3 class="segment-title2">Partial matching</h3>

<p class="calibre1">Another way you can use <code class="calibre9">switch</code> statements with matching to great effect is as follows:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (x: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, z: <span class="hljs-number">5</span>)

<span class="hljs-keyword">switch</span> coordinates {
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>): <span class="hljs-comment">// 1</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Origin"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>): <span class="hljs-comment">// 2</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x-axis."</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>): <span class="hljs-comment">// 3</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the y-axis."</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">_</span>): <span class="hljs-comment">// 4</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the z-axis."</span>)
<span class="hljs-keyword">default</span>:        <span class="hljs-comment">// 5</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Somewhere in space"</span>)
}</pre>
<p class="calibre1">This <code class="calibre9">switch</code> statement makes use of <em class="calibre5">partial matching</em>. Here’s what each case does, in order:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Matches precisely where the value is <code class="calibre9">(0, 0, 0)</code>. This is the origin of 3D space.
</p></li>

<li class="calibre4">
<p class="calibre1">Matches y=0, z=0 and any value of x. This means the coordinate is on the x-axis.
</p></li>

<li class="calibre4">
<p class="calibre1">Matches x=0, z=0 and any value of y. This means the coordinate is on the y-axis.
</p></li>
</ol>

<ol start="4" class="calibre11">
<li class="calibre4">
<p class="calibre1">Matches x=0, y=0 and any value of z. This means the coordinate is on the z-axis.
</p></li>

<li class="calibre4">
<p class="calibre1">Matches the remainder of coordinates.
</p></li>
</ol>

<p class="calibre1">You’re using the underscore to mean that you don’t care about the value. If you don’t want to ignore the value, you can bind it and use it in your <code class="calibre9">switch</code> statement.
</p>
<p class="calibre1">Here’s an example of how to do this:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> coordinates {
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Origin"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-keyword">let</span> x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x-axis at x = <span class="hljs-subst">\(x)</span>"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">let</span> y, <span class="hljs-number">0</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the y-axis at y = <span class="hljs-subst">\(y)</span>"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">let</span> z):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the z-axis at z = <span class="hljs-subst">\(z)</span>"</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (x, y, z):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Somewhere in space at x = <span class="hljs-subst">\(x)</span>, y = <span class="hljs-subst">\(y)</span>, z = <span class="hljs-subst">\(z)</span>"</span>)
}</pre>
<p class="calibre1">Here, the axis cases use the <code class="calibre9">let</code> syntax to pull out the pertinent values. The code then prints the values using string interpolation to build the string.
</p>
<p class="calibre1">Notice how you don’t need a default in this <code class="calibre9">switch</code> statement. This is because the final case is essentially the default; it matches anything because there are no constraints on any part of the tuple. If the <code class="calibre9">switch</code> statement exhausts all possible values with its cases, no default is necessary.
</p>
<p class="calibre1">Also, notice how you could use a single <code class="calibre9">let</code> to bind all values of the tuple: <code class="calibre9">let (x, y, z)</code> is the same as <code class="calibre9">(let x, let y, let z)</code>.
</p>
<p class="calibre1">Finally, you can use the same <code class="calibre9">let-where</code> syntax you saw earlier to match more complex cases. For example:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> coordinates {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (x, y, <span class="hljs-keyword">_</span>) <span class="hljs-keyword">where</span> y <span class="hljs-operator">==</span> x:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Along the y = x line."</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (x, y, <span class="hljs-keyword">_</span>) <span class="hljs-keyword">where</span> y <span class="hljs-operator">==</span> x <span class="hljs-operator">*</span> x:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Along the y = x^2 line."</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-keyword">break</span>
}</pre>
<p class="calibre1">Here, you match the “y equals x” and “y equals x squared” lines.
</p>
<p class="calibre1">And those are the basics of <code class="calibre9">switch</code> statements!
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Write a switch statement that takes an age as an integer and prints out the life stage related to that age. You can make up the life stages or use my categorization: 0-2 years, Infant; 3-12 years, Child; 13-19 years, Teenager; 20-39, Adult; 40-60, Middle-aged; 61+, Elderly.
</p></li>

<li class="calibre4">
<p class="calibre1">Write a <code class="calibre9">switch</code> statement that takes a tuple containing a string and an integer. The string is a name, and the integer is an age. Use the same cases you used in the previous exercise and <code class="calibre9">let</code> syntax to print out the name followed by the life stage. For example, for myself, it would print out <code class="calibre9">"Matt is an adult."</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of advanced control flow. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: How many times</h3>

<p class="calibre1">In the following <code class="calibre9">for</code> loop, what will be the value of <code class="calibre9">sum</code>, and how many iterations will happen?
</p><pre class="code-block"><span class="hljs-keyword">var</span> sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">5</span> {
  sum <span class="hljs-operator">+=</span> i
}</pre>
<h3 class="segment-title2">Challenge 2: Count the letter</h3>

<p class="calibre1">In the <code class="calibre9">while</code> loop below, how many instances of “a” will there be in <code class="calibre9">aLotOfAs</code>? Hint: <code class="calibre9">aLotOfAs.count</code> tells you how many characters are in the string <code class="calibre9">aLotOfAs</code>.
</p><pre class="code-block"><span class="hljs-keyword">var</span> aLotOfAs <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
<span class="hljs-keyword">while</span> aLotOfAs.count <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> {
  aLotOfAs <span class="hljs-operator">+=</span> <span class="hljs-string">"a"</span>
}</pre>
<h3 class="segment-title2">Challenge 3: What will print</h3>

<p class="calibre1">Consider the following <code class="calibre9">switch</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> coordinates {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (x, y, z) <span class="hljs-keyword">where</span> x <span class="hljs-operator">==</span> y <span class="hljs-operator">&amp;&amp;</span> y <span class="hljs-operator">==</span> z:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"x = y = z"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x/y plane"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">_</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x/z plane"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">_</span>, <span class="hljs-keyword">_</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the y/z plane"</span>)
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Nothing special"</span>)
}</pre>
<p class="calibre1">What will this code print when <code class="calibre9">coordinates</code> is each of the following?
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)
<span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)
<span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</pre>
<h3 class="segment-title2">Challenge 4: Closed range size</h3>

<p class="calibre1">A closed range can never be empty. Why?
</p>
<h3 class="segment-title2">Challenge 5: The final countdown</h3>

<p class="calibre1">Print a countdown from 10 to 0.  (Note: do not use the <code class="calibre9">reversed()</code> method, which will be introduced later.)
</p>
<h3 class="segment-title2">Challenge 6: Print a sequence</h3>

<p class="calibre1">Print 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0.  (Note: do not use the <code class="calibre9">stride(from:by:to:)</code> function, which will be introduced later.)
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You can use <em class="calibre5">countable ranges</em> to create a sequence of integers, incrementing to move from one value to another.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Closed ranges</em> include both the start and end values.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Half</em><em class="calibre5">-</em><em class="calibre5">open ranges</em> include the start value and stop one before the end value.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">For loops</em> allow you to iterate over a range.
</p></li>

<li class="calibre4">
<p class="calibre1">The <em class="calibre5">continue</em> statement lets you finish the current loop iteration and begin the next iteration.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Labeled statements</em> let you use <code class="calibre9">break</code> and <code class="calibre9">continue</code> on an outer loop.
</p></li>

<li class="calibre4">
<p class="calibre1">You use <em class="calibre5">switch</em> statements to decide which code to run depending on the value of a variable or constant.
</p></li>

<li class="calibre4">
<p class="calibre1">The power of a <code class="calibre9">switch</code> statement comes from leveraging <em class="calibre5">pattern matching</em> to compare values using complex rules.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-37">


<h1 class="segment-chapter">Chapter 5: Functions</h1>

<p class="calibre1">Functions are a core part of many programming languages. Simply put, a function lets you define a block of code that performs a task. Then, whenever your app needs to execute that task, you can run the function instead of copying and pasting the same code everywhere.
</p>
<p class="calibre1">In this chapter, you’ll learn how to write your own functions and see firsthand how Swift makes them easy to use.
</p>
<h2 class="segment-chapter1">Function basics</h2>

<p class="calibre1">Imagine you have an app that frequently needs to print your name. You can write a function to do this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMyName</span>() {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"My name is Matt Galloway."</span>)
}</pre>
<p class="calibre1">The code above is known as a <em class="calibre5">function declaration</em>. You define a function using the <code class="calibre9">func</code> keyword. After that comes the name of the function, followed by parentheses. You’ll learn more about the need for these parentheses in the next section.
</p>
<p class="calibre1">After the parentheses comes an opening brace, followed by the code you want to run in the function, followed by a closing brace. With your function defined, you can use it like so:
</p><pre class="code-block">printMyName()</pre>
<p class="calibre1">This prints out the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">My name is Matt Galloway</code>.
</p></div>

<p class="calibre1">If you suspect that you’ve already used a function in previous chapters, you’re correct! <code class="calibre9">print</code>, which prints the text you give it to the console, is indeed a function. This leads nicely into the next section, in which you’ll learn how to pass data to a function and get data back in return.
</p>
<h3 class="segment-title2">Function parameters</h3>

<p class="calibre1">In the previous example, the function simply prints out a message. That’s great, but sometimes you want to <em class="calibre5">parameterize</em> your function, which lets it perform differently depending on the data passed into it via its <em class="calibre5">parameters</em>.
</p>
<p class="calibre1">As an example, consider the following function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOfFive</span>(<span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(value)</span> * 5 = <span class="hljs-subst">\(value <span class="hljs-operator">*</span> <span class="hljs-number">5</span>)</span>"</span>)
}
printMultipleOfFive(value: <span class="hljs-number">10</span>)</pre>
<p class="calibre1">Here, you can see the definition of one parameter inside the parentheses after the function name, named <code class="calibre9">value</code> and of type <code class="calibre9">Int</code>. In any function, the parentheses contain what’s known as the <em class="calibre5">parameter list</em>. These parentheses are required both when declaring and invoking the function, even if the parameter list is empty. This function will print out any given multiple of five. In the example, you call the function with an <em class="calibre5">argument</em> of 10, so the function prints the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">10 * 5 = 50</code>
</p></div>

<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Take care not to confuse the terms “parameter” and “argument”. A function declares its <em class="calibre5">parameters</em> in its parameter list. When you call a function, you provide values as <em class="calibre5">arguments</em> for the functions’ parameters.
</p></div>

<p class="calibre1">You can take this one step further and make the function more general. With two parameters, the function can print out a multiple of any two values.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">andValue</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(multiplier)</span> * <span class="hljs-subst">\(andValue)</span> = <span class="hljs-subst">\(multiplier <span class="hljs-operator">*</span> andValue)</span>"</span>)
}
printMultipleOf(multiplier: <span class="hljs-number">4</span>, andValue: <span class="hljs-number">2</span>)</pre>
<p class="calibre1">There are now two parameters inside the parentheses after the function name: one named <code class="calibre9">multiplier</code> and the other named <code class="calibre9">andValue</code>, both of type <code class="calibre9">Int</code>.
</p>
<p class="calibre1">Notice that you need to apply the labels in the parameter list to the arguments when you call a function. In the example above, you need to put <code class="calibre9">multiplier:</code> before the multiplier and <code class="calibre9">andValue:</code> before the value to be multiplied.
</p>
<p class="calibre1">In Swift, you should try to make your function calls read like a sentence. In the example above, you would read the last line of code like this:
</p>
<div class="note">
<p class="calibre10"><i class="calibre2">Print multiple of multiplier 4 and value 2</i>
</p></div>

<p class="calibre1">You can make this even clearer by giving a parameter a different <em class="calibre5">external name</em>. For example, you can change the name of the <code class="calibre9">andValue</code> parameter:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(multiplier)</span> * <span class="hljs-subst">\(value)</span> = <span class="hljs-subst">\(multiplier <span class="hljs-operator">*</span> value)</span>"</span>)
}
printMultipleOf(multiplier: <span class="hljs-number">4</span>, and: <span class="hljs-number">2</span>)</pre>
<p class="calibre1">You assign a different external name by writing it in front of the parameter name. In this example, the internal name of the parameter is now <code class="calibre9">value</code> while the external name (the argument label) in the function call is now <code class="calibre9">and</code>. You can read the new call as:
</p>
<div class="note">
<p class="calibre10"><i class="calibre2">Print multiple of multiplier 4 and 2</i>
</p></div>

<p class="calibre1">The following diagram explains where the external and internal names come from in the function declaration:
</p><div class="image3"><img src="images/000120.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The idea behind this is to allow you to have a function call be readable in a sentence-like manner but still have an expressive name within the function itself. You could have written the above function like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">and</span>: <span class="hljs-built_in">Int</span>)</pre>
<p class="calibre1">This would have the same effect at the function call of being a nice readable sentence. However, now the parameter inside the function is also called <code class="calibre9">and</code>. In a long function, it could get confusing to have such a generically named parameter.
</p>
<p class="calibre1">If you want to have no external name at all, then you can employ the underscore <code class="calibre9">_</code>, as you’ve seen in previous chapters:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(multiplier)</span> * <span class="hljs-subst">\(value)</span> = <span class="hljs-subst">\(multiplier <span class="hljs-operator">*</span> value)</span>"</span>)
}
printMultipleOf(<span class="hljs-number">4</span>, and: <span class="hljs-number">2</span>)</pre>
<p class="calibre1">This change makes it even more readable at the call site. The function call now reads like so:
</p>
<div class="note">
<p class="calibre10"><i class="calibre2">Print multiple of 4 and 2</i>
</p></div>

<p class="calibre1">You could, if you so wished, take this even further and use <code class="calibre9">_</code> for all parameters, like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(multiplier)</span> * <span class="hljs-subst">\(value)</span> = <span class="hljs-subst">\(multiplier <span class="hljs-operator">*</span> value)</span>"</span>)
}
printMultipleOf(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</pre>
<p class="calibre1">In this example, all parameters have no external name. But this illustrates how you use the underscore wisely. Here, your expression is still understandable, but more complex functions that take many parameters can become confusing and unwieldy with no external parameter names. Imagine if a function took five parameters!
</p>
<p class="calibre1">You can also give default values to parameters:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(multiplier)</span> * <span class="hljs-subst">\(value)</span> = <span class="hljs-subst">\(multiplier <span class="hljs-operator">*</span> value)</span>"</span>)
}
printMultipleOf(<span class="hljs-number">4</span>)</pre>
<p class="calibre1">The difference is the <code class="calibre9">= 1</code> after the second parameter, which means that if no value is provided for the second parameter, it defaults to <code class="calibre9">1</code>.
</p>
<p class="calibre1">Therefore, this code prints the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">4 * 1 = 4</code>
</p></div>

<p class="calibre1">It can be useful to have a default value when you expect a parameter to be one particular value most of the time, and it will simplify your code when you call the function.
</p>
<h3 class="segment-title2">Return values</h3>

<p class="calibre1">All of the functions you’ve seen so far have performed a simple task: printing something out. Functions can also return a value, and the caller of the function can assign the return value to a variable or constant or use it directly in an expression.
</p>
<p class="calibre1">With a return value, you can use a function to transform data. You simply take in data through parameters, perform computations and return the result.
</p>
<p class="calibre1">Here’s how you define a function that returns a value:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">multiply</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">return</span> number <span class="hljs-operator">*</span> multiplier
}
<span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> multiply(<span class="hljs-number">4</span>, by: <span class="hljs-number">2</span>)</pre>
<p class="calibre1">To declare that a function returns a value, you add a <code class="calibre9">-&gt;</code> followed by the type of the return value after the set of parentheses and before the opening brace. In this example, the function returns an <code class="calibre9">Int</code>.
</p>
<p class="calibre1">Inside the function, you use a <code class="calibre9">return</code> statement to return the value. In this example, you return the product of the two parameters. It’s also possible to return multiple values through the use of tuples:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">multiplyAndDivide</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">factor</span>: <span class="hljs-built_in">Int</span>)
                   -&gt; (product: <span class="hljs-built_in">Int</span>, quotient: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-keyword">return</span> (number <span class="hljs-operator">*</span> factor, number <span class="hljs-operator">/</span> factor)
}
<span class="hljs-keyword">let</span> results <span class="hljs-operator">=</span> multiplyAndDivide(<span class="hljs-number">4</span>, by: <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> results.product
<span class="hljs-keyword">let</span> quotient <span class="hljs-operator">=</span> results.quotient</pre>
<p class="calibre1">This function returns <i class="calibre2">both</i> the product and quotient of the two parameters: It returns a tuple containing two <code class="calibre9">Int</code> values with appropriate member value names.
</p>
<p class="calibre1">The ability to return multiple values through tuples is one of the many things that makes it a pleasure to work with Swift. And it turns out to be a handy feature, as you’ll see shortly. You can make both of these functions simpler by removing the <code class="calibre9">return</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">multiply</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  number <span class="hljs-operator">*</span> multiplier
}

<span class="hljs-keyword">func</span> <span class="hljs-number">multiplyAndDivide</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">factor</span>: <span class="hljs-built_in">Int</span>)
                   -&gt; (product: <span class="hljs-built_in">Int</span>, quotient: <span class="hljs-built_in">Int</span>) {
  (number <span class="hljs-operator">*</span> factor, number <span class="hljs-operator">/</span> factor)
}</pre>
<p class="calibre1">You can do this because the function is a <em class="calibre5">single statement</em>. If the function had more lines of code in it, then you wouldn’t be able to do this. The idea behind this feature is that in such simple functions, it’s so obvious, and the <code class="calibre9">return</code> gets in the way of readability.
</p>
<p class="calibre1">You need the <code class="calibre9">return</code> for functions with multiple statements because you might make the function return in many different places.
</p>
<h3 class="segment-title2">Advanced parameter handling</h3>

<p class="calibre1">Function parameters are constants, which means they can’t be modified.
</p>
<p class="calibre1">To illustrate this point, consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">incrementAndPrint</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) {
  value <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
  <span class="hljs-built_in">print</span>(value)
}</pre>
<p class="calibre1">This results in an error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Left side of mutating operator isn't mutable: 'value' is a 'let' constant</code>
</p></div>

<p class="calibre1">The parameter <code class="calibre9">value</code> is the equivalent of a constant declared with <code class="calibre9">let</code>. Therefore, when the function attempts to increment it, the compiler emits an error.
</p>
<p class="calibre1">It is important to note that Swift copies the value before passing it to the function, a behavior known as <em class="calibre5">pass</em><em class="calibre5">-</em><em class="calibre5">by</em><em class="calibre5">-</em><em class="calibre5">value</em>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Pass-by-value and making copies is the standard behavior for all of the types you’ve seen so far in this book. You’ll see another way for things to be passed into functions in Chapter 13, “Classes”.
</p></div>

<p class="calibre1">Usually, you want this behavior. Ideally, a function doesn’t alter its parameters. If it did, you couldn’t be sure of the parameters’ values, and you might make incorrect assumptions and introduce bugs into your code.
</p>
<p class="calibre1">Sometimes you <i class="calibre2">do</i> want to let a function change a parameter directly, a behavior known as <em class="calibre5">copy</em><em class="calibre5">-</em><em class="calibre5">in copy</em><em class="calibre5">-</em><em class="calibre5">out</em> or <em class="calibre5">call by value result</em>. You do it like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">incrementAndPrint</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-keyword">inout</span> <span class="hljs-built_in">Int</span>) {
  value <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
  <span class="hljs-built_in">print</span>(value)
}</pre>
<p class="calibre1"><code class="calibre9">inout</code> before the parameter type indicates that this parameter should be copied in, that local copy used within the function, and copied back out when the function returns.  You need to make a slight tweak to the function call to complete this example. Add an ampersand (<code class="calibre9">&amp;</code>) before the argument, which makes it clear at the call site that you are using copy-in copy-out:
</p><pre class="code-block"><span class="hljs-keyword">var</span> value <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
incrementAndPrint(<span class="hljs-operator">&amp;</span>value)
<span class="hljs-built_in">print</span>(value)</pre>
<p class="calibre1">Now the function can change the value however it wishes.
</p>
<p class="calibre1">This example will print the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">6</code>
</p>
<p class="calibre10"><code class="calibre9">6</code>
</p></div>

<p class="calibre1">The function increments <code class="calibre9">value</code> and keeps its modified data after the function finishes. The value goes <i class="calibre2">in</i> to the function and comes back <i class="calibre2">out</i> again, thus the keyword <code class="calibre9">inout</code>.
</p>
<p class="calibre1">Under certain conditions, the compiler can simplify copy-in copy-out to what is called <i class="calibre2">pass</i><i class="calibre2">-</i><i class="calibre2">by</i><i class="calibre2">-</i><i class="calibre2">reference</i>. The argument value isn’t copied into the parameter. Instead, the parameter will hold a reference to the memory of the original value. This optimization satisfies all requirements of copy-in copy-out while removing the need for copies.
</p>
<h3 class="segment-title2">Overloading</h3>

<p class="calibre1">Did you notice how you used the same function name for several different functions in the previous examples?
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">andValue</span>: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">func</span> <span class="hljs-number">printMultipleOf</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">multiplier</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>)</pre>
<p class="calibre1">This is called <em class="calibre5">overloading</em> and lets you define similar functions using a single name.
</p>
<p class="calibre1">However, the compiler must still be able to tell the difference between these functions. Whenever you call a function, it should always be clear which function you’re calling.
</p>
<p class="calibre1">This is usually achieved through a difference in the parameter list:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A different number of parameters.
</p></li>

<li class="calibre4">
<p class="calibre1">Different parameter types.
</p></li>

<li class="calibre4">
<p class="calibre1">Different external parameter names, such as the case with <code class="calibre9">printMultipleOf</code>.
</p></li>
</ul>

<p class="calibre1">You can also overload a function name based on a different return type, like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">getValue</span>() -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-number">31</span>
}

<span class="hljs-keyword">func</span> <span class="hljs-number">getValue</span>() -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-string">"Matt Galloway"</span>
}</pre>
<p class="calibre1">Here, there are two functions called <code class="calibre9">getValue()</code>, which return different types&ndash;one an <code class="calibre9">Int</code> and the other a <code class="calibre9">String</code>.
</p>
<p class="calibre1">Using these is a little more complicated. Consider the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> getValue()</pre>
<p class="calibre1">How does Swift know which <code class="calibre9">getValue()</code> to call? The answer is, it doesn’t. And it will print the following error:
</p><pre class="code-block">error: ambiguous use of 'getValue()'</pre>
<p class="calibre1">There’s no way of knowing which one to call, and it’s a chicken and egg situation. It’s unknown what type <code class="calibre9">value</code> is, so Swift doesn’t know which <code class="calibre9">getValue()</code> to call or the return type of <code class="calibre9">getValue()</code>.
</p>
<p class="calibre1">To fix this, you can declare what type you want <code class="calibre9">value</code> to be, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> valueInt: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> getValue()
<span class="hljs-keyword">let</span> valueString: <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> getValue()</pre>
<p class="calibre1">This will correctly call the <code class="calibre9">Int</code> version of <code class="calibre9">getValue()</code> in the first instance and the <code class="calibre9">String</code> version of <code class="calibre9">getValue()</code> in the second instance.
</p>
<p class="calibre1">It’s worth noting that overloading should be used with care. Only use overloading for functions that are related and similar in behavior.
</p>
<p class="calibre1">When only the return type is overloaded, as in the above example, you lose type inference, which is not recommended.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Write a function named <code class="calibre9">printFullName</code> that takes two strings called <code class="calibre9">firstName</code> and <code class="calibre9">lastName</code>. The function should print out the full name defined as <code class="calibre9">firstName + " " + lastName</code>. Use it to print out your own full name.
</p></li>

<li class="calibre4">
<p class="calibre1">Change the declaration of <code class="calibre9">printFullName</code> to have no external name for either parameter.
</p></li>

<li class="calibre4">
<p class="calibre1">Write a function named <code class="calibre9">calculateFullName</code> that returns the full name as a string. Use it to store your own full name in a constant.
</p></li>

<li class="calibre4">
<p class="calibre1">Change <code class="calibre9">calculateFullName</code> to return a tuple containing both the full name and the length of the name. You can find a string’s length by using the <code class="calibre9">count</code> property. Use this function to determine the length of your own full name.
</p></li>
</ol>

<h2 class="segment-chapter1">Functions as variables</h2>

<p class="calibre1">This may come as a surprise, but functions in Swift are simply another data type. You can assign them to variables and constants just as you can any other type of value, such as an <code class="calibre9">Int</code> or a <code class="calibre9">String</code>.
</p>
<p class="calibre1">To see how this works, consider the following function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  a <span class="hljs-operator">+</span> b
}</pre>
<p class="calibre1">This function takes two parameters and returns the sum of their values.
</p>
<p class="calibre1">You can assign this function to a variable, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> function <span class="hljs-operator">=</span> add</pre>
<p class="calibre1">Here, the variable’s name is <code class="calibre9">function .</code> The compiler infers the type as <code class="calibre9">(Int, Int) -&gt; Int</code> from the <code class="calibre9">add</code> function you assign to it.
</p>
<p class="calibre1">Notice how the function type <code class="calibre9">(Int, Int) -&gt; Int</code> is written in the same way you write the parameter list and return type in a function declaration.
</p>
<p class="calibre1">Here, the <code class="calibre9">function</code> variable is a function type that takes two <code class="calibre9">Int</code> parameters and returns an <code class="calibre9">Int</code>.
</p>
<p class="calibre1">Now you can use the <code class="calibre9">function</code> variable in just the same way you’d use <code class="calibre9">add</code>, like so:
</p><pre class="code-block">function(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</pre>
<p class="calibre1">This returns 6.
</p>
<p class="calibre1">Now consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">subtract</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  a <span class="hljs-operator">-</span> b
}</pre>
<p class="calibre1">Here, you declare another function that takes two <code class="calibre9">Int</code> parameters and returns an <code class="calibre9">Int</code>. You can set the <code class="calibre9">function</code> variable from before to your new <code class="calibre9">subtract</code> function because the parameter list and return type of <code class="calibre9">subtract</code> is compatible with the type of the <code class="calibre9">function</code> variable.
</p><pre class="code-block">function <span class="hljs-operator">=</span> subtract
function(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</pre>
<p class="calibre1">This time, the call to <code class="calibre9">function</code> returns 2.
</p>
<p class="calibre1">The fact that you can assign functions to variables comes in handy because it means you can pass functions to other functions. Here’s an example of this in action:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printResult</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">function</span>: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> function(a, b)
  <span class="hljs-built_in">print</span>(result)
}
printResult(add, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</pre>
<p class="calibre1"><code class="calibre9">printResult</code> takes three parameters:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">function</code> is of a function type that takes two <code class="calibre9">Int</code> parameters and returns an <code class="calibre9">Int</code>, declared like so: <code class="calibre9">(Int, Int) -&gt; Int</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">a</code> is of type <code class="calibre9">Int</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">b</code> is of type <code class="calibre9">Int</code>.
</p></li>
</ol>

<p class="calibre1"><code class="calibre9">printResult</code> calls the passed-in function, passing into it the two <code class="calibre9">Int</code> parameters. Then it prints the result to the console:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">6</code>
</p></div>

<p class="calibre1">It’s extremely useful to be able to pass functions to other functions, and it can help you write reusable code. Not only can you pass data around to manipulate, but passing functions as parameters also means you can be flexible about what code executes.
</p>
<h3 class="segment-title2">The land of no return</h3>

<p class="calibre1">Some functions are never, ever intended to return control to the caller. For example, think about a function that is designed to crash an application. Perhaps this sounds strange, so let me explain: if an application is about to work with corrupt data, it’s often best to crash rather than continue into an unknown and potentially dangerous state.  The function <code class="calibre9">fatalError("reason to terminate")</code> is an example of a function like this. It prints the reason for the fatal error and then halts execution to prevent further damage.
</p>
<p class="calibre1">Another example of a non-returning function is one that handles an event loop. An event loop is at the heart of every modern application that takes input from the user and displays things on a screen. The event loop services requests coming from the user then passes these events to the application code, which in turn causes the information to be displayed on the screen. The loop then cycles back and services the next event.
</p>
<p class="calibre1">These event loops are often started in an application by calling a function known never to return.
</p>
<p class="calibre1">Swift will complain to the compiler that a function is known to never return, like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">noReturn</span>() -&gt; <span class="hljs-built_in">Never</span> {

}</pre>
<p class="calibre1">Notice the special return type <code class="calibre9">Never</code>, indicating that this function will never return.
</p>
<p class="calibre1">If you wrote this code, you would get the following error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Function with uninhabited return type 'Never' is missing call to another never-returning function on all paths</code>
</p></div>

<p class="calibre1">This is a rather long-winded way of saying that the function doesn’t call another “no return” function before it returns itself. When it reaches the end, the function returns to the place from which it was called, breaching the contract of the <code class="calibre9">Never</code> return type.
</p>
<p class="calibre1">A crude but honest implementation of a function that wouldn’t return would be as follows:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">infiniteLoop</span>() -&gt; <span class="hljs-built_in">Never</span> {
  <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> {
  }
}</pre>
<p class="calibre1">You may be wondering why bother with this special return type. It’s useful because by the compiler knowing that the function won’t ever return, it can make certain optimizations when generating the code to call the function. Essentially, the code that calls the function doesn’t need to bother doing anything after the function call because it knows that it will never end before the application is terminated.
</p>
<h3 class="segment-title2">Writing good functions</h3>

<p class="calibre1">Functions let you solve many problems. The best do <i class="calibre2">one simple task</i> , making them easier to mix, match, and model into more complex behaviors.
</p>
<p class="calibre1">Make functions that are easy to use and understand! Give them well-defined inputs that produce the same output every time. You’ll find it’s easier to reason about and test good, clean, simple functions in isolation.
</p>
<h2 class="segment-chapter1">Commenting your functions</h2>

<p class="calibre1">All good software developers document their code. :] ocumenting your functions is an important step to making sure that when you return to the code later or share it with other people, it can be understood without having to trawl through the code.
</p>
<p class="calibre1">Fortunately, Swift has a straightforward way to document functions that integrates well with Xcode’s code completion and other features.
</p>
<p class="calibre1">It uses the defacto <em class="calibre5">Doxygen</em> commenting standard used by many other languages outside of Swift. Let’s take a look at how you can document a function:
</p><pre class="code-block"><span class="hljs-comment">/// Calculates the average of three values</span>
<span class="hljs-comment">/// - Parameters:</span>
<span class="hljs-comment">///   - a: The first value.</span>
<span class="hljs-comment">///   - b: The second value.</span>
<span class="hljs-comment">///   - c: The third value.</span>
<span class="hljs-comment">/// - Returns: The average of the three values.</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">calculateAverage</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Double</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Double</span>, <span class="hljs-built_in">and</span> <span class="hljs-built_in">c</span>: <span class="hljs-built_in">Double</span>) -&gt; <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">let</span> total <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b <span class="hljs-operator">+</span> c
  <span class="hljs-keyword">let</span> average <span class="hljs-operator">=</span> total <span class="hljs-operator">/</span> <span class="hljs-number">3</span>
  <span class="hljs-keyword">return</span> average
}
calculateAverage(of: <span class="hljs-number">1</span>, and: <span class="hljs-number">3</span>, and: <span class="hljs-number">5</span>)</pre>
<p class="calibre1">Instead of the usual double-<code class="calibre9">/</code>, you use triple-<code class="calibre9">/</code> instead. Then the first line is the description of what the function does. Following that is a list of the parameters and, finally, a description of the return value.
</p>
<p class="calibre1">If you forget the format of a documentation comment, simply highlight the function and press “Option-Command-/” in Xcode.  The Xcode editor will insert a comment template for you that you can then fill out.
</p>
<p class="calibre1">When you create this kind of code documentation, you will find that the comment changes the font in Xcode from the usual monospace font. Neat right? Well, yes, but there’s more.
</p>
<p class="calibre1">First, Xcode shows your documentation when code completion comes up, like so:
</p><div class="image4"><img src="images/000007.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Also, you can hold the option key and click on the function name, and Xcode shows your documentation in a handy popover, like so:
</p><div class="image1"><img src="images/000021.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Both of these are very useful, and you should consider documenting all your functions, especially those that are frequently used or complicated. Future you will thank you later. :]
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of functions. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Looping with stride functions</h3>

<p class="calibre1">In Chapter 4, “Advanced Control Flow”, you wrote some <code class="calibre9">for</code> loops with countable ranges. Countable ranges are limited in that they must always be increasing by one. The Swift <code class="calibre9">stride(from:to:by:)</code> and <code class="calibre9">stride(from:through:by:)</code> functions let you loop much more flexibly.
</p>
<p class="calibre1">For example, if you wanted to loop from 10 to 20 by 4’s you can write:
</p><pre class="code-block"><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">10</span>, to: <span class="hljs-number">22</span>, by: <span class="hljs-number">4</span>) {
  <span class="hljs-built_in">print</span>(index)
}
<span class="hljs-comment">// prints 10, 14, 18</span>

<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">stride</span>(from: <span class="hljs-number">10</span>, through: <span class="hljs-number">22</span>, by: <span class="hljs-number">4</span>) {
  <span class="hljs-built_in">print</span>(index)
}
<span class="hljs-comment">// prints 10, 14, 18, and 22</span></pre>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">What is the difference between the two stride function overloads?
</p></li>

<li class="calibre4">
<p class="calibre1">Write a loop that goes from 10.0 to (and including) 9.0, decrementing by 0.1.
</p></li>
</ul>

<h3 class="segment-title2">Challenge 2: It’s prime time</h3>

<p class="calibre1">When I’m acquainting myself with a programming language, one of the first things I do is write a function to determine whether or not a number is prime. That’s your second challenge.
</p>
<p class="calibre1">First, write the following function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isNumberDivisible</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">divisor</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Bool</span></pre>
<p class="calibre1">You’ll use this to determine if one number is divisible by another. It should return <code class="calibre9">true</code> when <code class="calibre9">number</code> is divisible by <code class="calibre9">divisor</code>.
</p>
<p class="calibre1"><em class="calibre5">Hint</em>: You can use the modulo (<code class="calibre9">%</code>) operator to help you out here.
</p>
<p class="calibre1">Next, write the main function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isPrime</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Bool</span></pre>
<p class="calibre1">This should return <code class="calibre9">true</code> if <code class="calibre9">number</code> is prime and <code class="calibre9">false</code> otherwise. A number is prime if it’s only divisible by 1 and itself. You should loop through the numbers from 1 to the number and find the number’s divisors. If it has any divisors other than 1 and itself, then the number isn’t prime. You’ll need to use the <code class="calibre9">isNumberDivisible(_:by:)</code> function you wrote earlier.
</p>
<p class="calibre1">Use this function to check the following cases:
</p><pre class="code-block">isPrime(<span class="hljs-number">6</span>) <span class="hljs-comment">// false</span>
isPrime(<span class="hljs-number">13</span>) <span class="hljs-comment">// true</span>
isPrime(<span class="hljs-number">8893</span>) <span class="hljs-comment">// true</span></pre>
<p class="calibre1"><em class="calibre5">Hint 1</em>: Numbers less than 0 should not be considered prime. Check for this case at the start of the function and return early if the number is less than 0.
</p>
<p class="calibre1"><em class="calibre5">Hint 2</em>: Use a <code class="calibre9">for</code> loop to find divisors. If you start at two and end before the number itself, then as soon as you find a divisor, you can return <code class="calibre9">false</code>.
</p>
<p class="calibre1"><em class="calibre5">Hint 3</em>: If you want to get <i class="calibre2">really</i> clever, you can simply loop from 2 until you reach the square root of <code class="calibre9">number</code>, rather than going all the way up to <code class="calibre9">number</code> itself. I’ll leave it as an exercise for you to figure out why. It may help to think of the number 16, whose square root is 4. The divisors of 16 are 1, 2, 4, 8 and 16.
</p>
<h3 class="segment-title2">Challenge 3: Recursive functions</h3>

<p class="calibre1">In this challenge, you will see what happens when a function calls <i class="calibre2">itself</i>, a behavior called <em class="calibre5">recursion</em>. This may sound unusual, but it can be quite useful.
</p>
<p class="calibre1">You’re going to write a function that computes a value from the <em class="calibre5">Fibonacci sequence</em>. Any value in the sequence is the sum of the previous two values. The sequence is defined such that the first two values equal 1. That is, <code class="calibre9">fibonacci(1) = 1</code> and <code class="calibre9">fibonacci(2) = 1</code>.
</p>
<p class="calibre1">Write your function using the following declaration:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">fibonacci</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span></pre>
<p class="calibre1">Then, verify you’ve written the function correctly by executing it with the following numbers:
</p><pre class="code-block">fibonacci(<span class="hljs-number">1</span>)  <span class="hljs-comment">// = 1</span>
fibonacci(<span class="hljs-number">2</span>)  <span class="hljs-comment">// = 1</span>
fibonacci(<span class="hljs-number">3</span>)  <span class="hljs-comment">// = 2</span>
fibonacci(<span class="hljs-number">4</span>)  <span class="hljs-comment">// = 3</span>
fibonacci(<span class="hljs-number">5</span>)  <span class="hljs-comment">// = 5</span>
fibonacci(<span class="hljs-number">10</span>) <span class="hljs-comment">// = 55</span></pre>
<p class="calibre1"><em class="calibre5">Hint 1</em>: For values of <code class="calibre9">number</code> less than 0, you should return 0.
</p>
<p class="calibre1"><em class="calibre5">Hint 2</em>: To start the sequence, hard-code a return value of 1 when <code class="calibre9">number</code> equals 1 or 2.
</p>
<p class="calibre1"><em class="calibre5">Hint 3</em>: For any other value, you’ll need to return the sum of calling <code class="calibre9">fibonacci</code> with <code class="calibre9">number - 1</code> and <code class="calibre9">number - 2</code>.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You use a <em class="calibre5">function</em> to define a task that you can execute as many times as you like without writing the code multiple times.
</p></li>

<li class="calibre4">
<p class="calibre1">Functions can take zero or more <em class="calibre5">parameters</em> and optionally return a value.
</p></li>

<li class="calibre4">
<p class="calibre1">You can add an external name to a function parameter to change the label you use in a function call, or you can use an underscore to denote no label.
</p></li>

<li class="calibre4">
<p class="calibre1">Parameters are passed as constants, unless you mark them as <code class="calibre9">inout</code>, in which case they are copied-in and copied-out.
</p></li>

<li class="calibre4">
<p class="calibre1">Functions can have the same name with different parameters. This is called overloading.
</p></li>

<li class="calibre4">
<p class="calibre1">Functions can have a special <code class="calibre9">Never</code> return type to inform Swift that this function will never exit.
</p></li>

<li class="calibre4">
<p class="calibre1">You can assign functions to variables and pass them to other functions.
</p></li>

<li class="calibre4">
<p class="calibre1">Strive to create functions that are clearly named and have one job with repeatable inputs and outputs.
</p></li>

<li class="calibre4">
<p class="calibre1">Function documentation can be created by prefixing the function with a comment section using <code class="calibre9">///</code>.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-9">


<h1 class="segment-chapter">Chapter 6: Optionals</h1>

<p class="calibre1">All the variables and constants you’ve dealt with so far have had concrete values. When you had a string variable, like <code class="calibre9">var name</code>, it had a string value associated with it, like <code class="calibre9">"Matt Galloway"</code>. It could have been an empty string, like <code class="calibre9">""</code>, but there was a value to which you could refer.
</p>
<p class="calibre1">That’s one of the built-in safety features of Swift: If the type says <code class="calibre9">Int</code> or <code class="calibre9">String</code>, then there’s an actual integer or string there, guaranteed.
</p>
<p class="calibre1">This chapter will introduce you to the concept of <em class="calibre5">optionals</em>, a special Swift type that can represent a value and the absence of that value. By the end of this chapter, you’ll know why you need optionals and how to use them safely.
</p>
<h2 class="segment-chapter1">Introducing nil</h2>

<p class="calibre1">Sometimes, it’s useful to represent the absence of a value. Imagine a scenario where you need to refer to a person’s identifying information; you want to store the person’s name, age and occupation. Name and age are both things that must have a value &mdash; everyone has them. But not everyone is employed, so the absence of a value for occupation is something you need to handle.
</p>
<p class="calibre1">Without knowing about optionals, this is how you might represent the person’s name, age and occupation:
</p><pre class="code-block"><span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Matt Galloway"</span>
<span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>
<span class="hljs-keyword">var</span> occupation <span class="hljs-operator">=</span> <span class="hljs-string">"Software Developer &amp; Author"</span></pre>
<p class="calibre1">But what if I become unemployed? Maybe I’ve won the lottery and want to give up work altogether (I wish!). This is when it would be useful to be able to refer to the absence of a value.
</p>
<p class="calibre1">Why couldn’t you just use an empty string? You <i class="calibre2">could</i>, but optionals are a much better solution. Read on to see why.
</p>
<h3 class="segment-title2">Sentinel values</h3>

<p class="calibre1">A value representing a special condition such as the absence of a value is known as a <em class="calibre5">sentinel value</em>, or simply, special value. That’s what your empty string would be in the previous example.
</p>
<p class="calibre1">Let’s look at another example. Say your code requests something from a server, and you use a variable to store any returned error code:
</p><pre class="code-block"><span class="hljs-keyword">var</span> errorCode <span class="hljs-operator">=</span> <span class="hljs-number">0</span></pre>
<p class="calibre1">In the success case, you represent the lack of an error with a zero. That means <code class="calibre9">0</code> is a sentinel value.
</p>
<p class="calibre1">Like the empty string for occupation, this works, but it’s potentially confusing for the programmer because it arbitrarily steals a value. <code class="calibre9">0</code> might be a valid error code &mdash; or could be in the future if the server changed how it responded. Either way, you can’t be completely confident that the server didn’t return an error without consulting the documentation about special values.
</p>
<p class="calibre1">In these two examples, it would be much better if there were a special <i class="calibre2">type</i> that could represent the absence of a value. It would then be explicit when a value exists and when one doesn’t, the compiler could check for you.
</p>
<p class="calibre1"><em class="calibre5">Nil</em> is the name given to the absence of a value, and you’re about to see how Swift incorporates this concept directly into the language in a rather elegant way.
</p>
<p class="calibre1">Some other programming languages simply embrace sentinel values. Some, like Objective-C, have the concept of <code class="calibre9">nil</code>, but it is merely a synonym for zero, and it is just another sentinel value.
</p>
<p class="calibre1">Swift introduces a whole new type, <em class="calibre5">Optional</em>, that handles the possibility a value could be <code class="calibre9">nil</code>. If you’re handling a non-optional type, you’re guaranteed to have a value and don’t need to worry about a sentinel value with special meaning. Similarly, if you use an optional type, you know you must handle the <code class="calibre9">nil</code> case. It removes the ambiguity introduced by using sentinel values.
</p>
<h2 class="segment-chapter1">Introducing optionals</h2>

<p class="calibre1">Optionals are Swift’s solution to the problem of representing both a value and the absence of a value. An optional is allowed to hold either a value <i class="calibre2">or</i> <code class="calibre9">nil</code>.
</p>
<p class="calibre1">Think of an optional as a box: it either contains exactly one value or is empty. When it doesn’t contain a value, it’s said to contain <code class="calibre9">nil</code>. The box itself always exists; it’s always there for you to open and look inside.
</p><div class="image3"><img src="images/000047.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">A string or an integer, on the other hand, doesn’t have this box around it. Instead, there’s always a value, such as <code class="calibre9">"hello"</code> or 42. Remember, non-optional types are guaranteed to have an actual value.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Those of you who’ve studied physics may be thinking about Schroedinger’s cat right now. Optionals are a little bit like that, except it’s not a matter of life and death!
</p></div>

<p class="calibre1">You declare a variable of an optional type by using the following syntax:
</p><pre class="code-block"><span class="hljs-keyword">var</span> errorCode: <span class="hljs-built_in">Int</span>?</pre>
<p class="calibre1">The only difference between this and a standard declaration is the question mark at the end of the type. In this case, <code class="calibre9">errorCode</code> is an “optional <code class="calibre9">Int</code>”. This means the variable is like a box containing either an <code class="calibre9">Int</code> or <code class="calibre9">nil</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can add a question mark after any type to create an optional type. This optional type is said to <i class="calibre2">wrap</i> the regular non-optional type. For example, optional type <code class="calibre9">String?</code> wraps type <code class="calibre9">String</code>. In other words: an optional box of type <code class="calibre9">String?</code> holds either a <code class="calibre9">String</code> or <code class="calibre9">nil</code>.
</p></div>

<div class="note">
<p class="calibre10">Also, note how an optional type must be made explicit using a type annotation (here <code class="calibre9">: Int?</code>). Optional types can never be inferred from initialization values, as those values are of a regular, non-optional type, or <code class="calibre9">nil</code>, which can be used with any optional type.
</p></div>

<p class="calibre1">Setting the value is simple. You can either set it to an <code class="calibre9">Int</code>, like so:
</p><pre class="code-block">errorCode <span class="hljs-operator">=</span> <span class="hljs-number">100</span></pre>
<p class="calibre1">Or you can set it to <code class="calibre9">nil</code>, like so:
</p><pre class="code-block">errorCode <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<p class="calibre1">This diagram may help you visualize what’s happening:
</p><div class="image3"><img src="images/000059.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The optional box always exists. When you assign <code class="calibre9">100</code> to the variable, you’re filling the box with the value. When you assign <code class="calibre9">nil</code> to the variable, you’re emptying the box.
</p>
<p class="calibre1">Take a few minutes to think about this concept. The box analogy will be a big help as you go through the rest of the chapter and begin to use optionals.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Make an optional <code class="calibre9">String</code> called <code class="calibre9">myFavoriteSong</code>. If you have a favorite song, set it to a string representing that song. If you have more than one favorite song or no favorite, set the optional to <code class="calibre9">nil</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant called <code class="calibre9">parsedInt</code> and set it equal to <code class="calibre9">Int("10")</code>, which tries to parse the string <code class="calibre9">10</code> and convert it to an <code class="calibre9">Int</code>. Check the type of <code class="calibre9">parsedInt</code> using Option-Click. Why is it an optional?
</p></li>

<li class="calibre4">
<p class="calibre1">Change the string being parsed in the above exercise to a non-integer (try <code class="calibre9">dog</code>, for example). What does <code class="calibre9">parsedInt</code> equal now?
</p></li>
</ol>

<h2 class="segment-chapter1">Unwrapping optionals</h2>

<p class="calibre1">It’s all well and good that optionals exist, but you may be wondering how you can look inside the box and manipulate the value it contains.
</p>
<p class="calibre1">Take a look at what happens when you print out the value of an optional:
</p><pre class="code-block"><span class="hljs-keyword">var</span> result: <span class="hljs-built_in">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">30</span>
<span class="hljs-built_in">print</span>(result)</pre>
<p class="calibre1">This prints the following:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Optional(30)</code>
</p></div>

<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You will also see a warning on this line which says “Expression implicitly coerced from ‘Int?’ to Any”. This is because Swift warns that you’re using an optional in the place of the <code class="calibre9">Any</code> type as it’s something that usually means you did something wrong. You can change the code to <code class="calibre9">print(result as Any)</code> to silence the warning.
</p></div>

<p class="calibre1">That isn’t really what you wanted &mdash; although if you think about it, it makes sense. Your code has printed the box, and the result says, “<code class="calibre9">result</code> is an optional that contains the value <code class="calibre9">30</code>”.
</p>
<p class="calibre1">To see how an optional type is different from a non-optional type, see what happens if you try to use <code class="calibre9">result</code> as if it were a normal integer:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(result <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)</pre>
<p class="calibre1">This code triggers an error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Value of optional type 'Int?' must be unwrapped to a value of type 'Int'</code>
</p></div>

<p class="calibre1">It doesn’t work because you’re trying to add an integer to a box &mdash; not to the value inside the box but to the box itself, which doesn’t make sense.
</p>
<h3 class="segment-title2">Force unwrapping</h3>

<p class="calibre1">The error message indicates the solution: It tells you that the optional <code class="calibre9">must be unwrapped</code>. You need to unwrap the value from its box. It’s like Christmas!
</p>
<p class="calibre1">Let’s see how that works. Consider the following declarations:
</p><pre class="code-block"><span class="hljs-keyword">var</span> authorName: <span class="hljs-built_in">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">"Matt Galloway"</span>
<span class="hljs-keyword">var</span> authorAge: <span class="hljs-built_in">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">30</span></pre>
<p class="calibre1">There are two different methods you can use to unwrap these optionals. The first is known as <em class="calibre5">force unwrapping</em>, and you perform it like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> unwrappedAuthorName <span class="hljs-operator">=</span> authorName<span class="hljs-operator">!</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Author is <span class="hljs-subst">\(unwrappedAuthorName)</span>"</span>)</pre>
<p class="calibre1">This code prints:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Author is Matt Galloway</code>
</p></div>

<p class="calibre1">Great! That’s what you’d expect.
</p>
<p class="calibre1">The exclamation mark after the variable name tells the compiler that you want to look inside the box and take out the value. The result is a value of the wrapped type. This means <code class="calibre9">unwrappedAuthorName</code> is of type <code class="calibre9">String</code>, not <code class="calibre9">String?</code>.
</p>
<p class="calibre1">The use of the word “force” and the exclamation mark <code class="calibre9">!</code> probably conveys a sense of danger to you, and it should.
</p>
<p class="calibre1">You should use force unwrapping sparingly. To see why consider what happens when the optional doesn’t contain a value:
</p><pre class="code-block">authorName <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Author is <span class="hljs-subst">\(authorName<span class="hljs-operator">!</span>)</span>"</span>)</pre>
<p class="calibre1">This code produces the following error that you will see in your console:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Fatal error: Unexpectedly found nil while unwrapping an Optional value</code>
</p></div>

<p class="calibre1">The error occurs because the variable contains no value when you try to unwrap it. What’s worse is that you get this error at runtime rather than compile-time &ndash; which means you’d only notice the error if you happened to execute this code with some invalid input.
</p>
<p class="calibre1">Worse yet, if this code were inside an app, the runtime error would cause the app to crash!
</p>
<p class="calibre1">How can you play it safe?
</p>
<p class="calibre1">To stop the runtime error here, you could wrap the code that unwraps the optional in a check, like so:
</p><pre class="code-block"><span class="hljs-keyword">if</span> authorName <span class="hljs-operator">!=</span> <span class="hljs-keyword">nil</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Author is <span class="hljs-subst">\(authorName<span class="hljs-operator">!</span>)</span>"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No author."</span>)
}</pre>
<p class="calibre1">The <code class="calibre9">if</code> statement checks if the optional contains <code class="calibre9">nil</code>. If it doesn’t, that means it contains a value you can unwrap.
</p>
<p class="calibre1">The code is now safe, but it’s still not perfect. If you rely on this technique, you’ll have to remember to check for <code class="calibre9">nil</code> every time you want to unwrap an optional. That will start to become tedious, and one day you’ll forget and once again end up with the possibility of a runtime error.
</p>
<p class="calibre1">Back to the drawing board, then!
</p>
<h3 class="segment-title2">Optional binding</h3>

<p class="calibre1">Swift includes a feature known as <em class="calibre5">optional binding</em>, which lets you safely access the value inside an optional. You use it like so:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrappedAuthorName <span class="hljs-operator">=</span> authorName {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Author is <span class="hljs-subst">\(unwrappedAuthorName)</span>"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No author."</span>)
}</pre>
<p class="calibre1">You’ll immediately notice that there are no exclamation marks here. This optional binding gets rid of the optional type. If the optional contains a value, this value is unwrapped and stored in, or <i class="calibre2">bound to</i>, the constant <code class="calibre9">unwrappedAuthorName</code>. The <code class="calibre9">if</code> statement then executes the first block of code, within which you can safely use <code class="calibre9">unwrappedAuthorName</code>, as it’s a regular non-optional <code class="calibre9">String</code>.
</p>
<p class="calibre1">If the optional doesn’t contain a value, then the <code class="calibre9">if</code> statement executes the <code class="calibre9">else</code> block. In that case, the <code class="calibre9">unwrappedAuthorName</code> variable doesn’t even exist.
</p>
<p class="calibre1">You can see how optional binding is much safer than force unwrapping, and you should use it whenever an optional might be <code class="calibre9">nil</code>. Force unwrapping is only appropriate when an optional <i class="calibre2">is guaranteed</i> contain a value.
</p>
<p class="calibre1">Because naming things is so hard, it’s common practice to give the unwrapped constant the same name as the optional (thereby <i class="calibre2">shadowing</i> that optional):
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> authorName <span class="hljs-operator">=</span> authorName {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Author is <span class="hljs-subst">\(authorName)</span>"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No author."</span>)
}</pre>
<p class="calibre1">You can even unwrap multiple values at the same time, like so:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> authorName <span class="hljs-operator">=</span> authorName,
   <span class="hljs-keyword">let</span> authorAge <span class="hljs-operator">=</span> authorAge {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The author is <span class="hljs-subst">\(authorName)</span> who is <span class="hljs-subst">\(authorAge)</span> years old."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No author or no age."</span>)
}</pre>
<p class="calibre1">This code unwraps two values. It will only execute the <code class="calibre9">if</code> part of the statement when both optionals contain a value.
</p>
<p class="calibre1">You can combine unwrapping multiple optionals with additional Boolean checks. For example:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> authorName <span class="hljs-operator">=</span> authorName,
   <span class="hljs-keyword">let</span> authorAge <span class="hljs-operator">=</span> authorAge,
   authorAge <span class="hljs-operator">&gt;=</span> <span class="hljs-number">40</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The author is <span class="hljs-subst">\(authorName)</span> who is <span class="hljs-subst">\(authorAge)</span> years old."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No author or no age or age less than 40."</span>)
}</pre>
<p class="calibre1">Here, you unwrap <code class="calibre9">name</code> and <code class="calibre9">age</code> and check that <code class="calibre9">age</code> is greater than or equal to 40. The expression in the <code class="calibre9">if</code> statement will only be <code class="calibre9">true</code> if <code class="calibre9">name</code> is non-<code class="calibre9">nil</code>, <i class="calibre2">and</i> <code class="calibre9">age</code> is non-<code class="calibre9">nil</code>, <i class="calibre2">and</i> <code class="calibre9">age</code> is greater than or equal to 40.
</p>
<p class="calibre1">Now you know how to safely look inside an optional and extract its value if one exists.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Using your <code class="calibre9">myFavoriteSong</code> variable from earlier, use optional binding to check if it contains a value. If it does, print out the value. If it doesn’t, print <code class="calibre9">"I don’t have a favorite song."</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Change <code class="calibre9">myFavoriteSong</code> to the opposite of what it is now. If it’s <code class="calibre9">nil</code>, set it to a string; if it’s a string, set it to <code class="calibre9">nil</code>. Observe how your printed result changes.
</p></li>
</ol>

<h2 class="segment-chapter1">Introducing guard</h2>

<p class="calibre1">Sometimes you want to check a condition and only continue executing a function if the condition is true, such as when you use optionals. Imagine a function that fetches some data from the network. That fetch might fail if the network is down. The usual way to encapsulate this behavior is using an optional, which has a value if the fetch succeeds, and <code class="calibre9">nil</code> otherwise.
</p>
<p class="calibre1">Swift has a useful and powerful feature to help in situations like this: the <code class="calibre9"><em class="calibre13">guard</em></code><em class="calibre5"> statement</em>. Let’s take a look at it with this contrived example for now:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">guardMyCastle</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>?) {
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> castleName <span class="hljs-operator">=</span> name <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"No castle!"</span>)
    <span class="hljs-keyword">return</span> 
  }
  
  <span class="hljs-comment">// At this point, `castleName` is a non-optional String</span>
  
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Your castle called <span class="hljs-subst">\(castleName)</span> was guarded!"</span>)
}</pre>
<p class="calibre1">The guard statement comprises <code class="calibre9">guard</code> followed by a condition that can include both Boolean expressions and optional bindings, followed by <code class="calibre9">else</code>, followed by a block of code. The block of code covered by the <code class="calibre9">else</code> will execute if the condition is <i class="calibre2">false</i>. The block of code that executes in the case of the condition being false <i class="calibre2">must</i> return. If you accidentally forget, the compiler will stop you &mdash; this is the guard statement’s true beauty.
</p>
<p class="calibre1">You may hear programmers talking about the “happy path” through a function; this is the path you’d expect to happen most of the time. Any other path followed would be due to an error or another reason why the function should return earlier than expected.
</p>
<p class="calibre1">Guard statements ensure the happy path remains on the left-hand side of the code; this is usually a good thing as it makes code more readable and understandable. Also, because the guard statement must return in the false case, the Swift compiler knows that if the condition was true, anything checked in the guard statement’s condition <i class="calibre2">must</i> be true for the remainder of the function.
</p>
<p class="calibre1">This means the compiler can make specific optimizations. You don’t need to understand how these optimizations work or even what they are since Swift is designed to be user-friendly and fast.
</p>
<p class="calibre1">You could simply use an <code class="calibre9">if-let</code> binding and return when it’s <code class="calibre9">nil</code>. However, when you use <code class="calibre9">guard</code>, you are explicitly saying that this must return if the statement in the <code class="calibre9">guard</code> is false. Thus the compiler can make sure that you have added a return. The compiler is providing some nice safety for you!
</p>
<p class="calibre1">Let’s see guard in a more “real world” example. Consider the following function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">calculateNumberOfSides</span>(<span class="hljs-built_in">shape</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">Int</span>? {
  <span class="hljs-keyword">switch</span> shape {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Triangle"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Square"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Rectangle"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Pentagon"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"Hexagon"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
  }
}</pre>
<p class="calibre1">This function takes a shape name and returns the number of sides that shape has. If the shape isn’t known, or you pass something that isn’t a shape, it returns <code class="calibre9">nil</code>.
</p>
<p class="calibre1">You could use this function like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">maybePrintSides</span>(<span class="hljs-built_in">shape</span>: <span class="hljs-built_in">String</span>) {
  <span class="hljs-keyword">let</span> sides <span class="hljs-operator">=</span> calculateNumberOfSides(shape: shape)

  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> sides <span class="hljs-operator">=</span> sides {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A <span class="hljs-subst">\(shape)</span> has <span class="hljs-subst">\(sides)</span> sides."</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I don’t know the number of sides for <span class="hljs-subst">\(shape)</span>."</span>)
  }
}</pre>
<p class="calibre1">There’s nothing wrong with this, and it would work.
</p>
<p class="calibre1">However the same logic could be written with a guard statement like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">maybePrintSides</span>(<span class="hljs-built_in">shape</span>: <span class="hljs-built_in">String</span>) {
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> sides <span class="hljs-operator">=</span> calculateNumberOfSides(shape: shape) <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I don’t know the number of sides for <span class="hljs-subst">\(shape)</span>."</span>)
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-built_in">print</span>(<span class="hljs-string">"A <span class="hljs-subst">\(shape)</span> has <span class="hljs-subst">\(sides)</span> sides."</span>)
}</pre>
<p class="calibre1">When your functions get more complex, <code class="calibre9">guard</code> really comes into its own. You may have multiple <code class="calibre9">guard</code>s at the top of the function that set up the initial conditions correctly. You’ll see it used extensively in Swift code.
</p>
<h2 class="segment-chapter1">Nil coalescing</h2>

<p class="calibre1">There’s a rather handy alternative way to unwrap an optional. You use it when you want to get a value out of the optional <i class="calibre2">no matter what</i> &mdash; and in the case of <code class="calibre9">nil</code>, you’ll use a default value. This is called <em class="calibre5">nil coalescing</em>. Here’s how it works:
</p><pre class="code-block"><span class="hljs-keyword">var</span> optionalInt: <span class="hljs-built_in">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">var</span> mustHaveResult <span class="hljs-operator">=</span> optionalInt <span class="hljs-operator">??</span> <span class="hljs-number">0</span></pre>
<p class="calibre1">The <code class="calibre9">nil</code> coalescing happens on the second line, with the double question mark (<code class="calibre9">??</code>), known as the <em class="calibre5">nil coalescing operator</em>. This line means <code class="calibre9">mustHaveResult</code> will equal either the value inside <code class="calibre9">optionalInt</code>, or <code class="calibre9">0</code> if <code class="calibre9">optionalInt</code> contains <code class="calibre9">nil</code>. In this example, <code class="calibre9">mustHaveResult</code> contains the concrete <code class="calibre9">Int</code> value of <code class="calibre9">10</code>.
</p>
<p class="calibre1">The previous code is equivalent to the following:
</p><pre class="code-block"><span class="hljs-keyword">var</span> optionalInt: <span class="hljs-built_in">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">var</span> mustHaveResult: <span class="hljs-built_in">Int</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unwrapped <span class="hljs-operator">=</span> optionalInt {
  mustHaveResult <span class="hljs-operator">=</span> unwrapped
} <span class="hljs-keyword">else</span> {
  mustHaveResult <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
}</pre>
<p class="calibre1">Set the <code class="calibre9">optionalInt</code> to <code class="calibre9">nil</code>, like so:
</p><pre class="code-block">optionalInt <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
mustHaveResult <span class="hljs-operator">=</span> optionalInt <span class="hljs-operator">??</span> <span class="hljs-number">0</span></pre>
<p class="calibre1">Now <code class="calibre9">mustHaveResult</code> equals <code class="calibre9">0</code>.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of optionals. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: You be the compiler</h3>

<p class="calibre1">Which of the following are valid statements?
</p><pre class="code-block"><span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">"Ray"</span>
<span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
<span class="hljs-keyword">let</span> distance: <span class="hljs-built_in">Float</span> <span class="hljs-operator">=</span> <span class="hljs-number">26.7</span>
<span class="hljs-keyword">var</span> middleName: <span class="hljs-built_in">String</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<h3 class="segment-title2">Challenge 2: Divide and conquer</h3>

<p class="calibre1">First, create a function that returns the number of times an integer can be divided by another integer without a remainder. The function should return <code class="calibre9">nil</code> if the division doesn’t produce a whole number. Name the function <code class="calibre9">divideIfWhole</code>.
</p>
<p class="calibre1">Then, write code that tries to unwrap the optional result of the function. There should be two cases: upon success, print <code class="calibre9">"Yep, it divides \(answer) times"</code>, and upon failure, print <code class="calibre9">"Not divisible :["</code>.
</p>
<p class="calibre1">Finally, test your function:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Divide 10 by 2. This should print <code class="calibre9">"Yep, it divides 5 times."</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Divide 10 by 3. This should print <code class="calibre9">"Not divisible :[."</code>
</p></li>
</ol>

<p class="calibre1"><em class="calibre5">Hint 1</em>: Use the following as the start of the function signature:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">divideIfWhole</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">by</span> <span class="hljs-built_in">divisor</span>: <span class="hljs-built_in">Int</span>)</pre>
<p class="calibre1">You’ll need to add the return type, which will be an optional!
</p>
<p class="calibre1"><em class="calibre5">Hint 2</em>: You can use the modulo operator (<code class="calibre9">%</code>) to determine if a value is divisible by another; recall that this operation returns the remainder from the division of two numbers. For example, <code class="calibre9">10 % 2 = 0</code> means that 10 is divisible by 2 with no remainder, whereas <code class="calibre9">10 % 3 = 1</code> means that 10 is divisible by 3 with a remainder of 1.
</p>
<h3 class="segment-title2">Challenge 3: Refactor and reduce</h3>

<p class="calibre1">The code you wrote in the last challenge used <code class="calibre9">if</code> statements. In this challenge, refactor that code to use <code class="calibre9">nil</code> coalescing instead. This time, make it print <code class="calibre9">"It divides X times"</code> in all cases, but if the division doesn’t result in a whole number, then <code class="calibre9">X</code> should be <code class="calibre9">0</code>.
</p>
<h3 class="segment-title2">Challenge 4: Nested optionals</h3>

<p class="calibre1">Consider the following nested optional &mdash; it corresponds to a number inside a box inside a box inside a box.
</p><pre class="code-block"><span class="hljs-keyword">let</span> number: <span class="hljs-built_in">Int</span>??? <span class="hljs-operator">=</span> <span class="hljs-number">10</span></pre>
<p class="calibre1">If you print <code class="calibre9">number</code> you get the following:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(number)
<span class="hljs-comment">// Optional(Optional(Optional(10)))</span>

<span class="hljs-built_in">print</span>(number<span class="hljs-operator">!</span>)
<span class="hljs-comment">// Optional(Optional(10))</span></pre>
<p class="calibre1">Do the following:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Fully force unwrap and print <code class="calibre9">number</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Optionally bind and print <code class="calibre9">number</code> with <code class="calibre9">if let</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Write a function <code class="calibre9">printNumber(_ number: Int???)</code> that uses <code class="calibre9">guard</code> to print the number only if it is bound.
</p></li>
</ol>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">nil</code> represents the absence of a value.
</p></li>

<li class="calibre4">
<p class="calibre1">Non-optional variables and constants are never <code class="calibre9">nil</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Optional</em> variables and constants are like boxes that can contain a value <i class="calibre2">or</i> be empty (<code class="calibre9">nil</code>).
</p></li>

<li class="calibre4">
<p class="calibre1">To work with the value inside an optional, you must first unwrap it from the optional.
</p></li>

<li class="calibre4">
<p class="calibre1">The safest way to unwrap an optional’s value is by using <em class="calibre5">optional binding</em> or <em class="calibre5">nil coalescing</em>. Use <em class="calibre5">forced unwrapping</em> only when appropriate, as it could produce a runtime error.
</p></li>

<li class="calibre4">
<p class="calibre1">You can <code class="calibre9">guard let</code> to bind an optional.  If the binding fails, the compiler forces you to exit the current function (or halt execution). This guarantees that your program never executes with an uninitialized value.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-21">


<h1 class="segment-chapter">Section II: Collection Types</h1>

<p class="calibre1">So far, you’ve mostly seen data in the form of single elements. Although tuples can have multiple pieces of data, you have to specify the size upfront; a tuple with three strings is a completely different type from a tuple with two strings, and converting between them isn’t trivial. In this section, you’ll learn about <em class="calibre5">collection types</em> in Swift. Collections are flexible “containers” that let you store any number of values together.
</p>
<p class="calibre1">There are several collection types in Swift, but three important ones are arrays, dictionaries and sets. You’ll learn to apply custom operations and loop over collection types. Finally, you’ll revisit strings, which are collections of characters.
</p>
<p class="calibre1">All the collection types share similar interfaces but have very different use cases. As you read through these chapters, keep the differences in mind, and you’ll begin to develop a feel for which type you should use when.
</p></div>

<div class="segment-title" id="calibre_link-26">


<h1 class="segment-chapter">Chapter 7: Arrays, Dictionaries &amp; Sets</h1>

<p class="calibre1">As discussed in the introduction to this section, collections are flexible “containers” that let you store any number of values together. Before discussing these collections, you need to understand the concept of <i class="calibre2">mutable</i> vs. <i class="calibre2">immutable</i> collections.
</p>
<p class="calibre1">As part of exploring the differences between the collection types, you’ll also consider performance: how quickly the collections can perform certain operations, such as adding or searching through it.
</p>
<p class="calibre1">The usual way to talk about performance is with <em class="calibre5">big</em><em class="calibre5">-</em><em class="calibre5">O notation</em>. If you’re not familiar with it already, start reading the chapter for a brief introduction.
</p>
<p class="calibre1">Big-O notation is a way to describe <em class="calibre5">running time</em>, or how long an operation takes to complete. The idea is that the exact time an operation takes isn’t as important; it’s the relative difference in scale that matters.
</p>
<p class="calibre1">Imagine you have a list of names in some random order, and you have to look up the first name on the list. It doesn’t matter whether the list has a single name or a million names &mdash; glancing at the first name always takes the same amount of time. That’s an example of a <em class="calibre5">constant time</em> operation, or <em class="calibre5">O(1)</em> in big-O notation.
</p>
<p class="calibre1">Now say you have to find a particular name on the list. You need to scan through the list and look at every name until you either find a match or reach the end. Again, we’re not concerned with the exact amount of time this takes, just the relative time compared to other operations.
</p>
<p class="calibre1">To figure out the running time, think in terms of units of work. You need to look at every name, so consider there to be one “unit” of work per name. If you had 100 names, that’s 100 units of work. What if you double the number of names to 200? How does that change the amount of work?
</p>
<p class="calibre1">The answer is it <i class="calibre2">also</i> doubles the amount of work. Similarly, if you quadruple the number of names, that quadruples the amount of work.
</p>
<p class="calibre1">This increase in work is an example of a <em class="calibre5">linear time</em> operation, or <em class="calibre5"><i class="calibre2">O</i></em><em class="calibre5">(N)</em> in big-O notation. The input size is the variable N, which means the amount of time the process takes is also N. There’s a direct, linear relationship between the input size (the number of names in the list) and the time it will take to search for one name.
</p>
<p class="calibre1">You can see why constant time operations use the number one in <i class="calibre2">O</i>(1). They’re just a single unit of work, no matter what!
</p>
<p class="calibre1">You can read more about big-O notation by searching the Web. You’ll only need constant time and linear time in this book, but there are other such <em class="calibre5">time complexities</em> out there.
</p>
<p class="calibre1">Big-O notation is particularly important when dealing with collection types because collections can store vast amounts of data. You need to be aware of running times when you add, delete or edit values.
</p>
<p class="calibre1">For example, if collection type A has constant-time searching and collection type B has linear-time searching, which you choose to use will depend on how much searching you’re planning to do.
</p>
<h2 class="segment-chapter1">Mutable versus immutable collections</h2>

<p class="calibre1">Like the previous types you’ve read about, such as <code class="calibre9">Int</code> or <code class="calibre9">String</code>, when you create a collection, you must declare it as either a constant or a variable.
</p>
<p class="calibre1">If the collection doesn’t need to change after you’ve created it, you should make it immutable by declaring it as a constant with <code class="calibre9">let</code>. Alternatively, if you need to add, remove or update values in the collection, you should create a mutable collection by declaring it as a variable with <code class="calibre9">var</code>.
</p>
<h2 class="segment-chapter1">Arrays</h2>

<p class="calibre1">Arrays are the most common collection type you’ll run into in Swift. Arrays are typed, just like regular variables and constants, and store multiple values like a simple list.
</p>
<p class="calibre1">Before you create your first array, take some time to consider in detail what an array is and why you might want to use one.
</p>
<h2 class="segment-chapter1">What is an array?</h2>

<p class="calibre1">An array is an ordered collection of values of the same type. The elements in the array are <em class="calibre5">zero</em><em class="calibre5">-</em><em class="calibre5">indexed</em>, which means the index of the first element is 0, the index of the second element is 1, and so on. Knowing this, you can determine that the last element’s index is the number of values in the array minus one.
</p><div class="image6"><img src="images/000092.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">There are five elements in this array, at indices 0&ndash;4.
</p>
<p class="calibre1">All values are of type <code class="calibre9">String</code>, so you can’t add non-string types to an array that holds strings. Notice that the same value can appear multiple times.
</p>
<h2 class="segment-chapter1">When are arrays useful?</h2>

<p class="calibre1">Arrays are useful when you want to store your items in a particular order. You may want the elements sorted, or you may need to fetch elements by index without iterating through the entire array.
</p>
<p class="calibre1">For example, if you were storing high score data, then the order would matter. You would want the highest score to come first in the list (i.e., at index 0) with the next-highest score after that, and so on.
</p>
<h2 class="segment-chapter1">Creating arrays</h2>

<p class="calibre1">The easiest way to create an array is by using an <em class="calibre5">array literal</em>. This is a concise way to provide array values. An array literal is a list of values separated by commas and surrounded by square brackets.
</p><pre class="code-block"><span class="hljs-keyword">let</span> evenNumbers <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</pre>
<p class="calibre1">Since the array literal only contains integers, Swift infers the type of <code class="calibre9">evenNumbers</code> to be an array of <code class="calibre9">Int</code> values. This type is written as <code class="calibre9">[Int]</code>. The type inside the square brackets defines the type of values the array can store, which the compiler will enforce when adding elements to the array.
</p>
<p class="calibre1">If you try to add a string, for example, the compiler will return an error, and your code won’t compile. You can create an empty using the empty array literal <code class="calibre9">[]</code>. Because the compiler isn’t able to infer a type from this, you need to use a type annotation to make the type explicit:
</p><pre class="code-block"><span class="hljs-keyword">var</span> subscribers: [<span class="hljs-built_in">String</span>] <span class="hljs-operator">=</span> []</pre>
<p class="calibre1">It’s also possible to create an array with all of its values set to a default value:
</p><pre class="code-block"><span class="hljs-keyword">let</span> allZeros <span class="hljs-operator">=</span> <span class="hljs-built_in">Array</span>(repeating: <span class="hljs-number">0</span>, count: <span class="hljs-number">5</span>) <span class="hljs-comment">// [0, 0, 0, 0, 0]</span></pre>
<p class="calibre1">It’s good practice to declare arrays that aren’t going to change as constants. For example, consider this array:
</p><pre class="code-block"><span class="hljs-keyword">let</span> vowels <span class="hljs-operator">=</span> [<span class="hljs-string">"A"</span>, <span class="hljs-string">"E"</span>, <span class="hljs-string">"I"</span>, <span class="hljs-string">"O"</span>, <span class="hljs-string">"U"</span>]</pre>
<p class="calibre1"><code class="calibre9">vowels</code> is an array of strings, and its values can’t be changed. But that’s fine since the list of vowels doesn’t tend to change very often!
</p>
<h2 class="segment-chapter1">Accessing elements</h2>

<p class="calibre1">Being able to create arrays is useless unless you know how to fetch values from an array. In this section, you’ll learn several different ways to access elements in an array.
</p>
<h3 class="segment-title2">Using properties and methods</h3>

<p class="calibre1">Imagine creating a game of cards, and you want to store the players’ names in an array. The list will need to change as players join or leave the game, so you need to declare a mutable array:
</p><pre class="code-block"><span class="hljs-keyword">var</span> players <span class="hljs-operator">=</span> [<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Cindy"</span>, <span class="hljs-string">"Dan"</span>]</pre>
<p class="calibre1">In this example, <code class="calibre9">players</code> is a mutable array because you assigned it to a variable.
</p>
<p class="calibre1">Before the game starts, you need to make sure there are enough players. You can use the <code class="calibre9">isEmpty</code> <i class="calibre2">property</i> to check if there’s at least one player:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(players.isEmpty)
<span class="hljs-comment">// &gt; false</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You’ll learn all about properties in Chapter 11, “Properties”. For now, just think of them as variables that are built into values. To access a property, place a dot after the name of the constant or variable that holds the value and follow it by the name of the property you want to access.
</p></div>

<p class="calibre1">The array isn’t empty, but you need at least two players to start a game. You can get the number of players using the <code class="calibre9">count</code> property:
</p><pre class="code-block"><span class="hljs-keyword">if</span> players.count <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"We need at least two players!"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Let’s start!"</span>)
}
<span class="hljs-comment">// &gt; Let’s start!</span></pre>
<p class="calibre1">It’s time to start the game! You decide that the order of play is by the order of names in the array. How would you get the first player’s name?
</p>
<p class="calibre1">Arrays provide the <code class="calibre9">first</code> property to fetch the first object of an array:
</p><pre class="code-block"><span class="hljs-keyword">var</span> currentPlayer <span class="hljs-operator">=</span> players.first</pre>
<p class="calibre1">Printing the value of <code class="calibre9">currentPlayer</code> reveals something interesting:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(currentPlayer <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>)
<span class="hljs-comment">// &gt; Optional("Alice")</span></pre>
<p class="calibre1">The property <code class="calibre9">first</code> actually returns an <i class="calibre2">optional</i> because if the array were empty, <code class="calibre9">first</code> would return <code class="calibre9">nil</code>. The <code class="calibre9">print()</code> method realizes <code class="calibre9">currentPlayer</code> is optional and generates a warning. To suppress the warning, simply add <code class="calibre9">as Any</code> to the type to be printed.
</p>
<p class="calibre1">Similarly, arrays have a <code class="calibre9">last</code> property that returns the last value in an array, or <code class="calibre9">nil</code> if the array is empty:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(players.last <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>)
<span class="hljs-comment">// &gt; Optional("Dan")</span></pre>
<p class="calibre1">Another way to get values from an array is by calling <code class="calibre9">min()</code>. This <i class="calibre2">method</i> returns the element with the lowest <i class="calibre2">value</i> in the array &mdash; not the lowest index!
</p>
<p class="calibre1">If the array contained strings, then it would return the string that’s the lowest in alphabetical order, which in this case is <code class="calibre9">"Alice"</code>:
</p><pre class="code-block">currentPlayer <span class="hljs-operator">=</span> players.min()
<span class="hljs-built_in">print</span>(currentPlayer <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>)
<span class="hljs-comment">// &gt; Optional("Alice")</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You’ll learn all about methods in Chapter 12, “Methods”. For now, just think of them as functions that are built into values. To call a method, place a dot after the name of the constant or variable that holds the value and follow it by the name of the method you want to call. Like functions, don’t forget to include the parameter list, even if it’s empty, when calling a method.
</p></div>

<p class="calibre1">Obviously, <code class="calibre9">first</code> and <code class="calibre9">min()</code> will not always return the same value. For example:
</p><pre class="code-block"><span class="hljs-built_in">print</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>].first <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>)
<span class="hljs-comment">// &gt; Optional(2)</span>
<span class="hljs-built_in">print</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>].min() <span class="hljs-keyword">as</span> <span class="hljs-keyword">Any</span>)
<span class="hljs-comment">// &gt; Optional(1)</span></pre>
<p class="calibre1">As you might have guessed, arrays also have a <code class="calibre9">max()</code> method.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The <code class="calibre9">first</code> and <code class="calibre9">last</code> properties and the <code class="calibre9">min()</code> and <code class="calibre9">max()</code> methods aren’t unique to arrays. Every collection type has these properties and methods, in addition to a plethora of others. You’ll learn more about this behavior when you read about protocols in Chapter 16, “Protocols”.
</p></div>

<p class="calibre1">Now that you know how to get the first player, you’ll announce who that player is:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> currentPlayer <span class="hljs-operator">=</span> currentPlayer {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(currentPlayer)</span> will start"</span>)
}
<span class="hljs-comment">// &gt; Alice will start</span></pre>
<p class="calibre1">You use <code class="calibre9">if let</code> to unwrap the optional you got back from <code class="calibre9">min()</code>; otherwise, the statement would print <code class="calibre9">Optional("Alice") will start</code>, which is not what you want.
</p>
<p class="calibre1">These properties and methods are helpful if you want to get the first, last, minimum or maximum elements. But what if the element you want can’t be obtained with one of these properties or methods?
</p>
<h3 class="segment-title2">Using subscripting</h3>

<p class="calibre1">The most convenient way to access elements in an array is by using the subscript syntax. This syntax lets you access any value directly by using its index inside square brackets:
</p><pre class="code-block"><span class="hljs-keyword">var</span> firstPlayer <span class="hljs-operator">=</span> players[<span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"First player is <span class="hljs-subst">\(firstPlayer)</span>"</span>)
<span class="hljs-comment">// &gt; First player is "Alice"</span></pre>
<p class="calibre1">Because arrays are zero-indexed, you use index 0 to fetch the first object. You can use a greater index to get the next elements in the array, but if you try to access an index that’s beyond the size of the array, you’ll get a runtime error.
</p><pre class="code-block"><span class="hljs-keyword">var</span> player <span class="hljs-operator">=</span> players[<span class="hljs-number">4</span>]
<span class="hljs-comment">// &gt; fatal error: Index out of range</span></pre>
<p class="calibre1">You receive this error because <code class="calibre9">players</code> contains only four strings. Index 4 represents the fifth element, but there <i class="calibre2">is</i> no fifth element in this array.
</p>
<p class="calibre1">When you use subscripts, you don’t have to worry about optionals since trying to access a non-existing index doesn’t return <code class="calibre9">nil</code>; it simply causes a runtime error.
</p>
<h3 class="segment-title2">Using countable ranges to make an <code class="calibre12">ArraySlice</code></h3>

<p class="calibre1">You can use the subscript syntax with countable ranges to fetch more than a single value from an array. For example, if you’d like to get the next two players, you could do this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> upcomingPlayersSlice <span class="hljs-operator">=</span> players[<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">2</span>]
<span class="hljs-built_in">print</span>(upcomingPlayersSlice[<span class="hljs-number">1</span>], upcomingPlayersSlice[<span class="hljs-number">2</span>])
<span class="hljs-comment">// &gt; "Bob Cindy\n"</span></pre>
<p class="calibre1">The constant <code class="calibre9">upcomingPlayersSlice</code> is actually an <code class="calibre9">ArraySlice</code> of the original array. The reason for this type difference is to make clear that <code class="calibre9">upcomingPlayersSlice</code> shares storage with <code class="calibre9">players</code>.
</p>
<p class="calibre1">The range you used is <code class="calibre9">1...2</code>, representing the second and third items in the array. You can use an index here as long as the start value is smaller than or equal to the end value and within the array’s bounds.
</p>
<p class="calibre1">It is also easy to make a brand-new, zero-indexed <code class="calibre9">Array</code> from an <code class="calibre9">ArraySlice</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> upcomingPlayersArray <span class="hljs-operator">=</span> <span class="hljs-built_in">Array</span>(players[<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">2</span>])
<span class="hljs-built_in">print</span>(upcomingPlayersArray[<span class="hljs-number">0</span>], upcomingPlayersArray[<span class="hljs-number">1</span>])
<span class="hljs-comment">// &gt; "Bob Cindy\n"</span></pre>
<h3 class="segment-title2">Checking for an element</h3>

<p class="calibre1">You can check if there’s at least one occurrence of a specific element in an array by using <code class="calibre9">contains(_:)</code>, which returns <code class="calibre9">true</code> if it finds the element in the array, and <code class="calibre9">false</code> otherwise.
</p>
<p class="calibre1">You can use this strategy to write a function that checks if a given player is in the game:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isEliminated</span>(<span class="hljs-built_in">player</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-operator">!</span>players.contains(player)
}</pre>
<p class="calibre1">Now you can use this function any time you need to check if a player has been eliminated:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(isEliminated(player: <span class="hljs-string">"Bob"</span>))
<span class="hljs-comment">// &gt; false</span></pre>
<p class="calibre1">You could even test for the existence of an element in a specific range using an <code class="calibre9">ArraySlice</code>:
</p><pre class="code-block">players[<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3</span>].contains(<span class="hljs-string">"Bob"</span>) <span class="hljs-comment">// true</span></pre>
<p class="calibre1">Now that you can get data <i class="calibre2">out</i> of your arrays, it’s time to look at mutable arrays and how to change their values.
</p>
<h2 class="segment-chapter1">Modifying arrays</h2>

<p class="calibre1">You can make all kinds of changes to mutable arrays, such as adding and removing elements, updating existing values, and moving elements around into a different order. In this section, you’ll see how to work with the array to match up what’s going on with your game.
</p>
<h3 class="segment-title2">Appending elements</h3>

<p class="calibre1">If new players want to join the game, they need to sign up and add their names to the array. Eli is the first player to join the existing four players. You can add Eli to the end of the array using the <code class="calibre9">append(_:)</code> method:
</p><pre class="code-block">players.append(<span class="hljs-string">"Eli"</span>)</pre>
<p class="calibre1">If you try to append anything other than a string, the compiler will show an error. Remember, arrays can only store values of the same type. Also, <code class="calibre9">append(_:)</code> only works with mutable arrays.
</p>
<p class="calibre1">The next player to join the game is Gina. You can append her to the game another way by using the <code class="calibre9">+=</code> operator:
</p><pre class="code-block">players <span class="hljs-operator">+=</span> [<span class="hljs-string">"Gina"</span>]</pre>
<p class="calibre1">The right-hand side of this expression is an array with a single element: the string <code class="calibre9">"Gina"</code>. By using <code class="calibre9">+=</code>, you’re appending the elements of that array to <code class="calibre9">players</code>.
</p>
<p class="calibre1">Now the array looks like this:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Alice", "Bob", "Cindy", "Dan", "Eli", "Gina"]</span></pre>
<p class="calibre1">Here, you added a single element to the array, but you can see how easy it would be to append <i class="calibre2">multiple</i> items using the <code class="calibre9">+=</code> operator by adding more names after Gina’s.
</p>
<h3 class="segment-title2">Inserting elements</h3>

<p class="calibre1">An unwritten rule of this card game is that the players’ names have to be in alphabetical order. This list is missing a player that starts with the letter F. Luckily, Frank has just arrived. You want to add him to the list between Eli and Gina. To do that, you can use the <code class="calibre9">insert(_:at:)</code> method:
</p><pre class="code-block">players.insert(<span class="hljs-string">"Frank"</span>, at: <span class="hljs-number">5</span>)</pre>
<p class="calibre1">The <code class="calibre9">at</code> argument defines where you want to add the element. Remember that the array is zero-indexed, so index 5 is Gina’s index, causing her to move up as Frank takes her place.
</p>
<h3 class="segment-title2">Removing elements</h3>

<p class="calibre1">During the game, the other players caught Cindy and Gina cheating. They should be removed from the game! You know that Gina is last in the players list, so you can remove her easily with the <code class="calibre9">removeLast()</code> method:
</p><pre class="code-block"><span class="hljs-keyword">var</span> removedPlayer <span class="hljs-operator">=</span> players.removeLast()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(removedPlayer)</span> was removed"</span>)
<span class="hljs-comment">// &gt; Gina was removed</span></pre>
<p class="calibre1">This method does two things: It removes the last element and then returns it, in case you need to print it or store it somewhere else &mdash; like in an array of cheaters!
</p>
<p class="calibre1">To remove Cindy from the game, you need to know the exact index where her name is stored. Looking at the list of players, you see that she’s third, so her index is 2.
</p><pre class="code-block">removedPlayer <span class="hljs-operator">=</span> players.remove(at: <span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(removedPlayer)</span> was removed"</span>)
<span class="hljs-comment">// &gt; Cindy was removed</span></pre>
<p class="calibre1">But how would you get the index of an element if you didn’t already know it? There’s a method for that! <code class="calibre9">firstIndex(of:)</code> returns the <i class="calibre2">first index</i> of the element because the array might contain multiple copies of the same value. If the method doesn’t find the element, it returns <code class="calibre9">nil</code>.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Use <code class="calibre9">firstIndex(of:)</code> to determine the position of the element <code class="calibre9">"Dan"</code> in <code class="calibre9">players</code>.
</p>
<h3 class="segment-title2">Updating elements</h3>

<p class="calibre1">Frank has decided everyone should call him Franklin from now on. You could remove the value <code class="calibre9">"Frank"</code> from the array and then add <code class="calibre9">"Franklin"</code>, but that’s too much work for a simple task. Instead, you should use the subscript syntax to update the name.
</p><pre class="code-block"><span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Alice", "Bob", "Dan", "Eli", "Frank"]</span>
players[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"Franklin"</span>
<span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Alice", "Bob", "Dan", "Eli", "Franklin"]</span></pre>
<p class="calibre1">Be careful not to use an index beyond the bounds of the array, or your code will crash.
</p>
<p class="calibre1">As the game continues, some players are eliminated, and new ones come to replace them. You can also use subscripting with ranges to update multiple values in a single line of code:
</p><pre class="code-block">players[<span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [<span class="hljs-string">"Donna"</span>, <span class="hljs-string">"Craig"</span>, <span class="hljs-string">"Brian"</span>, <span class="hljs-string">"Anna"</span>]
<span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Donna", "Craig", "Brian", "Anna", "Dan", "Eli", "Franklin"]</span></pre>
<p class="calibre1">This code replaces the first two players, Alice and Bob, with the four players in the new player’s array. As you can see, the size of the range doesn’t have to be equal to the size of the array that holds the values you’re adding.
</p>
<h3 class="segment-title2">Moving elements</h3>

<p class="calibre1">Take a look at this mess! The <code class="calibre9">players</code> array contains names that start with A to F, but they aren’t in the correct order, which violates the rules of the game.
</p>
<p class="calibre1">You can try to fix this situation by moving values one by one to their correct positions:
</p><pre class="code-block"><span class="hljs-keyword">let</span> playerAnna <span class="hljs-operator">=</span> players.remove(at: <span class="hljs-number">3</span>)
players.insert(playerAnna, at: <span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Anna", "Donna", "Craig", "Brian", "Dan", "Eli", "Franklin"]</span></pre>
<p class="calibre1">…or by swapping elements, by using <code class="calibre9">swapAt(_:_:)</code>:
</p><pre class="code-block">players.swapAt(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Anna", "Brian", "Craig", "Donna", "Dan", "Eli", "Franklin"]</span></pre>
<p class="calibre1">This works for a few elements, but to sort the entire array, you should use <code class="calibre9">sort()</code>:
</p><pre class="code-block">players.sort()
<span class="hljs-built_in">print</span>(players)
<span class="hljs-comment">// &gt; ["Anna", "Brian", "Craig", "Dan", "Donna", "Eli", "Franklin"]</span></pre>
<p class="calibre1">If you’d like to leave the original array untouched and return a sorted <i class="calibre2">copy</i> instead, use <code class="calibre9">sorted()</code> instead of <code class="calibre9">sort()</code>.
</p>
<h2 class="segment-chapter1">Iterating through an array</h2>

<p class="calibre1">It’s getting late, so the players decide to stop for the night and continue tomorrow. In the meantime, you’ll keep their scores in a separate array. You’ll investigate a better approach for this when you learn about dictionaries, but for now, you can continue to use arrays:
</p><pre class="code-block"><span class="hljs-keyword">let</span> scores <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</pre>
<p class="calibre1">Before the players leave, you want to print the names of those still in the game. You can do this using the <code class="calibre9">for-in</code> loop you read about in Chapter 4, “Advanced Control Flow”:
</p><pre class="code-block"><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players {
  <span class="hljs-built_in">print</span>(player)
}
<span class="hljs-comment">// &gt; Anna</span>
<span class="hljs-comment">// &gt; Brian</span>
<span class="hljs-comment">// &gt; Craig</span>
<span class="hljs-comment">// &gt; Dan</span>
<span class="hljs-comment">// &gt; Donna</span>
<span class="hljs-comment">// &gt; Eli</span>
<span class="hljs-comment">// &gt; Franklin</span></pre>
<p class="calibre1">This code goes over all the elements of <code class="calibre9">players</code>, from index 0 up to <code class="calibre9">players.count - 1</code> and prints their values. In the first iteration, <code class="calibre9">player</code> is equal to the first element of the array; in the second iteration, it’s equal to the second element of the array; and so on, until the loop has printed all the elements in the array.
</p>
<p class="calibre1">If you need the index of each element, you can iterate over the return value of the array’s <code class="calibre9">enumerated()</code> method, which returns tuples with each element’s index and value:
</p><pre class="code-block"><span class="hljs-keyword">for</span> (index, player) <span class="hljs-keyword">in</span> players.enumerated() {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(index <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)</span>. <span class="hljs-subst">\(player)</span>"</span>)
}
<span class="hljs-comment">// &gt; 1. Anna</span>
<span class="hljs-comment">// &gt; 2. Brian</span>
<span class="hljs-comment">// &gt; 3. Craig</span>
<span class="hljs-comment">// &gt; 4. Dan</span>
<span class="hljs-comment">// &gt; 5. Donna</span>
<span class="hljs-comment">// &gt; 6. Eli</span>
<span class="hljs-comment">// &gt; 7. Franklin</span></pre>
<p class="calibre1">Now you can use the technique you’ve just learned to write a function that takes an array of integers as its input and returns the sum of its elements:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">sumOfElements</span>(<span class="hljs-built_in">in</span> <span class="hljs-built_in">array</span>: [<span class="hljs-built_in">Int</span>]) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">var</span> sum <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> array {
    sum <span class="hljs-operator">+=</span> number
  }
  <span class="hljs-keyword">return</span> sum
}</pre>
<p class="calibre1">You could use this function to calculate the sum of the players’ scores:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(sumOfElements(in: scores))
<span class="hljs-comment">// &gt; 22</span></pre>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a <code class="calibre9">for-in</code> loop that prints the players’ names and scores.
</p>
<h2 class="segment-chapter1">Running time for array operations</h2>

<p class="calibre1">Arrays are stored as a contiguous block in memory. That means if you have ten elements in an array, the ten values are all stored one next to the other. With that in mind, here’s the performance cost of various array operations:
</p>
<p class="calibre1"><em class="calibre5">Accessing elements</em>: The cost of fetching an element is cheap, meaning it happens in a fixed or constant time. Sometimes this is written <i class="calibre2">O</i>(<i class="calibre2">1</i>). Since all the values are sequential, it’s easy to use <i class="calibre2">random access</i> and fetch a value at a particular index; all the compiler needs to know is where the array starts and what index you want to fetch.
</p>
<p class="calibre1"><em class="calibre5">Inserting elements</em>: The complexity of adding an element depends on the position in which you add the new element:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">If you add to the beginning of the array, Swift requires time proportional to the size of the array because it has to shift all of the elements over by one to make room. This is called linear time and sometimes written <i class="calibre2">O</i>(<i class="calibre2">n</i>).
</p></li>

<li class="calibre4">
<p class="calibre1">Likewise, if you add to the middle of the array, all values from that index on need to be shifted over. Doing so will require <code class="calibre9">n/2</code> operations; therefore, the running time is still linear with the size of the array or <i class="calibre2">O</i>(<i class="calibre2">n</i>).
</p></li>
</ul>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">If you add to the end of the array using <code class="calibre9">append</code> and there’s room, it will take <i class="calibre2">O</i>(<i class="calibre2">1</i>). If there isn’t room, Swift will need to make space somewhere else and copy the entire array over before adding the new element, which will take <i class="calibre2">O</i>(<i class="calibre2">n</i>). The average case is <i class="calibre2">O</i>(<i class="calibre2">1</i>) because arrays are not full most of the time.
</p></li>
</ul>

<p class="calibre1"><em class="calibre5">Deleting elements</em>: Deleting an element leaves a gap where the removed element was. All elements in the array must be sequential, so this gap needs to be closed by shifting elements forward.
</p>
<p class="calibre1">The complexity is similar to inserting elements: If you’re removing an element from the end, it’s an <i class="calibre2">O</i>(<i class="calibre2">1</i>) operation. Otherwise, the complexity is <i class="calibre2">O</i>(<i class="calibre2">n</i>).
</p>
<p class="calibre1"><em class="calibre5">Searching for an element</em>: If the element you’re searching for is the first element in the array, then the search will end after a single operation. If the element doesn’t exist, you need to perform <code class="calibre9">N</code> operations until you realize that the element is not found. On average, searching for an element will take <code class="calibre9">n/2</code> operations; therefore, searching has a complexity of <i class="calibre2">O</i>(<i class="calibre2">n</i>).
</p>
<p class="calibre1">As you learn about dictionaries and sets, you’ll see how their performance characteristics differ from arrays. That could give you a hint on which collection type to use for your particular case.
</p>
<h2 class="segment-chapter1">Dictionaries</h2>

<p class="calibre1">A dictionary is an unordered collection of pairs, where each pair comprises a <em class="calibre5">key</em> and a <em class="calibre5">value</em>.
</p>
<p class="calibre1">As shown in the diagram below, keys are unique. The same key can’t appear twice in a dictionary, but different keys may point to the same value. All keys must be of the same type, and all values must be of the same type.
</p><div class="image2"><img src="images/000105.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Dictionaries are useful when you want to look up values by means of an identifier. For example, the table of contents of this book maps chapter names to their page numbers, making it easy to skip to the chapter you want to read.
</p>
<p class="calibre1">How is this different from an array? With an array, you can only fetch a value by its index, which has to be an integer, and all indexes have to be sequential. In a dictionary, the keys can be of any type and in no particular order.
</p>
<h2 class="segment-chapter1">Creating dictionaries</h2>

<p class="calibre1">The easiest way to create a dictionary is by using a <em class="calibre5">dictionary literal</em>. This is a list of key-value pairs separated by commas, enclosed in square brackets.
</p>
<p class="calibre1">For your card game from earlier, instead of using the two arrays to map players to their scores, you can use a dictionary literal:
</p><pre class="code-block"><span class="hljs-keyword">var</span> namesAndScores <span class="hljs-operator">=</span> [<span class="hljs-string">"Anna"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"Brian"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"Craig"</span>: <span class="hljs-number">8</span>, <span class="hljs-string">"Donna"</span>: <span class="hljs-number">6</span>]
<span class="hljs-built_in">print</span>(namesAndScores)
<span class="hljs-comment">// &gt; ["Craig": 8, "Anna": 2, "Donna": 6, "Brian": 2]</span></pre>
<p class="calibre1">In this example, the compiler infers the dictionary type to be <code class="calibre9">[String: Int]</code>. This means <code class="calibre9">namesAndScores</code> is a dictionary with strings as keys and integers as values.
</p>
<p class="calibre1">When you print the dictionary, you see there’s no particular order to the pairs. Remember that, unlike arrays, dictionaries are unordered! The empty dictionary literal looks like this: <code class="calibre9">[:]</code>. You can use that to empty an existing dictionary, like so:
</p><pre class="code-block">namesAndScores <span class="hljs-operator">=</span> [:]</pre>
<p class="calibre1">…or create a new dictionary, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> pairs: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> [:]</pre>
<p class="calibre1">The type annotation is required here, as the compiler can’t infer the type of the dictionary from the empty dictionary literal.
</p>
<p class="calibre1">After you create a dictionary, you can define its capacity:
</p><pre class="code-block">pairs.reserveCapacity(<span class="hljs-number">20</span>)</pre>
<p class="calibre1">Using <code class="calibre9">reserveCapacity(_:)</code> is an easy way to improve performance when you know how much data the dictionary needs to store.
</p>
<h2 class="segment-chapter1">Accessing values</h2>

<p class="calibre1">As with arrays, there are several ways to access dictionary values.
</p>
<h3 class="segment-title2">Using subscripting</h3>

<p class="calibre1">Dictionaries support subscripting to access values. Unlike arrays, you don’t access a value by its index but rather by its key. For example, if you want to get Anna’s score, you would type:
</p><pre class="code-block">namesAndScores <span class="hljs-operator">=</span> [<span class="hljs-string">"Anna"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"Brian"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"Craig"</span>: <span class="hljs-number">8</span>, <span class="hljs-string">"Donna"</span>: <span class="hljs-number">6</span>]
<span class="hljs-comment">// Restore the values</span>

<span class="hljs-built_in">print</span>(namesAndScores[<span class="hljs-string">"Anna"</span>]<span class="hljs-operator">!</span>) <span class="hljs-comment">// 2</span></pre>
<p class="calibre1">Notice that the return type is an optional. The dictionary will check if there’s a pair with the key <code class="calibre9">Anna</code>, and if there is, return its value. If the dictionary doesn’t find the key, it will return <code class="calibre9">nil</code>.
</p><pre class="code-block">namesAndScores[<span class="hljs-string">"Greg"</span>] <span class="hljs-comment">// nil</span></pre>
<p class="calibre1">With arrays, out-of-bounds subscript access causes a runtime error, but dictionaries are different since their results are wrapped in an optional. Subscript access using optionals is really powerful. You can find out if a specific player is in the game without iterating over all the keys, as you must do when using an array.
</p>
<h3 class="segment-title2">Using properties and methods</h3>

<p class="calibre1">Dictionaries, like arrays, conform to Swift’s <code class="calibre9">Collection</code> protocol.  Because of that, they share many of the same properties. For example, both arrays and dictionaries have <code class="calibre9">isEmpty</code> and <code class="calibre9">count</code> properties:
</p><pre class="code-block">namesAndScores.isEmpty  <span class="hljs-comment">//  false</span>
namesAndScores.count    <span class="hljs-comment">//  4</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you want to know whether a collection has elements or not, it is always better to use the <code class="calibre9">isEmpty</code> property than comparing <code class="calibre9">count</code> to zero. Although arrays and dictionaries compute <code class="calibre9">count</code> in constant time, not every collection is guaranteed to do so. For example, <code class="calibre9">count</code> on a <code class="calibre9">String</code> needs to loop through all of its characters. <code class="calibre9">isEmpty</code>, by contrast, always runs in constant time no matter how many values there are for every collection type.
</p></div>

<h2 class="segment-chapter1">Modifying dictionaries</h2>

<p class="calibre1">It’s easy enough to create dictionaries and access their contents &mdash; but what about modifying them?
</p>
<h3 class="segment-title2">Adding pairs</h3>

<p class="calibre1">Bob wants to join the game.
</p><div class="image7"><img src="images/000114.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Take a look at his details before you let him join:
</p><pre class="code-block"><span class="hljs-keyword">var</span> bobData <span class="hljs-operator">=</span> [
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"Bob"</span>,
  <span class="hljs-string">"profession"</span>: <span class="hljs-string">"Card Player"</span>,
  <span class="hljs-string">"country"</span>: <span class="hljs-string">"USA"</span>
]</pre>
<p class="calibre1">This dictionary is of type <code class="calibre9">[String: String]</code>, and it’s mutable because it’s assigned to a variable. Imagine you received more information about Bob, and you wanted to add it to the dictionary. This is how you’d do it:
</p><pre class="code-block">bobData.updateValue(<span class="hljs-string">"CA"</span>, forKey: <span class="hljs-string">"state"</span>)</pre>
<p class="calibre1">There’s even a shorter way to add pairs, using subscripting:
</p><pre class="code-block">bobData[<span class="hljs-string">"city"</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"San Francisco"</span></pre>
<p class="calibre1">Bob’s a professional card player. So far, he sounds like an excellent addition to your roster.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a function that prints a given player’s city and state.
</p>
<h3 class="segment-title2">Updating values</h3>

<p class="calibre1">It appears that in the past, Bob was caught cheating when playing cards. He’s not just a professional &mdash; he’s a card shark! He asks you to change his name and profession so no one will recognize him.
</p>
<p class="calibre1">Because Bob seems eager to change his ways, you agree. First, you change his name from Bob to Bobby:
</p><pre class="code-block">bobData.updateValue(<span class="hljs-string">"Bobby"</span>, forKey: <span class="hljs-string">"name"</span>) <span class="hljs-comment">// Bob</span></pre>
<p class="calibre1">You saw this method above when you read about adding pairs. Why does it return the string <code class="calibre9">Bob</code>? <code class="calibre9">updateValue(_:forKey:)</code> replaces the value of the given key with the new value and returns the old value. If the key doesn’t exist, this method will add a new pair and return <code class="calibre9">nil</code>.
</p>
<p class="calibre1">As with adding, you can do this with less code by using subscripting:
</p><pre class="code-block">bobData[<span class="hljs-string">"profession"</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"Mailman"</span></pre>
<p class="calibre1">Like <code class="calibre9">updateValue(_:forKey:)</code>, this code updates the value for this key or, if the key doesn’t exist, creates a new pair.
</p>
<h3 class="segment-title2">Removing pairs</h3>

<p class="calibre1">Bob &mdash; er, sorry &mdash; <i class="calibre2">Bobby</i>, still doesn’t feel safe, and he wants you to remove all information about his whereabouts:
</p><pre class="code-block">bobData.removeValue(forKey: <span class="hljs-string">"state"</span>)</pre>
<p class="calibre1">This method will remove the key <code class="calibre9">state</code> and its associated value from the dictionary. As you might expect, there’s a shorter way to do this using subscripting:
</p><pre class="code-block">bobData[<span class="hljs-string">"city"</span>] <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<p class="calibre1">Assigning <code class="calibre9">nil</code> as a key’s associated value removes the pair from the dictionary.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you’re using a dictionary that has values that are optional types, <code class="calibre9">dictionary[key] = nil</code> still removes the key completely. If you want to keep the key and set the value to <code class="calibre9">nil,</code> you must use the <code class="calibre9">updateValue</code> method.
</p></div>

<h3 class="segment-title2">Iterating through dictionaries</h3>

<p class="calibre1">The <code class="calibre9">for-in</code> loop also works when you want to iterate over a dictionary. But since the items in a dictionary are pairs, you can use a tuple:
</p><pre class="code-block"><span class="hljs-keyword">for</span> (player, score) <span class="hljs-keyword">in</span> namesAndScores {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(player)</span> - <span class="hljs-subst">\(score)</span>"</span>)
}
<span class="hljs-comment">// &gt; Craig - 8</span>
<span class="hljs-comment">// &gt; Anna - 2</span>
<span class="hljs-comment">// &gt; Donna - 6</span>
<span class="hljs-comment">// &gt; Brian - 2</span></pre>
<p class="calibre1">It’s also possible to iterate over just the keys:
</p><pre class="code-block"><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> namesAndScores.keys {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(player)</span>, "</span>, terminator: <span class="hljs-string">""</span>) <span class="hljs-comment">// no newline</span>
}
<span class="hljs-built_in">print</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// print one final newline</span>
<span class="hljs-comment">// &gt; Craig, Anna, Donna, Brian,</span></pre>
<p class="calibre1">You can iterate over just the values in the same manner with the <code class="calibre9">values</code> property of the dictionary.
</p>
<h3 class="segment-title2">Running time for dictionary operations</h3>

<p class="calibre1">To examine how dictionaries work, you need to understand what <em class="calibre5">hashing</em> is and how it works. Hashing is the process of transforming a value &mdash; <code class="calibre9">String</code>, <code class="calibre9">Int</code>, <code class="calibre9">Double</code>, <code class="calibre9">Bool</code>, etc. &mdash; to a numeric value, known as the <i class="calibre2">hash value</i>.  This value can then be used to quickly look up the values in a <i class="calibre2">hash table</i>.
</p>
<p class="calibre1">Swift dictionaries have a type requirement for keys. Keys must be <em class="calibre5">Hashable</em>, or you will get a compiler error.
</p>
<p class="calibre1">Fortunately, in Swift, all basic types are already <code class="calibre9">Hashable</code> and have a hash value. This value must be deterministic &mdash; meaning that a given value must <i class="calibre2">always</i> return the same hash value. No matter how many times you calculate the hash value for <code class="calibre9">some string</code>, it will always give the same value. However, you should never save a hash value because it will be different each time you run your program.
</p>
<p class="calibre1">Here’s the performance of various dictionary operations. This great performance hinges on having a good hashing function that avoids value collisions.
</p>
<p class="calibre1">All operations below degenerate to linear time <i class="calibre2">O</i>(<i class="calibre2">n</i>) performance if you have a poor hashing function. Fortunately, the built-in types have great, general-purpose <code class="calibre9">Hashable</code> implementations.
</p>
<p class="calibre1"><em class="calibre5">Accessing elements</em>: Getting the value for a key is a constant time operation, or <i class="calibre2">O</i>(<i class="calibre2">1</i>).
</p>
<p class="calibre1"><em class="calibre5">Inserting elements</em>: To insert an element, the dictionary needs to calculate the hash value of the key then store data based on that hash. These are all <i class="calibre2">O</i>(<i class="calibre2">1</i>) operations.
</p>
<p class="calibre1"><em class="calibre5">Deleting elements</em>: Again, the dictionary needs to calculate the hash value to know exactly where to find the element and then remove it. This is also an <i class="calibre2">O</i>(<i class="calibre2">1</i>) operation.
</p>
<p class="calibre1"><em class="calibre5">Searching for an element</em>: As mentioned above, accessing an element has constant running time, so the complexity for searching is also <i class="calibre2">O</i>(<i class="calibre2">1</i>).
</p>
<p class="calibre1">While these running times compare favorably to arrays, remember that you lose order information when using dictionaries.
</p>
<h2 class="segment-chapter1">Sets</h2>

<p class="calibre1">A set is an unordered collection of unique values of the same type. This can be extremely useful when you want to ensure that an item doesn’t appear more than once in your collection and when the order of your items isn’t important.
</p><div class="image3"><img src="images/000001.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">There are four strings in the Set illustration above. Notice that there’s no order for the elements.
</p>
<h3 class="segment-title2">Creating sets</h3>

<p class="calibre1">You can declare a set explicitly by writing <code class="calibre9">Set</code> followed by the type inside angle brackets:
</p><pre class="code-block"><span class="hljs-keyword">let</span> setOne: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]</pre>
<h3 class="segment-title2">Set literals</h3>

<p class="calibre1">Sets don’t have their own literals. You use <em class="calibre5">array literals</em> to create a set with initial values. Consider this example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> someArray <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]</pre>
<p class="calibre1">This is an array. So how would you use array literals to create a set? Like this:
</p><pre class="code-block"><span class="hljs-keyword">var</span> explicitSet: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]</pre>
<p class="calibre1">You have to explicitly declare the variable as a <code class="calibre9">Set</code>. However, you can let the compiler infer the element type like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> someSet <span class="hljs-operator">=</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])</pre>
<p class="calibre1">To see the most important features of a set in action, print the set you just created:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(someSet)
<span class="hljs-comment">// &gt; [2, 3, 1] but the order is not defined</span></pre>
<p class="calibre1">First, you can see there’s no specific ordering. Second, although you created the set with two instances of the value <code class="calibre9">1</code>, that value only appears once. Remember, a set’s values must be unique.
</p>
<h3 class="segment-title2">Accessing elements</h3>

<p class="calibre1">You can use <code class="calibre9">contains(_:)</code> to check for the existence of a specific element:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(someSet.contains(<span class="hljs-number">1</span>))
<span class="hljs-comment">// &gt; true</span>
<span class="hljs-built_in">print</span>(someSet.contains(<span class="hljs-number">4</span>))
<span class="hljs-comment">// &gt; false</span></pre>
<p class="calibre1">You can also use the <code class="calibre9">first</code> and <code class="calibre9">last</code> properties, which return one of the elements in the set. However, because sets are unordered, you won’t know which item you’ll get.
</p>
<h3 class="segment-title2">Adding and removing elements</h3>

<p class="calibre1">You can use <code class="calibre9">insert(_:)</code> to add elements to a set. If the element already exists, the method does nothing.
</p><pre class="code-block">someSet.insert(<span class="hljs-number">5</span>)</pre>
<p class="calibre1">You can remove the element from the set like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> removedElement <span class="hljs-operator">=</span> someSet.remove(<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(removedElement<span class="hljs-operator">!</span>)
<span class="hljs-comment">// &gt; 1</span></pre>
<p class="calibre1"><code class="calibre9">remove(_:)</code> returns the removed element if it’s in the set, or <code class="calibre9">nil</code> otherwise.
</p>
<h3 class="segment-title2">Running time for set operations</h3>

<p class="calibre1">Sets have a very similar implementation to dictionaries, and they also require the elements to be hashable. The running time of all the operations is identical to those of dictionaries.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of arrays, dictionaries and sets. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Which is valid</h3>

<p class="calibre1">Which of the following are valid statements?
</p><pre class="code-block"><span class="hljs-number">1</span>. <span class="hljs-keyword">let</span> array1 <span class="hljs-operator">=</span> [<span class="hljs-built_in">Int</span>]()
<span class="hljs-number">2</span>. <span class="hljs-keyword">let</span> array2 <span class="hljs-operator">=</span> []
<span class="hljs-number">3</span>. <span class="hljs-keyword">let</span> array3: [<span class="hljs-built_in">String</span>] <span class="hljs-operator">=</span> []</pre>
<p class="calibre1">For the next five statements, <code class="calibre9">array4</code> has been declared as:
</p><pre class="code-block"><span class="hljs-keyword">let</span> array4 <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</pre><pre class="code-block"><span class="hljs-number">4</span>. <span class="hljs-built_in">print</span>(array4[<span class="hljs-number">0</span>])
<span class="hljs-number">5</span>. <span class="hljs-built_in">print</span>(array4[<span class="hljs-number">5</span>])
<span class="hljs-number">6</span>. array4[<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">2</span>]
<span class="hljs-number">7</span>. array4[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">4</span>
<span class="hljs-number">8</span>. array4.append(<span class="hljs-number">4</span>)</pre>
<p class="calibre1">For the final five statements, <code class="calibre9">array5</code> has been declared as:
</p><pre class="code-block"><span class="hljs-keyword">var</span> array5 <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</pre><pre class="code-block"><span class="hljs-number">9</span>. array5[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> array5[<span class="hljs-number">1</span>]
<span class="hljs-number">10</span>. array5[<span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-number">11</span>. array5[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"Six"</span>
<span class="hljs-number">12</span>. array5 <span class="hljs-operator">+=</span> <span class="hljs-number">6</span>
<span class="hljs-number">13</span>. <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> array5 { <span class="hljs-built_in">print</span>(item) }</pre>
<h3 class="segment-title2">Challenge 2: Remove the first number</h3>

<p class="calibre1">Write a function that removes the first occurrence of a given integer from an array of integers. This is the signature of the function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">removingOnce</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">item</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">array</span>: [<span class="hljs-built_in">Int</span>]) -&gt; [<span class="hljs-built_in">Int</span>]</pre>
<h3 class="segment-title2">Challenge 3: Remove the numbers</h3>

<p class="calibre1">Write a function that removes all occurrences of a given integer from an array of integers. This is the signature of the function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">removing</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">item</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">array</span>: [<span class="hljs-built_in">Int</span>]) -&gt; [<span class="hljs-built_in">Int</span>]</pre>
<h3 class="segment-title2">Challenge 4: Reverse an array</h3>

<p class="calibre1">Arrays have a <code class="calibre9">reversed()</code> method that returns an array holding the same elements as the original array in reverse order. Write a function that does the same thing without using <code class="calibre9">reversed()</code>. This is the signature of the function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">reversed</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">array</span>: [<span class="hljs-built_in">Int</span>]) -&gt; [<span class="hljs-built_in">Int</span>]</pre>
<h3 class="segment-title2">Challenge 5: Return the middle</h3>

<p class="calibre1">Write a function that returns the middle element of an array. When array size is even, return the first of the two middle elements.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">middle</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">array</span>: [<span class="hljs-built_in">Int</span>]) -&gt; <span class="hljs-built_in">Int</span>?</pre>
<h3 class="segment-title2">Challenge 6: Find the minimum and maximum</h3>

<p class="calibre1">Write a function that calculates the minimum and maximum values in an array of integers. Calculate these values yourself; don’t use the methods <code class="calibre9">min</code> and <code class="calibre9">max</code>. Return <code class="calibre9">nil</code> if the given array is empty.
</p>
<p class="calibre1">This is the signature of the function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">minMax</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">numbers</span>: [<span class="hljs-built_in">Int</span>]) -&gt; (min: <span class="hljs-built_in">Int</span>, max: <span class="hljs-built_in">Int</span>)<span class="hljs-operator">?</span></pre>
<h3 class="segment-title2">Challenge 7: Which is valid</h3>

<p class="calibre1">Which of the following are valid statements?
</p><pre class="code-block"><span class="hljs-number">1</span>. <span class="hljs-keyword">let</span> dict1: [<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> [:]
<span class="hljs-number">2</span>. <span class="hljs-keyword">let</span> dict2 <span class="hljs-operator">=</span> [:]
<span class="hljs-number">3</span>. <span class="hljs-keyword">let</span> dict3: [<span class="hljs-built_in">Int</span>: <span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> [:]</pre>
<p class="calibre1">For the next four statements, use the following dictionary:
</p><pre class="code-block"><span class="hljs-keyword">let</span> dict4 <span class="hljs-operator">=</span> [<span class="hljs-string">"One"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"Two"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"Three"</span>: <span class="hljs-number">3</span>]</pre><pre class="code-block"><span class="hljs-number">4</span>. dict4[<span class="hljs-number">1</span>]
<span class="hljs-number">5</span>. dict4[<span class="hljs-string">"One"</span>]
<span class="hljs-number">6</span>. dict4[<span class="hljs-string">"Zero"</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-number">7</span>. dict4[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"Zero"</span></pre>
<p class="calibre1">For the next three statements, use the following dictionary:
</p><pre class="code-block"><span class="hljs-keyword">var</span> dict5 <span class="hljs-operator">=</span> [<span class="hljs-string">"NY"</span>: <span class="hljs-string">"New York"</span>, <span class="hljs-string">"CA"</span>: <span class="hljs-string">"California"</span>]</pre><pre class="code-block"><span class="hljs-number">8</span>. dict5[<span class="hljs-string">"NY"</span>]
<span class="hljs-number">9</span>. dict5[<span class="hljs-string">"WA"</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"Washington"</span>
<span class="hljs-number">10</span>. dict5[<span class="hljs-string">"CA"</span>] <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<h3 class="segment-title2">Challenge 8: Long names</h3>

<p class="calibre1">Given a dictionary with two-letter state codes as keys, and the full state names as values, write a function that prints all the states with names longer than eight characters. For example, for the dictionary <code class="calibre9">["NY": "New York", "CA": "California"]</code>, the output would be <code class="calibre9">California</code>.
</p>
<h3 class="segment-title2">Challenge 9: Merge dictionaries</h3>

<p class="calibre1">Write a function that combines two dictionaries into one. If a certain key appears in both dictionaries, ignore the pair from the first dictionary. This is the function’s signature:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">merging</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">dict1</span>: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>], <span class="hljs-built_in">with</span> <span class="hljs-built_in">dict2</span>: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>]) -&gt; [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>]</pre>
<h3 class="segment-title2">Challenge 10: Count the characters</h3>

<p class="calibre1">Declare a function <code class="calibre9">occurrencesOfCharacters</code> that calculates which characters occur in a string, as well as how often each of these characters occur. Return the result as a dictionary. This is the function signature:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">occurrencesOfCharacters</span>(<span class="hljs-built_in">in</span> <span class="hljs-built_in">text</span>: <span class="hljs-built_in">String</span>) -&gt; [<span class="hljs-built_in">Character</span>: <span class="hljs-built_in">Int</span>]</pre>
<p class="calibre1">Hint: <code class="calibre9">String</code> is a collection of characters that you can iterate over with a for statement.Bonus: To make your code shorter, dictionaries have a special subscript operator that lets you add a default value if it is not found in the dictionary. For example, <code class="calibre9">dictionary["a", default: 0]</code> creates a 0 entry for the character “a” if it is not found instead of just returning <code class="calibre9">nil</code>.
</p>
<h3 class="segment-title2">Challenge 11: Unique values</h3>

<p class="calibre1">Write a function that returns <code class="calibre9">true</code> if all of the values of a dictionary are unique.  Use a set to test uniqueness. This is the function signature:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isInvertible</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">dictionary</span>: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">Int</span>]) -&gt; <span class="hljs-built_in">Bool</span></pre>
<h3 class="segment-title2">Challenge 12: Removing keys and setting values to nil</h3>

<p class="calibre1">Given the dictionary:
</p><pre class="code-block"><span class="hljs-keyword">var</span> nameTitleLookup: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>?] <span class="hljs-operator">=</span> [<span class="hljs-string">"Mary"</span>: <span class="hljs-string">"Engineer"</span>, <span class="hljs-string">"Patrick"</span>: <span class="hljs-string">"Intern"</span>, <span class="hljs-string">"Ray"</span>: <span class="hljs-string">"Hacker"</span>]</pre>
<p class="calibre1">Set the value of the key <code class="calibre9">"Patrick"</code> to <code class="calibre9">nil</code> and completely remove the key and value for <code class="calibre9">"Ray"</code>.
</p>
<h2 class="segment-chapter1">Key points</h2>

<p class="calibre1"><em class="calibre5">Sets:</em>
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Are unordered collections of unique values of the same type.
</p></li>

<li class="calibre4">
<p class="calibre1">Are most useful when you need to know whether something is included in the collection or not.
</p></li>
</ul>

<p class="calibre1"><em class="calibre5">Dictionaries:</em>
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Are unordered collections of key-value pairs.
</p></li>

<li class="calibre4">
<p class="calibre1">The <em class="calibre5">keys</em> are all of the same type, and the <em class="calibre5">values</em> are all of the same type.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">subscripting</em> to get values and to add, update or remove pairs.
</p></li>

<li class="calibre4">
<p class="calibre1">If a key is not in a dictionary, lookup returns <code class="calibre9">nil</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">The key of a dictionary must be a type that conforms to the <code class="calibre9"><em class="calibre13">Hashable</em></code> protocol.
</p></li>

<li class="calibre4">
<p class="calibre1">Basic Swift types such as <code class="calibre9">String</code>, <code class="calibre9">Int</code>, <code class="calibre9">Double</code> are <code class="calibre9">Hashable</code> out of the box.
</p></li>
</ul>

<p class="calibre1"><em class="calibre5">Arrays</em>:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Are ordered collections of values of the same type.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">subscripting</em>, or one of the many properties and methods, to access and update elements.
</p></li>

<li class="calibre4">
<p class="calibre1">Be wary of accessing an index that’s out of bounds.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-5">


<h1 class="segment-chapter">Chapter 8: Collection Iteration With Closures</h1>

<p class="calibre1">Earlier, you learned about functions. But Swift has another object you can use to break up code into reusable chunks: a <em class="calibre5">closure</em>. They become instrumental when dealing with collections.
</p>
<p class="calibre1">A closure is simply a function with no name; you can assign it to a variable and pass it around like any other value. This chapter shows you how convenient and valuable closures can be.
</p>
<h2 class="segment-chapter1">Closure basics</h2>

<p class="calibre1">Closures are so named because they can “close over” the variables and constants within the closure’s scope. This simply means that a closure can access the values of any variable or constant from the surrounding context. Variables and constants used within the closure body are said to have been <em class="calibre5">captured</em> by the closure.
</p>
<p class="calibre1">You may ask, “If closures are functions without names, then how do you use them?” To use a closure, you first have to assign it to a variable or constant.
</p>
<p class="calibre1">Here’s a declaration of a variable that can hold a closure:
</p><pre class="code-block"><span class="hljs-keyword">var</span> multiplyClosure: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span></pre>
<p class="calibre1"><code class="calibre9">multiplyClosure</code> takes two <code class="calibre9">Int</code> values and returns an <code class="calibre9">Int</code>. Notice that this is the same as a variable declaration for a function. That’s because a closure is simply a function without a name, and the type of a closure is a function type.
</p>
<p class="calibre1">For the declaration to compile in a playground, you need to provide an initial definition like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> multiplyClosure <span class="hljs-operator">=</span> { (a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">return</span> a <span class="hljs-operator">*</span> b
}</pre>
<p class="calibre1">This looks similar to a function declaration, but there’s a subtle difference. There’s the same parameter list, <code class="calibre9">-&gt;</code> symbol and return type. But with closures, these elements appear inside braces, and there is an <code class="calibre9">in</code> keyword after the return type.
</p>
<p class="calibre1">With your closure variable defined, you can use it just as if it were a function, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> multiplyClosure(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</pre>
<p class="calibre1">As you’d expect, <code class="calibre9">result</code> equals 8. Again, though, there’s a subtle difference.
</p>
<p class="calibre1">Notice how the closure has no external names for the parameters. You can’t set them like you can with functions.
</p>
<h3 class="segment-title2">Shorthand syntax</h3>

<p class="calibre1">There are many ways to shorten the syntax of a closure. First, just like normal functions, if the closure consists of a single return statement, you can leave out the <code class="calibre9">return</code> keyword, like so:
</p><pre class="code-block">multiplyClosure <span class="hljs-operator">=</span> { (a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span>
  a <span class="hljs-operator">*</span> b
}</pre>
<p class="calibre1">Next, you can use Swift’s type inference to shorten the syntax even more by removing the type information:
</p><pre class="code-block">multiplyClosure <span class="hljs-operator">=</span> { (a, b) <span class="hljs-keyword">in</span>
  a <span class="hljs-operator">*</span> b
}</pre>
<p class="calibre1">Remember, you already declared <code class="calibre9">multiplyClosure</code> as a closure taking two <code class="calibre9">Int</code>s and returning an <code class="calibre9">Int</code>, so you can let Swift infer these types for you.
</p>
<p class="calibre1">And finally, you can even omit the parameter list if you want. Swift lets you refer to each parameter by number, starting at zero, like so:
</p><pre class="code-block">multiplyClosure <span class="hljs-operator">=</span> {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">*</span> <span class="hljs-variable">$1</span>
}</pre>
<p class="calibre1">The parameter list, return type and <code class="calibre9">in</code> keyword are all gone, and your new closure declaration is much shorter than the original. Numbered parameters like this should only be used when the closure is short and sweet, like the one above.
</p>
<p class="calibre1">If the parameter list is longer, it can be confusing to remember what each numbered parameter refers to. In these cases, you should use the named syntax.
</p>
<p class="calibre1">Consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">operateOnNumbers</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Int</span>,
                      <span class="hljs-built_in">operation</span>: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> operation(a, b)
  <span class="hljs-built_in">print</span>(result)
  <span class="hljs-keyword">return</span> result
}</pre>
<p class="calibre1">This declares a function named <code class="calibre9">operateOnNumbers</code>, which takes <code class="calibre9">Int</code> values as its first two parameters. The third parameter is named <code class="calibre9">operation</code> and is of a function type. <code class="calibre9">operateOnNumbers</code> itself returns an <code class="calibre9">Int</code>.
</p>
<p class="calibre1">You can then use <code class="calibre9">operateOnNumbers</code> with a closure, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> addClosure <span class="hljs-operator">=</span> { (a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span>) <span class="hljs-keyword">in</span>
  a <span class="hljs-operator">+</span> b
}
operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, operation: addClosure)</pre>
<p class="calibre1">Remember, closures are simply functions without names. So you shouldn’t be surprised to learn that you can also pass in a function as the third parameter of <code class="calibre9">operateOnNumbers</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">addFunction</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">a</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">b</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  a <span class="hljs-operator">+</span> b
}
operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, operation: addFunction)</pre>
<p class="calibre1"><code class="calibre9">operateOnNumbers</code> is called the same way, whether the <code class="calibre9">operation</code> is a function or a closure.
</p>
<p class="calibre1">The power of the closure syntax comes in handy again. You can define the closure inline with the <code class="calibre9">operateOnNumbers</code> function call, like this:
</p><pre class="code-block">operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, operation: { (a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">return</span> a <span class="hljs-operator">+</span> b
})</pre>
<p class="calibre1">There’s no need to define the closure and assign it to a local variable or constant. You can simply declare the closure right where you pass it into the function as a parameter!
</p>
<p class="calibre1">But recall that you can simplify the closure syntax to remove a lot of the boilerplate code. You can therefore reduce the above to the following:
</p><pre class="code-block">operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, operation: { <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> <span class="hljs-variable">$1</span> })</pre>
<p class="calibre1">You can even go a step further. The + operator is just a function that takes two arguments and returns one result so that you can write:
</p><pre class="code-block">operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, operation: <span class="hljs-operator">+</span>)</pre>
<p class="calibre1">There’s one more way you can simplify the syntax, but it can only be done when the closure is the final parameter passed to a function. In this case, you can move the closure outside of the function call:
</p><pre class="code-block">operateOnNumbers(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> <span class="hljs-variable">$1</span>
}</pre>
<p class="calibre1">This may look strange, but it’s just the same as the previous code snippet, except you’ve removed the <code class="calibre9">operation</code> label and pulled the braces outside the function call parameter list. This is called <em class="calibre5">trailing closure syntax</em>.
</p>
<h3 class="segment-title2">Multiple trailing closures syntax</h3>

<p class="calibre1">If a function has multiple closure for inputs, you can call it in a special shorthand way.  Suppose you have this function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">sequenced</span>(<span class="hljs-built_in">first</span>: ()-&gt;<span class="hljs-built_in">Void</span>, <span class="hljs-built_in">second</span>: ()-&gt;<span class="hljs-built_in">Void</span>) {
  first()
  second()
}</pre>
<p class="calibre1">Swift lets you call it like so:
</p><pre class="code-block">sequenced {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, "</span>, terminator: <span class="hljs-string">""</span>)
} second: {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"world."</span>)
}</pre>
<p class="calibre1">This will print out “Hello, world.”
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you ever forget how to call a function with a closure, Xcode can help you. Type in the method’s name (or code complete it) and press the return key twice. The code completion function will fill out trailing closure syntax for you.
</p></div>

<h3 class="segment-title2">Closures with no return value</h3>

<p class="calibre1">Until now, all the closures you’ve seen have taken one or more parameters and have returned values. But just like functions, closures aren’t required to do these things. Here’s how you declare a closure that takes no parameters and returns nothing:
</p><pre class="code-block"><span class="hljs-keyword">let</span> voidClosure: () -&gt; <span class="hljs-built_in">Void</span> <span class="hljs-operator">=</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Swift Apprentice is awesome!"</span>)
}
voidClosure()</pre>
<p class="calibre1">The closure’s type is <code class="calibre9">() -&gt; Void</code>. The empty parentheses denote there are no parameters. You must declare a return type, so Swift knows you’re declaring a closure. This is where <code class="calibre9">Void</code> comes in handy, and it means exactly what its name suggests: the closure returns nothing.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: <code class="calibre9">Void</code> is actually just a typealias for <code class="calibre9">()</code>. This means you could have written <code class="calibre9">() -&gt; Void</code> as <code class="calibre9">() -&gt; ()</code>. A function’s parameter list however must always be surrounded by parentheses, so <code class="calibre9">Void -&gt; ()</code> or <code class="calibre9">Void -&gt; Void</code> are invalid.
</p></div>

<h3 class="segment-title2">Capturing from the enclosing scope</h3>

<p class="calibre1">Finally, let’s return to the defining characteristic of a closure: it can access the variables and constants within its scope.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Recall that scope defines the range in which an entity (variable, constant, etc.) is accessible. You saw a new scope introduced with <code class="calibre9">if</code>-statements. Closures also introduce a new scope and inherit all entities visible to the scope in which it is defined.
</p></div>

<p class="calibre1">For example, take the following closure:
</p><pre class="code-block"><span class="hljs-keyword">var</span> counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">let</span> incrementCounter <span class="hljs-operator">=</span> {
  counter <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
}</pre>
<p class="calibre1"><code class="calibre9">incrementCounter</code> is relatively simple: It increments the <code class="calibre9">counter</code> variable. The <code class="calibre9">counter</code> variable is defined outside of the closure. The closure can access the variable because the closure is defined in the same scope as the variable. The closure is said to <em class="calibre5">capture</em> the <code class="calibre9">counter</code> variable. Any changes it makes to the variable are visible both inside and outside the closure.
</p>
<p class="calibre1">Let’s say you call the closure five times, like so:
</p><pre class="code-block">incrementCounter()
incrementCounter()
incrementCounter()
incrementCounter()
incrementCounter()</pre>
<p class="calibre1">After these five calls, <code class="calibre9">counter</code> will equal 5.
</p>
<p class="calibre1">The fact that closures can be used to capture variables from the enclosing scope can be extremely useful. For example, you could write the following function:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">countingClosure</span>() -&gt; () -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">var</span> counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> incrementCounter: () -&gt; <span class="hljs-built_in">Int</span> <span class="hljs-operator">=</span> {
    counter <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> counter
  }
  <span class="hljs-keyword">return</span> incrementCounter
}</pre>
<p class="calibre1">This function takes no parameters and returns a closure. The closure it returns takes no parameters and returns an <code class="calibre9">Int</code>.
</p>
<p class="calibre1">The closure returned from this function will increment its internal counter each time it is called. Each time you call this function, you get a different counter.
</p>
<p class="calibre1">For example, this could be used like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> counter1 <span class="hljs-operator">=</span> countingClosure()
<span class="hljs-keyword">let</span> counter2 <span class="hljs-operator">=</span> countingClosure()

counter1() <span class="hljs-comment">// 1</span>
counter2() <span class="hljs-comment">// 1</span>
counter1() <span class="hljs-comment">// 2</span>
counter1() <span class="hljs-comment">// 3</span>
counter2() <span class="hljs-comment">// 2</span></pre>
<p class="calibre1">The two counters created by the function are mutually exclusive and count independently. Neat!
</p>
<h2 class="segment-chapter1">Custom sorting with closures</h2>

<p class="calibre1">Closures come in handy when you start looking deeper at collections. In Chapter 7, “Arrays, Dictionaries &amp; Sets”, you used array’s <code class="calibre9">sort</code> method to sort an array. By specifying a closure, you can customize how things are sorted. You call <code class="calibre9">sorted()</code> to get a sorted version of the array as so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> names <span class="hljs-operator">=</span> [<span class="hljs-string">"ZZZZZZ"</span>, <span class="hljs-string">"BB"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-string">"CCCC"</span>, <span class="hljs-string">"EEEEE"</span>]
names.sorted()
<span class="hljs-comment">// ["A", "BB", "CCCC", "EEEEE", "ZZZZZZ"]</span></pre>
<p class="calibre1">By specifying a custom closure, you can change the details of how the array is sorted. Specify a trailing closure like so:
</p><pre class="code-block">names.sorted {
  <span class="hljs-variable">$0</span>.count <span class="hljs-operator">&gt;</span> <span class="hljs-variable">$1</span>.count
}
<span class="hljs-comment">// ["ZZZZZZ", "EEEEE", "CCCC", "BB", "A"]</span></pre>
<p class="calibre1">Now the array is sorted by the length of the string, with longer strings coming first.
</p>
<h2 class="segment-chapter1">Iterating over collections with closures</h2>

<p class="calibre1">In Swift, collections implement some convenient features often associated with <em class="calibre5">functional programming</em>. These features come in the shape of functions that you can apply to a collection to operate on it.
</p>
<p class="calibre1">Operations include things like transforming each element or filtering out certain elements.
</p>
<p class="calibre1">All of these functions make use of closures, as you will see now.
</p>
<p class="calibre1">The first of these functions lets you loop over the elements in a collection and perform an operation like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> values <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
values.forEach { 
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-variable">$0</span>)</span>: <span class="hljs-subst">\(<span class="hljs-variable">$0</span><span class="hljs-operator">*</span><span class="hljs-variable">$0</span>)</span>"</span>)
}</pre>
<p class="calibre1">This loops through each item in the collection printing the value and its square.
</p>
<p class="calibre1">Another function allows you to filter out certain elements, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> prices <span class="hljs-operator">=</span> [<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4.99</span>, <span class="hljs-number">2.30</span>, <span class="hljs-number">8.19</span>]

<span class="hljs-keyword">let</span> largePrices <span class="hljs-operator">=</span> prices.filter {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>
}</pre>
<p class="calibre1">Here, you create an array of <code class="calibre9">Double</code> to represent the prices of items in a shop. To filter out prices greater than $5, you use the <code class="calibre9">filter</code> function. This function looks like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">filter</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">isIncluded</span>: (<span class="hljs-built_in">Element</span>) -&gt; <span class="hljs-built_in">Bool</span>) -&gt; [<span class="hljs-built_in">Element</span>]</pre>
<p class="calibre1">This means that <code class="calibre9">filter</code> takes a single parameter, a closure (or function) that takes an <code class="calibre9">Element</code> and returns a <code class="calibre9">Bool</code>. The <code class="calibre9">filter</code> function then returns an array of <code class="calibre9">Element</code>s. In this context, <code class="calibre9">Element</code> refers to the type of items in the array. In the example above, <code class="calibre9">Double</code>s.
</p>
<p class="calibre1">The closure’s job is to return <code class="calibre9">true</code> or <code class="calibre9">false</code> depending on whether or not the value should be kept or not. The array returned from <code class="calibre9">filter</code> will contain all elements for which the closure returned <code class="calibre9">true</code>.
</p>
<p class="calibre1">In your example, <code class="calibre9">largePrices</code> will contain:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">(10, 8.19)</code>
</p></div>

<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The array returned from <code class="calibre9">filter</code> (and all of these functions) is a new array. The original is not modified at all.
</p></div>

<p class="calibre1">If you’re only interested in the first element that satisfies a certain condition, you can use <code class="calibre9">first(where:)</code>. For example, using a trailing closure:
</p><pre class="code-block"><span class="hljs-keyword">let</span> largePrice <span class="hljs-operator">=</span> prices.first {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>
}</pre>
<p class="calibre1">In this case, <code class="calibre9">largePrice</code> would be 10.
</p>
<p class="calibre1">However, there is more!
</p>
<p class="calibre1">Imagine having a sale and wanting to discount all items to 90% of their original price. There’s a handy function named <code class="calibre9">map</code> that can achieve this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> salePrices <span class="hljs-operator">=</span> prices.map {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">*</span> <span class="hljs-number">0.9</span>
}</pre>
<p class="calibre1">The <code class="calibre9">map</code> function will take a closure, execute it on each item in the array and return a new array containing each result with the order maintained. In this case, <code class="calibre9">salePrices</code> will contain:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">[1.35, 9, 4.491, 2.07, 7.371]</code>
</p></div>

<p class="calibre1">The <code class="calibre9">map</code> function can also be used to change the type. You can do that like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> userInput <span class="hljs-operator">=</span> [<span class="hljs-string">"0"</span>, <span class="hljs-string">"11"</span>, <span class="hljs-string">"haha"</span>, <span class="hljs-string">"42"</span>]

<span class="hljs-keyword">let</span> numbers1 <span class="hljs-operator">=</span> userInput.map {
  <span class="hljs-built_in">Int</span>(<span class="hljs-variable">$0</span>)
}</pre>
<p class="calibre1">This takes some strings that the user input and turns them into an array of <code class="calibre9">Int?</code>. They need to be optional because the conversion from <code class="calibre9">String</code> to <code class="calibre9">Int</code> might fail.
</p>
<p class="calibre1">If you want to filter out the invalid (missing) values, you can use <code class="calibre9">compactMap</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> numbers2 <span class="hljs-operator">=</span> userInput.compactMap {
  <span class="hljs-built_in">Int</span>(<span class="hljs-variable">$0</span>)
}</pre>
<p class="calibre1">This is almost the same as <code class="calibre9">map</code> except it creates an array of <code class="calibre9">Int</code> and tosses out the missing values.
</p>
<p class="calibre1">There’s also a <code class="calibre9">flatMap</code> operation which has a similar name to <code class="calibre9">map</code> and <code class="calibre9">compactMap</code>, however does something a little different. Let’s see it in action:
</p><pre class="code-block"><span class="hljs-keyword">let</span> userInputNested <span class="hljs-operator">=</span> [[<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>], [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>], [<span class="hljs-string">"🐕"</span>]]
<span class="hljs-keyword">let</span> allUserInput <span class="hljs-operator">=</span> userInputNested.flatMap {
  <span class="hljs-variable">$0</span>
}</pre>
<p class="calibre1">You will notice that <code class="calibre9">allUserInput</code> is <code class="calibre9">["0", "1", "a", "b", "c", "🐕"]</code>.
</p>
<p class="calibre1">Swift expects the return value from the closure given to <code class="calibre9">flatMap</code> to be a collection itself. What it does then takes all these collections and concatenates them together. So, in this case, it’s done the trick of unwrapping those inner collections. We end up with a collection containing all the items from the first inner collection, then all the items from the second inner collection, and so on.
</p>
<p class="calibre1">Another handy function is <code class="calibre9">reduce</code>. This function takes an initial value and a closure that gets called for each element in the array. Each time the closure is called, it gets two inputs: the current value (that starts as the initial value) and an array element. The closure returns what will be the next current value.  This process might sound convoluted, but an example will make it clear.
</p>
<p class="calibre1">For example, this could be used with the <code class="calibre9">prices</code> array to calculate the total, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> prices.reduce(<span class="hljs-number">0</span>) {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> <span class="hljs-variable">$1</span>
}</pre>
<p class="calibre1">The initial value representing a running total is 0. The closure gets called for each element and returns the running total plus the current element. The returned value is the new running total.  The final result is the total of all the values in the array. In this case, <code class="calibre9">sum</code> will be:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">26.98</code>
</p></div>

<p class="calibre1">Now that you’ve seen <code class="calibre9">filter</code>, <code class="calibre9">map</code> and <code class="calibre9">reduce</code>, hopefully, you realize how powerful these functions can be, thanks to the syntax of closures. In just a few lines of code, you have calculated quite complex values from the collection.
</p>
<p class="calibre1">These functions can also be used with dictionaries. Imagine you represent the stock in your shop by a dictionary mapping the price to the number of items at that price. You could use that to calculate the total value of your stock like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> stock <span class="hljs-operator">=</span> [<span class="hljs-number">1.5</span>: <span class="hljs-number">5</span>, <span class="hljs-number">10</span>: <span class="hljs-number">2</span>, <span class="hljs-number">4.99</span>: <span class="hljs-number">20</span>, <span class="hljs-number">2.30</span>: <span class="hljs-number">5</span>, <span class="hljs-number">8.19</span>: <span class="hljs-number">30</span>]
<span class="hljs-keyword">let</span> stockSum <span class="hljs-operator">=</span> stock.reduce(<span class="hljs-number">0</span>) {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">+</span> <span class="hljs-variable">$1</span>.key <span class="hljs-operator">*</span> <span class="hljs-built_in">Double</span>(<span class="hljs-variable">$1</span>.value)
}</pre>
<p class="calibre1">The second parameter to the <code class="calibre9">reduce</code> function is a named tuple containing the <code class="calibre9">key</code> and <code class="calibre9">value</code> from the dictionary elements. A type conversion of the value is required to perform the calculation.
</p>
<p class="calibre1">Here, the result is:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">384.5</code>
</p></div>

<p class="calibre1">There’s another form of <code class="calibre9">reduce</code> named <code class="calibre9">reduce(into:_:)</code>. You’d use it when the result you’re reducing a collection into is an array or dictionary, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> farmAnimals <span class="hljs-operator">=</span> [<span class="hljs-string">"🐎"</span>: <span class="hljs-number">5</span>, <span class="hljs-string">"🐄"</span>: <span class="hljs-number">10</span>, <span class="hljs-string">"🐑"</span>: <span class="hljs-number">50</span>, <span class="hljs-string">"🐶"</span>: <span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> allAnimals <span class="hljs-operator">=</span> farmAnimals.reduce(into: []) {
  (result, this: (key: <span class="hljs-built_in">String</span>, value: <span class="hljs-built_in">Int</span>)) <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> <span class="hljs-operator">..&lt;</span> this.value {
    result.append(this.key)
  }
}</pre>
<p class="calibre1">It works the same way as the other version, except that you don’t return something from the closure. Instead, each iteration gives you a mutable value. In this way, there is only ever one array in this example created and appended to, making  <code class="calibre9">reduce(into:_:)</code> more efficient in some cases.
</p>
<p class="calibre1">Should you need to chop up an array, there are a few more functions that can be helpful. The first function is <code class="calibre9">dropFirst</code>, which works like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> removeFirst <span class="hljs-operator">=</span> prices.dropFirst()
<span class="hljs-keyword">let</span> removeFirstTwo <span class="hljs-operator">=</span> prices.dropFirst(<span class="hljs-number">2</span>)</pre>
<p class="calibre1">The <code class="calibre9">dropFirst</code> function takes a single parameter that defaults to 1 and returns an array with the required number of elements removed from the front. Results are as follows:
</p><pre class="code-block">removeFirst <span class="hljs-operator">=</span> [<span class="hljs-number">10</span>, <span class="hljs-number">4.99</span>, <span class="hljs-number">2.30</span>, <span class="hljs-number">8.19</span>]
removeFirstTwo <span class="hljs-operator">=</span> [<span class="hljs-number">4.99</span>, <span class="hljs-number">2.30</span>, <span class="hljs-number">8.19</span>]</pre>
<p class="calibre1">Just like <code class="calibre9">dropFirst</code>, there also exists <code class="calibre9">dropLast</code> which removes elements from the end of the array. It works like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> removeLast <span class="hljs-operator">=</span> prices.dropLast()
<span class="hljs-keyword">let</span> removeLastTwo <span class="hljs-operator">=</span> prices.dropLast(<span class="hljs-number">2</span>)</pre>
<p class="calibre1">The results of these are as you would expect:
</p><pre class="code-block">removeLast <span class="hljs-operator">=</span> [<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4.99</span>, <span class="hljs-number">2.30</span>]
removeLastTwo <span class="hljs-operator">=</span> [<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4.99</span>]</pre>
<p class="calibre1">You can select just the first or last elements of an array as shown below:
</p><pre class="code-block"><span class="hljs-keyword">let</span> firstTwo <span class="hljs-operator">=</span> prices.prefix(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> lastTwo <span class="hljs-operator">=</span> prices.suffix(<span class="hljs-number">2</span>)</pre>
<p class="calibre1">Here, <code class="calibre9">prefix</code> returns the required number of elements from the front of the array, and <code class="calibre9">suffix</code> returns the required number of elements from the back of the array. The results of this function are:
</p><pre class="code-block">firstTwo <span class="hljs-operator">=</span> [<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>]
lastTwo <span class="hljs-operator">=</span> [<span class="hljs-number">2.30</span>, <span class="hljs-number">8.19</span>]</pre>
<p class="calibre1">And finally, you can remove all elements in a collection by using <code class="calibre9">removeAll()</code> qualified by a closure, or unconditionally:
</p><pre class="code-block">prices.removeAll() { <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> } <span class="hljs-comment">// prices is now [1.5]</span>
prices.removeAll() <span class="hljs-comment">// prices is now an empty array</span></pre>
<h3 class="segment-title2">Lazy collections</h3>

<p class="calibre1">Sometimes you can have a huge collection, or perhaps even infinite, but you want to be able to access it somehow. A concrete example of this would be all of the prime numbers. That is an infinite set of numbers. So how can you work with that set? Enter the <em class="calibre5">lazy collection</em>. Consider that you might want to calculate the first ten prime numbers. To do this in an imperative way you might do something like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isPrime</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-keyword">if</span> number <span class="hljs-operator">==</span> <span class="hljs-number">1</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> }
  <span class="hljs-keyword">if</span> number <span class="hljs-operator">==</span> <span class="hljs-number">2</span> <span class="hljs-operator">||</span> number <span class="hljs-operator">==</span> <span class="hljs-number">3</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span> }

  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">2</span><span class="hljs-operator">...</span><span class="hljs-built_in">Int</span>(<span class="hljs-built_in">Double</span>(number).squareRoot()) {
    <span class="hljs-keyword">if</span> number <span class="hljs-operator">%</span> i <span class="hljs-operator">==</span> <span class="hljs-number">0</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
}

<span class="hljs-keyword">var</span> primes: [<span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> []
<span class="hljs-keyword">var</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> primes.count <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> {
  <span class="hljs-keyword">if</span> isPrime(i) {
    primes.append(i)
  }
  i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
}
primes.forEach { <span class="hljs-built_in">print</span>(<span class="hljs-variable">$0</span>) }</pre>
<p class="calibre1">This creates a function that checks if a number is prime or not. Then it uses that to generate an array of the first ten prime numbers.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> The function to calculate if this is a prime is not a very good one! This is a deep topic and far beyond the scope of this chapter. If you’re curious, then I suggest starting with reading about the Sieve of Eratosthenes.
</p></div>

<p class="calibre1">This works, but functional is better, as you saw earlier in the chapter. The functional way to get the first ten prime numbers would be to have a sequence of <i class="calibre2">all</i> the prime numbers and then use <code class="calibre9">prefix()</code> to get the first ten. However, how can you have a sequence of infinite length and get the <code class="calibre9">prefix()</code> of that? That’s where you can use the <code class="calibre9">lazy</code> operation to tell Swift to create the collection on-demand when it’s needed.
</p>
<p class="calibre1">Let’s see it in action. You could rewrite the code above instead like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> primes <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">...</span>).lazy
  .filter { isPrime(<span class="hljs-variable">$0</span>) }
  .prefix(<span class="hljs-number">10</span>)
primes.forEach { <span class="hljs-built_in">print</span>(<span class="hljs-variable">$0</span>) }</pre>
<p class="calibre1">Notice that you start with the completely open-ended collection <code class="calibre9">1...</code> which means 1 until, well, infinity (or rather the maximum integer that the <code class="calibre9">Int</code> type can hold!). Then you use <code class="calibre9">lazy</code> to tell Swift that you want this to be a lazy collection. Then you use <code class="calibre9">filter()</code> and <code class="calibre9">prefix()</code> to filter out the primes and choose the first ten.
</p>
<p class="calibre1">At that point, the sequence has not been generated at all. No primes have been checked. Only on the second statement, the <code class="calibre9">primes.forEach</code> that the sequence is evaluated and the first ten prime numbers are printed out. Neat! :]
</p>
<p class="calibre1">Lazy collections are extremely useful when the collection is huge (even infinite) or expensive to generate. It saves the computation until precisely when it is needed.
</p>
<p class="calibre1">That wraps up collection iteration with closures!
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a constant array called <code class="calibre9">names</code> that contains some names as strings. Any names will do &mdash; make sure there are more than three. Now use <code class="calibre9">reduce</code> to create a string that is the concatenation of each name in the array.
</p></li>
</ol>

<ol start="2" class="calibre11">
<li class="calibre4">
<p class="calibre1">Using the same <code class="calibre9">names</code> array, first filter the array to contain only names longer than four characters, and then create the same concatenation of names as in the above exercise. (Hint: You can chain these operations together.)
</p></li>

<li class="calibre4">
<p class="calibre1">Create a constant dictionary called <code class="calibre9">namesAndAges</code> containing some names as strings mapped to ages as integers. Now use <code class="calibre9">filter</code> to create a dictionary containing only people under the age of 18.
</p></li>

<li class="calibre4">
<p class="calibre1">Using the same <code class="calibre9">namesAndAges</code> dictionary, filter out the adults (those 18 or older) and then use <code class="calibre9">map</code> to convert to an array containing just the names (i.e., drop the ages).
</p></li>
</ol>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of collection iterations with closures. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Repeating yourself</h3>

<p class="calibre1">Your first challenge is to write a function that will run a given closure a given number of times.
</p>
<p class="calibre1">Declare the function like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">repeatTask</span>(<span class="hljs-built_in">times</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">task</span>: () -&gt; <span class="hljs-built_in">Void</span>)</pre>
<p class="calibre1">The function should run the <code class="calibre9">task</code> closure, <code class="calibre9">times</code> number of times. Use this function to print <code class="calibre9">"Swift Apprentice is a great book!"</code> 10 times.
</p>
<h3 class="segment-title2">Challenge 2: Closure sums</h3>

<p class="calibre1">In this challenge, you will write a function that you can reuse to create different mathematical sums.
</p>
<p class="calibre1">Declare the function like so:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">mathSum</span>(<span class="hljs-built_in">length</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">series</span>: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span></pre>
<p class="calibre1">The first parameter, <code class="calibre9">length</code>, defines the number of values to sum. The second parameter, <code class="calibre9">series</code>, is a closure that can be used to generate a series of values. <code class="calibre9">series</code> should have a parameter that is the position of the value in the series and return the value at that position.
</p>
<p class="calibre1"><code class="calibre9">mathSum</code> should calculate <code class="calibre9">length</code> number of values, starting at position 1, and return their sum.
</p>
<p class="calibre1">Use the function to find the sum of the first 10 square numbers, which equals 385. Then use the function to find the sum of the first 10 Fibonacci numbers, which equals 143. For the Fibonacci numbers, you can use the function you wrote in Chapter 5, “Functions” &mdash; or grab it from the solutions if you’re unsure your solution is correct.
</p>
<h3 class="segment-title2">Challenge 3: Functional ratings</h3>

<p class="calibre1">In this final challenge, you will have a list of app names with associated ratings they’ve been given. Note &mdash; these are all fictional apps! Create the data dictionary like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> appRatings <span class="hljs-operator">=</span> [
  <span class="hljs-string">"Calendar Pro"</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>],
  <span class="hljs-string">"The Messenger"</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  <span class="hljs-string">"Socialise"</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]
]</pre>
<p class="calibre1">First, create a dictionary called <code class="calibre9">averageRatings</code> that will contain a mapping of app names to average ratings. Use <code class="calibre9">forEach</code> to iterate through the <code class="calibre9">appRatings</code> dictionary, then use <code class="calibre9">reduce</code> to calculate the average rating.  Store this rating in the <code class="calibre9">averageRatings</code> dictionary. Finally, use <code class="calibre9">filter</code> and <code class="calibre9">map</code> chained together to get a list of the app names whose average rating is greater than 3.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Closures</em> are functions without names. They can be assigned to variables and passed as parameters to functions.
</p></li>

<li class="calibre4">
<p class="calibre1">Closures have <em class="calibre5">shorthand syntax</em> that makes them a lot easier to use than other functions.
</p></li>

<li class="calibre4">
<p class="calibre1">A closure can <em class="calibre5">capture</em> the variables and constants from its surrounding context.
</p></li>

<li class="calibre4">
<p class="calibre1">A closure can be used to direct how a collection is sorted.
</p></li>

<li class="calibre4">
<p class="calibre1">A handy set of functions exists on collections that you can use to iterate over a collection and transform it. Transforms comprise mapping each element to a new value, filtering out certain values and reducing the collection down to a single value.
</p></li>

<li class="calibre4">
<p class="calibre1">Lazy collections can be used to evaluate a collection only when strictly needed, which means you can easily work with large, expensive or potentially infinite collections.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-8">


<h1 class="segment-chapter">Chapter 9: Strings</h1>

<p class="calibre1">So far, you have briefly seen what the type <code class="calibre9">String</code> has to offer for representing text. Text is a ubiquitous data type: people’s names, their addresses, the words of a book. All of these are examples of text that an app might need to handle. It’s worth having a deeper understanding of how <code class="calibre9">String</code> works and what it can do.
</p>
<p class="calibre1">This chapter deepens your knowledge of strings in general and how strings work in Swift. Swift is one of the few languages that handle Unicode characters correctly while maintaining maximum predictable performance.
</p>
<h2 class="segment-chapter1">Strings as collections</h2>

<p class="calibre1">In Chapter 2, “Types &amp; Operations”, you learned what a string is and what character sets and code points are. To recap, they define the mapping numbers to the character it represents. And now it’s time to look deeper into the <code class="calibre9">String</code> type.
</p>
<p class="calibre1">It’s pretty easy to conceptualize a string as a collection of characters. Because strings are collections, you can do things like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> string <span class="hljs-operator">=</span> <span class="hljs-string">"Matt"</span>
<span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> string {
  <span class="hljs-built_in">print</span>(char)
}</pre>
<p class="calibre1">This will print out every character of <code class="calibre9">Matt</code> individually. Simple, eh?
</p>
<p class="calibre1">You can also use other collection operations, such as:
</p><pre class="code-block"><span class="hljs-keyword">let</span> stringLength <span class="hljs-operator">=</span> string.count</pre>
<p class="calibre1">This will give you the length of the string.
</p>
<p class="calibre1">Now imagine you want to get the fourth character in the string. You may think to do something like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fourthChar <span class="hljs-operator">=</span> string[<span class="hljs-number">3</span>]</pre>
<p class="calibre1">However, if you did this, you would receive the following error message:
</p><pre class="code-block">'subscript' is unavailable: cannot subscript String with an Int, see the documentation comment for discussion</pre>
<p class="calibre1">Why is that? The short answer is because characters do not have a fixed size, so they can’t be accessed like an array. Why not?  It’s time to take a detour further into how strings work by introducing what a <em class="calibre5">grapheme cluster</em> is.
</p>
<h3 class="segment-title2">Grapheme clusters</h3>

<p class="calibre1">As you know, a string is made up of a collection of Unicode characters. Until now, you have considered one code point to precisely equal one character and vice versa. However, the term “character” is relatively loose.
</p>
<p class="calibre1">It may come as a surprise, but there are two ways to represent some characters. One example is the <code class="calibre9">é</code> in <code class="calibre9">café</code>, an <code class="calibre9">e</code> with an acute accent. You can represent this character with either one or two characters.
</p>
<p class="calibre1">The single character to represent this is code point 233. The two-character case is an <code class="calibre9">e</code> on its own, followed by an acute accent <em class="calibre5">combining character</em>, a special character that modifies the previous character.
</p>
<p class="calibre1">So you can represent the <code class="calibre9">e</code> with an acute accent by either of these means:
</p><div class="image2"><img src="images/000039.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The combination of these two characters in the second diagram forms what is known as a <em class="calibre5">grapheme cluster</em> defined by the Unicode standard. When you think of a character, you’re probably thinking of a grapheme cluster. Grapheme clusters are represented by the Swift type <code class="calibre9">Character</code>.
</p>
<p class="calibre1">Other examples of combining characters are the special characters used to change the skin color of certain emojis.
</p><div class="image2"><img src="images/000052.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Here, the thumbs-up emoji is followed by a skin tone combining character. On platforms that support it, including iOS and macOS, the rendered emoji is a single thumbs-up character with the skin tone applied.
</p>
<p class="calibre1">Let’s now take a look at what this means for strings when they are used as collections. Consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> cafeNormal <span class="hljs-operator">=</span> <span class="hljs-string">"café"</span>
<span class="hljs-keyword">let</span> cafeCombining <span class="hljs-operator">=</span> <span class="hljs-string">"cafe<span class="hljs-subst">\u{0301}</span>"</span>

cafeNormal.count     <span class="hljs-comment">// 4</span>
cafeCombining.count  <span class="hljs-comment">// 4</span></pre>
<p class="calibre1">Both of these counts turn out to equal four because Swift considers a string as a collection of grapheme clusters. You may also notice that evaluating the length of a string takes linear time because you need to go through all characters to determine how many grapheme clusters there are. One can simply not know, just from looking, how big the string is in memory.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The backslash character, <code class="calibre9">\</code>, is the <em class="calibre5">escape character</em>. It is used here followed by a <code class="calibre9">u</code> to indicate that what follows the <code class="calibre9">\u</code> is a Unicode code point in hexadecimal in braces. In the code above, the acute accent combining character is written using this syntax. You can use this shorthand to write any Unicode character. I had to use it here for the combining character because there’s no way to type this character on my keyboard!
</p></div>

<p class="calibre1">However, you can access the underlying Unicode code points in the string via the <code class="calibre9">unicodeScalars</code> <em class="calibre5">view</em>. This view is also a collection itself. So, you can do the following:
</p><pre class="code-block">cafeNormal.unicodeScalars.count     <span class="hljs-comment">// 4</span>
cafeCombining.unicodeScalars.count  <span class="hljs-comment">// 5</span></pre>
<p class="calibre1">In this case, you’re seeing the difference in the counts as you’d expect.
</p>
<p class="calibre1">You can iterate through this Unicode scalars view like so:
</p><pre class="code-block"><span class="hljs-keyword">for</span> codePoint <span class="hljs-keyword">in</span> cafeCombining.unicodeScalars {
  <span class="hljs-built_in">print</span>(codePoint.value)
}</pre>
<p class="calibre1">This will print the following list of numbers, as expected:
</p><pre class="code-block">99
97
102
101
769</pre>
<h3 class="segment-title2">Indexing strings</h3>

<p class="calibre1">As you saw earlier, indexing into a string to get a certain character (err, I mean grapheme cluster) is not as simple as using an integer subscript. Swift wants you to be aware of what’s going on under the hood, so it requires syntax that is a bit more verbose.
</p>
<p class="calibre1">You have to operate on the specific string index type to index into strings. For example, you obtain the index that represents the start of the string like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> firstIndex <span class="hljs-operator">=</span> cafeCombining.startIndex</pre>
<p class="calibre1">If you option-click on <code class="calibre9">firstIndex</code> in a playground, you’ll notice that it is of type <code class="calibre9">String.Index</code> and not an integer.
</p>
<p class="calibre1">You can then use this value to obtain the <code class="calibre9">Character</code> (grapheme cluster) at that index, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> firstChar <span class="hljs-operator">=</span> cafeCombining[firstIndex]</pre>
<p class="calibre1">In this case, <code class="calibre9">firstChar</code> will, of course, be <em class="calibre5">c</em>. The type of this value is <em class="calibre5">Character</em>, a grapheme cluster.
</p>
<p class="calibre1">Similarly, you can obtain the last grapheme cluster like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> lastIndex <span class="hljs-operator">=</span> cafeCombining.endIndex
<span class="hljs-keyword">let</span> lastChar <span class="hljs-operator">=</span> cafeCombining[lastIndex]</pre>
<p class="calibre1">But if you do this, you’ll get a fatal error on the console (and an <code class="calibre9">EXC_BAD_INSTRUCTION</code> error in the code):
</p><pre class="code-block">Fatal error: String index is out of bounds</pre>
<p class="calibre1">This error happens because the <code class="calibre9">endIndex</code> is one past the end of the string. You need to do this to obtain the last character:
</p><pre class="code-block"><span class="hljs-keyword">let</span> lastIndex <span class="hljs-operator">=</span> cafeCombining.index(before: cafeCombining.endIndex)
<span class="hljs-keyword">let</span> lastChar <span class="hljs-operator">=</span> cafeCombining[lastIndex]</pre>
<p class="calibre1">Here you’re obtaining the index just before the end index then obtaining the character at that index. Alternatively, you could offset from the first character like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fourthIndex <span class="hljs-operator">=</span> cafeCombining.index(cafeCombining.startIndex,
                                      offsetBy: <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> fourthChar <span class="hljs-operator">=</span> cafeCombining[fourthIndex]</pre>
<p class="calibre1">In this case, <code class="calibre9">fourthChar</code> is <code class="calibre9">é</code> as expected.
</p>
<p class="calibre1">But as you know, the <code class="calibre9">é</code> in that case is made up of multiple code points. You can access these code points on the <code class="calibre9">Character</code> type the same way as you can on <code class="calibre9">String</code> through the <code class="calibre9">unicodeScalars</code> view. So you can do this:
</p><pre class="code-block">fourthChar.unicodeScalars.count <span class="hljs-comment">// 2</span>
fourthChar.unicodeScalars.forEach { codePoint <span class="hljs-keyword">in</span>
  <span class="hljs-built_in">print</span>(codePoint.value)
}</pre>
<p class="calibre1">This time you’re using the <code class="calibre9">forEach</code> function to iterate through the Unicode scalars view. The count is two, and as expected, the loop prints out:
</p><pre class="code-block">101
769</pre>
<h3 class="segment-title2">Equality with combining characters</h3>

<p class="calibre1">Combining characters make the equality of strings a little trickier. For example, consider the word <em class="calibre5">café</em> written once using the single <em class="calibre5">é</em> character, and once using the combining character, like so:
</p><div class="image2"><img src="images/000064.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">These two strings are, of course, logically equal. When they are printed on-screen, they use the same <em class="calibre5">glyph</em> and look the same. But they are represented inside the computer in different ways. Many programming languages would consider these strings to be unequal because those languages work by comparing the code points one by one.
</p>
<p class="calibre1">Swift, however, considers these strings to be equal by default. Let’s see that in action.
</p><pre class="code-block"><span class="hljs-keyword">let</span> equal <span class="hljs-operator">=</span> cafeNormal <span class="hljs-operator">==</span> cafeCombining</pre>
<p class="calibre1">In this case, <code class="calibre9">equal</code> is <code class="calibre9">true</code> because the two strings are logically the same.
</p>
<p class="calibre1">String comparison in Swift uses a technique known as <em class="calibre5">canonicalization</em>. Say that three times fast! Before checking equality, Swift canonicalizes both strings, which means they’re converted to use the same special character representation.
</p>
<p class="calibre1">It doesn’t matter which way Swift does the canonicalization &mdash; using the single character or using the combining character &mdash; as long as both strings get converted to the same style. Once the canonicalization is complete, Swift can compare individual characters to check for equality.
</p>
<p class="calibre1">The same canonicalization comes into play when considering how many characters are in a particular string. You saw earlier where <code class="calibre9">café</code> using the single <code class="calibre9">é</code> character and <code class="calibre9">café</code> using the <code class="calibre9">e</code> plus combining accent character had the same length.
</p>
<h2 class="segment-chapter1">Strings as bi-directional collections</h2>

<p class="calibre1">Sometimes you want to reverse a string. Often this is so you can iterate through it backward. Fortunately, Swift has a rather simple way to do this, through a method called <code class="calibre9">reversed()</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Matt"</span>
<span class="hljs-keyword">let</span> backwardsName <span class="hljs-operator">=</span> name.reversed()</pre>
<p class="calibre1">But what is the type of <code class="calibre9">backwardsName</code>? If you said <code class="calibre9">String</code>, then you would be wrong. It is a <code class="calibre9">ReversedCollection&lt;String&gt;</code>. Changing the type is a smart optimization that Swift makes. Instead of it being a concrete <code class="calibre9">String</code>, it is a <em class="calibre5">reversed collection</em>. Think of it as a thin wrapper around any collection that allows you to use the collection as if it were the other way around, without incurring additional memory usage.
</p>
<p class="calibre1">You can then access every <code class="calibre9">Character</code>in the backwards string just as you would any other string, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> secondCharIndex <span class="hljs-operator">=</span> backwardsName.index(backwardsName.startIndex,
                                          offsetBy: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> secondChar <span class="hljs-operator">=</span> backwardsName[secondCharIndex] <span class="hljs-comment">// "t"</span></pre>
<p class="calibre1">But what if you want a <code class="calibre9">String</code> type? Well, you can do that by initializing a <code class="calibre9">String</code> from the reversed collection, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> backwardsNameString <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span>(backwardsName)</pre>
<p class="calibre1">This will create a new <code class="calibre9">String</code> from the reversed collection. But when you do this, you end up making a reversed copy of the original string with its own memory storage. Staying in the reversed collection domain will save memory space, which is fine if you don’t need the whole reversed string.
</p>
<h2 class="segment-chapter1">Raw strings</h2>

<p class="calibre1">A <em class="calibre5">raw string</em> is useful when you want to avoid special characters or string interpolation. Instead, the complete string as you type it is what becomes the string. To illustrate this, consider the following raw string:
</p><pre class="code-block"><span class="hljs-keyword">let</span> raw1 <span class="hljs-operator">=</span> <span class="hljs-string">#"Raw "No Escaping" \(no interpolation!). Use all the \ you want!"#</span>
<span class="hljs-built_in">print</span>(raw1)</pre>
<p class="calibre1">To denote a raw string, you surround the string in <code class="calibre9">#</code> symbols. This code prints:
</p><pre class="code-block">Raw "No Escaping" \(no interpolation!). Use all the \ you want!</pre>
<p class="calibre1">If you didn’t use the <code class="calibre9">#</code> symbols, this string would try to use interpolation and wouldn’t compile because “no interpolation!” is not valid Swift. If you want to include <code class="calibre9">#</code> in your code, you can do that too. You can use any number of <code class="calibre9">#</code> symbols you want as long as the beginning and end match like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> raw2 <span class="hljs-operator">=</span> <span class="hljs-string">##"Aren’t we "# clever"##</span>
<span class="hljs-built_in">print</span>(raw2)</pre>
<p class="calibre1">This prints:
</p><pre class="code-block">Aren’t we "# clever</pre>
<p class="calibre1">What if you want to use interpolation with raw strings. Can you do that?
</p><pre class="code-block"><span class="hljs-keyword">let</span> can <span class="hljs-operator">=</span> <span class="hljs-string">"can do that too"</span>
<span class="hljs-keyword">let</span> raw3 <span class="hljs-operator">=</span> <span class="hljs-string">#"Yes we <span class="hljs-subst">\#(can)</span>!"#</span>
<span class="hljs-built_in">print</span>(raw3)</pre>
<p class="calibre1">Prints:
</p><pre class="code-block">Yes, we can do that too!</pre>
<p class="calibre1">There’s one more rather fun use of raw strings. You might need to use some ASCII art in your programs from time to time. ASCII art is where you use simple characters to draw out a picture. The problem is that ASCII art will often contain the backslash character, <code class="calibre9">\</code>, which is usually the escape character, as you saw earlier. Therefore raw strings are good for ASCII art because otherwise, all the <code class="calibre9">\</code> would be treated as escapes, and bad things would ensure.
</p>
<p class="calibre1">You can try out some ASCII art for yourself:
</p><pre class="code-block"><span class="hljs-keyword">let</span> multiRaw <span class="hljs-operator">=</span> <span class="hljs-string">#"""
  _____         _  __ _
 / ____|       (_)/ _| |
| (_____      ___| |_| |_
 \___ \ \ /\ / / |  _| __|
 ____) \ V  V /| | | | |_
|_____/ \_/\_/ |_|_|  \__|
"""#</span>
<span class="hljs-built_in">print</span>(multiRaw)</pre>
<p class="calibre1">Now that looks neat!
</p>
<p class="calibre1">The Swift team seems to have thought of everything with raw strings.
</p>
<h2 class="segment-chapter1">Substrings</h2>

<p class="calibre1">Another thing you often need to do when manipulating strings is to generate substrings. That is, pull out a part of the string into its own value. This can be done in Swift using a subscript that takes a range of indices.
</p>
<p class="calibre1">For example, consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fullName <span class="hljs-operator">=</span> <span class="hljs-string">"Matt Galloway"</span>
<span class="hljs-keyword">let</span> spaceIndex <span class="hljs-operator">=</span> fullName.firstIndex(of: <span class="hljs-string">" "</span>)<span class="hljs-operator">!</span>
<span class="hljs-keyword">let</span> firstName <span class="hljs-operator">=</span> fullName[fullName.startIndex<span class="hljs-operator">..&lt;</span>spaceIndex] <span class="hljs-comment">// "Matt"</span></pre>
<p class="calibre1">This code finds the index representing the first space (using a force unwrap here because you know one exists). Then it uses a range to find the grapheme clusters between the start index and the index of the space (not including the space).
</p>
<p class="calibre1">Now is an excellent time to introduce a new type of range you haven’t seen before: the <em class="calibre5">open</em><em class="calibre5">-</em><em class="calibre5">ended range</em>. This type of range only takes one index and assumes the other is either the start or the end of the collection.
</p>
<p class="calibre1">That last line of code can be rewritten by using an open-ended range:
</p><pre class="code-block"><span class="hljs-keyword">let</span> firstName <span class="hljs-operator">=</span> fullName[<span class="hljs-operator">..&lt;</span>spaceIndex] <span class="hljs-comment">// "Matt"</span></pre>
<p class="calibre1">This time we omit the <code class="calibre9">fullName.startIndex</code> and Swift will infer that this is what you mean.
</p>
<p class="calibre1">Similarly, you can also use a one-sided range to start at a certain index and go to the end of the collection, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> lastName <span class="hljs-operator">=</span> fullName[fullName.index(after: spaceIndex)<span class="hljs-operator">...</span>]
<span class="hljs-comment">// "Galloway"</span></pre>
<p class="calibre1">There’s something interesting to point out with substrings. If you look at their type, then you will see they are of type <code class="calibre9">String.SubSequence</code> rather than <code class="calibre9">String</code>. This <code class="calibre9">String.SubSequence</code> is just a <code class="calibre9">typealias</code> of <code class="calibre9">Substring</code>, which means that <code class="calibre9">Substring</code> is the actual type, and <code class="calibre9">String.SubSequence</code> is an alias.
</p>
<p class="calibre1">Just like with the reversed string, you can force this <code class="calibre9">Substring</code> into a <code class="calibre9">String</code> by doing the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> lastNameString <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span>(lastName)</pre>
<p class="calibre1">The reason for this extra <code class="calibre9">Substring</code> type is a cunning optimization. A <code class="calibre9">Substring</code> shares the storage with its parent <code class="calibre9">String</code> that it was sliced from. This means that when you’re in the process of slicing a string, you use no extra memory. Then, when you want the substring as a <code class="calibre9">String</code>, you explicitly create a new string, and the memory is copied into a new buffer for this new string.
</p>
<p class="calibre1">The designers of Swift could have made this copying behavior by default. However, by having the separate type <code class="calibre9">Substring</code>, Swift makes it very explicit what is happening. The good news is that <code class="calibre9">String</code> and <code class="calibre9">Substring</code> share almost all the same capabilities. You might not even realize which type you are using until you return or pass your <code class="calibre9">Substring</code> to another function that requires a <code class="calibre9">String</code>. In this case, you can simply initialize a new <code class="calibre9">String</code> from your <code class="calibre9">Substring</code> explicitly.
</p>
<p class="calibre1">Hopefully, it’s clear that Swift is opinionated about strings and very deliberate in the way it implements them. It is an important bit of knowledge to carry because strings are complex beasts and are used frequently. Getting the API right is important &mdash; that’s an understatement. :]
</p>
<h2 class="segment-chapter1">Character properties</h2>

<p class="calibre1">You encountered the <code class="calibre9">Character</code> type earlier in this chapter. Some rather interesting properties of this type allow you to introspect the character in question and learn about its semantics.
</p>
<p class="calibre1">Let’s take a look at a few of the properties.
</p>
<p class="calibre1">The first is simply finding out if the character belongs to the <em class="calibre5">ASCII</em> character set.  You can achieve this like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> singleCharacter: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"x"</span>
singleCharacter.isASCII</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> ASCII stands for American Standard Code for Information Interchange. It is a fixed-width 7-bit code for representing strings developed in the 1960s by Bell Labs. Because of its history and importance, the standard 8-bit Unicode encoding (UTF-8) was created as a superset of ASCII.  You will learn more about UTF-8 later in this chapter.
</p></div>

<p class="calibre1">In this case, the result is <code class="calibre9">true</code> because <code class="calibre9">"x"</code> is indeed in the ASCII character set. However, if you did this for something like <code class="calibre9">"🥳"</code>, the “party face” emoji, then you would get <code class="calibre9">false</code>.
</p>
<p class="calibre1">Next up is checking if something is whitespace. This can be useful as whitespace often has meaning in things like programming languages.
</p>
<p class="calibre1">You can achieve this like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> space: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">" "</span>
space.isWhitespace</pre>
<p class="calibre1">Again, the result here would be <code class="calibre9">true</code>.
</p>
<p class="calibre1">Next up is checking if something is a hexadecimal digit or not. This can be useful if you are parsing some text and want to know if something is valid hexadecimal or not. You can achieve this like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> hexDigit: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"d"</span>
hexDigit.isHexDigit</pre>
<p class="calibre1">The result is <code class="calibre9">true</code>, but if you changed it to check <code class="calibre9">"s"</code>, it would be <code class="calibre9">false</code>.
</p>
<p class="calibre1">Finally, a rather powerful property is being able to convert a character to its numeric value. That might sound simple, say converting the character <code class="calibre9">"5"</code> into the number <code class="calibre9">5</code>. However, it also works on non-Latin characters. For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> thaiNine: <span class="hljs-built_in">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">"๙"</span>
thaiNine.wholeNumberValue</pre>
<p class="calibre1">In this case, the result is <code class="calibre9">9</code> because that is the Thai character for the number nine. Neat! :]
</p>
<p class="calibre1">This is only scratching the surface of the properties of <code class="calibre9">Character</code>. There are too many to go through each one here; however, you can read more in the Swift evolution proposal (<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0221-character-properties.md" class="calibre6">https://github.com/apple/swift-evolution/blob/master/proposals/0221-character-properties.md</a>), which added these.
</p>
<h2 class="segment-chapter1">Encoding</h2>

<p class="calibre1">So far, you’ve learned what strings are and explored how to work with them but haven’t touched on how strings are stored or encoded.
</p>
<p class="calibre1">Strings are made up of a collection of Unicode code points. These code points range from the number 0 up to 1114111 (or 0x10FFFF in hexadecimal). This means that the maximum number of bits you need to represent a code point is 21.
</p>
<p class="calibre1">However, if you are only ever using low code points, such as if your text contains only Latin characters, then you can get away with using only eight bits per code point.
</p>
<p class="calibre1">Numeric types in most programming languages come in sizes of addressable, powers-of-2 bits, such as 8-bits, 16-bits and 32-bits. This is because computers are made of billions of transistors, either off or on; they just love powers of two!
</p>
<p class="calibre1">When choosing how to store strings, you could store every individual code point in a 32-bit type, such as <code class="calibre9">UInt32</code>. Your <code class="calibre9">String</code> type would be backed by a <code class="calibre9">[UInt32]</code> (a <code class="calibre9">UInt32</code> array). Each of these <code class="calibre9">UInt32</code>s is what is known as a <em class="calibre5">code unit</em>. However, you would be wasting space because not all those bits are needed, especially if the string uses only low code points.
</p>
<p class="calibre1">This choice of how to store strings is known as the string’s <em class="calibre5">encoding</em>. This particular scheme described above is known as <em class="calibre5">UTF</em><em class="calibre5">-</em><em class="calibre5">32</em>. However, because it has inefficient memory usage, it is very rarely used.
</p>
<h3 class="segment-title2">UTF-8</h3>

<p class="calibre1">A much more common scheme is called <em class="calibre5">UTF</em><em class="calibre5">-</em><em class="calibre5">8</em>. This uses 8-bit code units instead. One reason for UTF-8’s popularity is because it is fully compatible with the venerable, English-only, 7-bit ASCII encoding. But how do you store code points that need more than eight bits?! Herein lies the magic of the encoding.
</p>
<p class="calibre1">If the code point requires up to seven bits, it is represented by simply one code unit and is identical to <em class="calibre5">ASCII</em>. But for code points above seven bits, a scheme comes into play that uses up to four <em class="calibre5">code units</em> to represent the code point.
</p>
<p class="calibre1">For code points of 8 to 11 bits, two code units are used. The first code unit’s initial three bits are <code class="calibre9">110</code>. The remaining five bits are the first five bits of the code point. The second code unit’s initial two bits are <code class="calibre9">10</code>. The remaining six bits are the remaining six bits of the code point.
</p>
<p class="calibre1">For example, the code point <code class="calibre9">0x00BD</code> represents the ½ character. In binary, this is <code class="calibre9">10111101</code> and uses eight bits. In UTF-8, this would comprise two code units of <code class="calibre9">11000010</code> and <code class="calibre9">10111101</code>.
</p>
<p class="calibre1">To illustrate this, consider the following diagram:
</p><div class="image3"><img src="images/000074.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Of course, code points higher than 11 bits are also supported. 12- to 16-bit code points use three UTF-8 code units, and 17- to 21-bit code points use four UTF-8 code units, according to the following scheme:
</p><div class="image3"><img src="images/000086.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Each <em class="calibre5">x</em> is replaced with the bits from the code points.
</p>
<p class="calibre1">In Swift, you can access the UTF-8 string encoding through the <code class="calibre9">utf8</code> view. For example, consider the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> char <span class="hljs-operator">=</span> <span class="hljs-string">"<span class="hljs-subst">\u{00bd}</span>"</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> char.utf8 {
  <span class="hljs-built_in">print</span>(i)
}</pre>
<p class="calibre1">The <code class="calibre9">utf8</code> view is a collection, just like the <code class="calibre9">unicodeScalars</code> view. Its values are the UTF-8 code units that make up the string. In this case, it’s a single character, namely the one that we discussed above.
</p>
<p class="calibre1">The above code will print the following:
</p><pre class="code-block">194
189</pre>
<p class="calibre1">If you pull out your calculator (or have a fantastic mental arithmetic mind), then you can validate that these are <code class="calibre9">11000010</code> and <code class="calibre9">10111101</code>, respectively, as you expected!
</p>
<p class="calibre1">Now consider a more complicated example which you’ll refer back to later in this section. Take the following string:
</p><pre class="code-block">+½⇨🙃</pre>
<p class="calibre1">And iterate through the UTF-8 code units it contains:
</p><pre class="code-block"><span class="hljs-keyword">let</span> characters <span class="hljs-operator">=</span> <span class="hljs-string">"+<span class="hljs-subst">\u{00bd}</span><span class="hljs-subst">\u{21e8}</span><span class="hljs-subst">\u{1f643}</span>"</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> characters.utf8 {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(i)</span> : <span class="hljs-subst">\(String(i, radix: <span class="hljs-number">2</span>))</span>"</span>)
}</pre>
<p class="calibre1">This time the <code class="calibre9">print</code> statement will print out both the decimal number and the number in binary. It prints the following, with newlines added to split grapheme clusters:
</p><pre class="code-block">43 : 101011

194 : 11000010
189 : 10111101

226 : 11100010
135 : 10000111
168 : 10101000

240 : 11110000
159 : 10011111
153 : 10011001
131 : 10000011</pre>
<p class="calibre1">Feel free to verify that these are indeed correct. Notice that the first character used one code unit, the second used two code units, and so on.
</p>
<p class="calibre1">UTF-8 is therefore much more compact than UTF-32. For this string, you used 10 bytes to store the 4 code points. In UTF-32 this would be 16 bytes (four bytes per code unit, one code unit per code point, four code points).
</p>
<p class="calibre1">There is a downside to UTF-8, though. To handle certain string operations, you need to inspect every byte. For example, if you wanted to jump to the <i class="calibre2">n</i> th code point, you would need to inspect every byte until you have gone past <i class="calibre2">n</i>-1 code points. You cannot simply jump into the buffer because you don’t know how far you have to jump.
</p>
<h3 class="segment-title2">UTF-16</h3>

<p class="calibre1">There is another encoding that is useful to introduce, namely <em class="calibre5">UTF</em><em class="calibre5">-</em><em class="calibre5">16</em>. Yes, you guessed it. It uses 16-bit code units!
</p>
<p class="calibre1">This means that code points that are up to 16 bits use one code unit. But how are code points of 17 to 21 bits represented? These use a scheme known as <em class="calibre5">surrogate pairs</em>. These are two UTF-16 code units that, when next to each other, represent a code point from the range above 16 bits.
</p>
<p class="calibre1">There is a space within Unicode reserved for these surrogate pair code points. They are split into low and high surrogates. The high surrogates range from <code class="calibre9">0xD800</code> to <code class="calibre9">0xDBFF</code>, and the low surrogates range from <code class="calibre9">0xDC00</code> to <code class="calibre9">0xDFFF</code>.
</p>
<p class="calibre1">Perhaps that sounds backward &mdash; but the high and low here refer to the bits from the original code point represented by this surrogate.
</p>
<p class="calibre1">Take the upside-down face emoji from the string you saw earlier. Its code point is <code class="calibre9">0x1F643</code>. To find out the surrogate pairs for this code point, you apply the following algorithm:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Subtract <code class="calibre9">0x10000</code> to give 0xF643, or <code class="calibre9">0000 1111 0110 0100 0011</code> in binary.
</p></li>

<li class="calibre4">
<p class="calibre1">Split these 20 bits into two. This gives you <code class="calibre9">0000 1111 01</code> and <code class="calibre9">10 0100 0011</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Take the first and add <code class="calibre9">0xD800</code> to it to give <code class="calibre9">0xD83D</code>. This is your <em class="calibre5">high surrogate</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">Take the second and add <code class="calibre9">0xDC00</code> to it to give <code class="calibre9">0xDE43</code>. This is your <em class="calibre5">low surrogate</em>.
</p></li>
</ol>

<p class="calibre1">So in UTF-16, that upside-down face emoji is represented by the code unit <code class="calibre9">0xD83D</code> followed by <code class="calibre9">0xDE43</code>. Neat!
</p>
<p class="calibre1">Just as with UTF-8, Swift allows you to access the UTF-16 code units through the <code class="calibre9">utf16</code> view, like so:
</p><pre class="code-block"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> characters.utf16 {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(i)</span> : <span class="hljs-subst">\(String(i, radix: <span class="hljs-number">2</span>))</span>"</span>)
}</pre>
<p class="calibre1">In this case, the following is printed, again with newlines added to split grapheme clusters:
</p><pre class="code-block">43 : 101011

189 : 10111101

8680 : 10000111101000

55357 : 1101100000111101
56899 : 1101111001000011</pre>
<p class="calibre1">As you can see, the only code point that needs to use more than one code unit is the last one, your upside-down face emoji. As expected, the values are correct!
</p>
<p class="calibre1">So with UTF-16, your string this time uses 10 bytes (5 code units, 2 bytes per code unit), the same as UTF-8. However, the memory usage with UTF-8 and UTF-16 is often different. For example, strings comprised of code points of 7 bits or less will take up twice the space in UTF-16 than they would in UTF-8.
</p>
<p class="calibre1">For a string made up of code points 7 bits or less, the string has to be entirely made up of those Latin characters contained in that range. Even the “£” sign is not in this range! So, often, the memory usage of UTF-16 and UTF-8 are comparable.
</p>
<p class="calibre1">Swift string views make the <code class="calibre9">String</code> type encoding agnostic &mdash; Swift is one of the only languages that does this.  Internally it uses UTF-8, C-language compatible, <code class="calibre9">NULL</code> terminated strings because it hits a sweet spot between memory usage and complexity of operations.
</p>
<h3 class="segment-title2">Converting indexes between encoding views</h3>

<p class="calibre1">As you saw earlier, you use indexes to access grapheme clusters in a string. For example, using the same string from above, you can do the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> arrowIndex <span class="hljs-operator">=</span> characters.firstIndex(of: <span class="hljs-string">"<span class="hljs-subst">\u{21e8}</span>"</span>)<span class="hljs-operator">!</span>
characters[arrowIndex] <span class="hljs-comment">// ⇨</span></pre>
<p class="calibre1">Here, <code class="calibre9">arrowIndex</code> is of type <code class="calibre9">String.Index</code> and used to obtain the <code class="calibre9">Character</code> at that index.
</p>
<p class="calibre1">You can convert this index into the index relating to the start of this grapheme cluster in the <code class="calibre9">unicodeScalars</code>, <code class="calibre9">utf8</code> and <code class="calibre9">utf16</code> views. You do that using the <code class="calibre9">samePosition(in:)</code> method on <code class="calibre9">String.Index</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> unicodeScalarsIndex <span class="hljs-operator">=</span> arrowIndex.samePosition(in: characters.unicodeScalars) {
  characters.unicodeScalars[unicodeScalarsIndex] <span class="hljs-comment">// 8680</span>
}

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> utf8Index <span class="hljs-operator">=</span> arrowIndex.samePosition(in: characters.utf8) {
  characters.utf8[utf8Index] <span class="hljs-comment">// 226  </span>
}

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> utf16Index <span class="hljs-operator">=</span> arrowIndex.samePosition(in: characters.utf16) {
  characters.utf16[utf16Index] <span class="hljs-comment">// 8680</span>
}</pre>
<p class="calibre1"><code class="calibre9">unicodeScalarsIndex</code> is of type <code class="calibre9">String.UnicodeScalarView.Index</code>. This grapheme cluster is represented by only one code point, so in the <code class="calibre9">unicodeScalars</code> view, the scalar returned is the one and only code point. If the <code class="calibre9">Character</code> were made up of two code points, such as <em class="calibre5">e</em> combined with <em class="calibre5">´</em> as you saw earlier, the scalar returned in the code above would be just the “e”.
</p>
<p class="calibre1">Likewise, <code class="calibre9">utf8Index</code> is of type <code class="calibre9">String.UTF8View.Index</code>, and the value at that index is the first UTF-8 code unit used to represent this code point. The same goes for the <code class="calibre9">utf16Index</code>, which is of type <code class="calibre9">String.UTF16View.Index</code>.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of strings. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Character count</h3>

<p class="calibre1">Write a function that takes a string and prints out the count of each character in the string. For bonus points, print them ordered by the count of each character. For bonus-bonus points, print it as a nice histogram.
</p>
<p class="calibre1">Hint: You could use # characters to draw the bars.
</p>
<h3 class="segment-title2">Challenge 2: Word count</h3>

<p class="calibre1">Write a function that tells you how many words there are in a string. Do it without splitting the string.
</p>
<p class="calibre1">Hint: try iterating through the string yourself.
</p>
<h3 class="segment-title2">Challenge 3: Name formatter</h3>

<p class="calibre1">Write a function that takes a string that looks like “Galloway, Matt” and returns one which looks like “Matt Galloway”, i.e., the string goes from <code class="calibre9">"&lt;LAST_NAME&gt;, &lt;FIRST_NAME&gt;"</code> to <code class="calibre9">"&lt;FIRST_NAME&gt; &lt;LAST_NAME&gt;"</code>.
</p>
<h3 class="segment-title2">Challenge 4: Components</h3>

<p class="calibre1">A method exists on a string named <code class="calibre9">components(separatedBy:)</code> that will split the string into chunks, which are delimited by the given string, and return an array containing the results.
</p>
<p class="calibre1">Your challenge is to implement this yourself.
</p>
<p class="calibre1">Hint: There exists a view on <code class="calibre9">String</code> named <code class="calibre9">indices</code> that lets you iterate through all the indices (of type <code class="calibre9">String.Index</code>) in the string. You will need to use this.
</p>
<h3 class="segment-title2">Challenge 5: Word reverser</h3>

<p class="calibre1">Write a function that takes a string and returns a version of it with each individual word reversed.
</p>
<p class="calibre1">For example, if the string is “My dog is called Rover” then the resulting string would be “yM god si dellac revoR”.
</p>
<p class="calibre1">Try to do it by iterating through the <code class="calibre9">indices</code> of the string until you find a space and then reversing what was before it. Build up the result string by continually doing that as you iterate through the string.
</p>
<p class="calibre1">Hint: You’ll need to do a similar thing as you did for Challenge 4 but reverse the word each time. Try to explain to yourself, or the closest unsuspecting family member, why this is better in terms of memory usage than using the function you created in the previous challenge.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Strings are collections of <code class="calibre9">Character</code> types.
</p></li>

<li class="calibre4">
<p class="calibre1">A <code class="calibre9">Character</code> is <em class="calibre5">grapheme cluster</em> and is made up of one or more <em class="calibre5">code points</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">A <em class="calibre5">combining character</em> is a character that alters the previous character in some way.
</p></li>

<li class="calibre4">
<p class="calibre1">You use special (non-integer) indexes to subscript into the string to a certain grapheme cluster.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift’s use of <em class="calibre5">canonicalization</em> ensures that the comparison of strings accounts for combining characters.
</p></li>

<li class="calibre4">
<p class="calibre1">Slicing a string yields a substring with type <code class="calibre9">Substring</code>, which shares storage with its parent <code class="calibre9">String</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">You can convert from a <code class="calibre9">Substring</code> to a <code class="calibre9">String</code> by initializing a new <code class="calibre9">String</code> and passing the <code class="calibre9">Substring</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift <code class="calibre9">String</code> has a view called <code class="calibre9">unicodeScalars</code>, a collection of the individual Unicode code points that make up the string.
</p></li>

<li class="calibre4">
<p class="calibre1">There are multiple ways to encode a string. UTF-8 and UTF-16 are the most popular.
</p></li>

<li class="calibre4">
<p class="calibre1">The individual parts of an encoding are called <em class="calibre5">code units</em>. UTF-8 uses 8-bit code units, and UTF-16 uses 16-bit code units.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift’s <code class="calibre9">String</code> has views called <code class="calibre9">utf8</code> and <code class="calibre9">utf16</code>that are collections that allow you to obtain the individual code units in the given encoding.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-30">


<h1 class="segment-chapter">Section III: Building Your Own Types</h1>

<p class="calibre1">You can create your own type by combining variables and functions into a new type definition. When you create a new type, you give it a name; thus, these custom types are known as <em class="calibre5">named types</em>. Structures are a powerful tool for modeling real-world concepts. You can encapsulate related concepts, properties and methods into a single, cohesive model.
</p>
<p class="calibre1">Swift includes four kinds of named types: structures, classes, enumerations and protocols. You’ll learn here how other named types use the concepts of methods and properties, how they differ, and where you want to use each.
</p>
<p class="calibre1">You’ll also learn about generics, which are types and methods that take as input other types instead of just methods, as well as custom types to build larger and complex things!
</p></div>

<div class="segment-title" id="calibre_link-35">


<h1 class="segment-chapter">Chapter 10: Structures</h1>

<p class="calibre1">You’ve covered some fundamental building blocks of Swift. With variables, conditionals, strings, functions and collections, you’re ready to conquer the world! Well, almost.
</p>
<p class="calibre1">Most programs that perform complex tasks benefit from higher levels of abstraction. In addition to an <code class="calibre9">Int</code>, <code class="calibre9">String</code> or <code class="calibre9">Array</code>, most programs use new types specific to the domain of the task at hand. Keeping track of photos or contacts, for example, demands more than the simple types you’ve seen so far.
</p>
<p class="calibre1">This chapter introduces the first <em class="calibre5">named type</em>&ndash;<em class="calibre5">structures</em>. Structures are types that can store named properties and define actions and behaviors. Like a <code class="calibre9">String</code>, <code class="calibre9">Int</code> or <code class="calibre9">Array</code>, you can define structures to create named types to use in your code. By the end of this chapter, you’ll know how to define and use your own structures.
</p>
<p class="calibre1">You’ll begin your adventure into custom types with pizza.
</p><div class="image3"><img src="images/000117.png" alt="" title="" class="calibre7" /></div>
<h2 class="segment-chapter1">Introducing structures</h2>

<p class="calibre1">Imagine you live in a town called Pizzaville. As you might expect, Pizzaville is known for its amazing pizza. You own the most popular (and fastest!) pizza delivery restaurant in Pizzaville &mdash; “Swift Pizza”.
</p><div class="image3"><img src="images/000003.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">As the owner of a single restaurant, you have a limited delivery area. You want to write a program that calculates if a potential customer is within range for your delivery drivers. The first version of your program might look something like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> restaurantLocation <span class="hljs-operator">=</span> (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> restaurantRange <span class="hljs-operator">=</span> <span class="hljs-number">2.5</span>

<span class="hljs-comment">// Pythagorean Theorem 📐🎓</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">distance</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">source</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>),
              <span class="hljs-built_in">to</span> <span class="hljs-built_in">target</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">let</span> distanceX <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(source.x <span class="hljs-operator">-</span> target.x)
  <span class="hljs-keyword">let</span> distanceY <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(source.y <span class="hljs-operator">-</span> target.y)
  <span class="hljs-keyword">return</span> (distanceX <span class="hljs-operator">*</span> distanceX <span class="hljs-operator">+</span>
    distanceY <span class="hljs-operator">*</span> distanceY).squareRoot()
}</pre><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">isInDeliveryRange</span>(<span class="hljs-built_in">location</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-keyword">let</span> deliveryDistance <span class="hljs-operator">=</span> distance(from: location,
                                  to: restaurantLocation)
  <span class="hljs-keyword">return</span> deliveryDistance <span class="hljs-operator">&lt;</span> restaurantRange
}

isInDeliveryRange(location: (x: <span class="hljs-number">5</span>, y: <span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span></pre>
<p class="calibre1">Simple enough, right? <code class="calibre9">distance(from:to:)</code> will calculate how far away you are from your pizza. <code class="calibre9">isInDeliveryRange(location:)</code> will return <code class="calibre9">true</code> only if you’re not too far away.
</p><div class="image3"><img src="images/000016.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">A successful pizza delivery business may eventually expand to include multiple locations, adding a minor twist to the deliverable calculator.
</p>
<p class="calibre1">Replace your existing code with the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> restaurantLocation <span class="hljs-operator">=</span> (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> restaurantRange <span class="hljs-operator">=</span> <span class="hljs-number">2.5</span>

<span class="hljs-keyword">let</span> otherRestaurantLocation <span class="hljs-operator">=</span> (<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)
<span class="hljs-keyword">let</span> otherRestaurantRange <span class="hljs-operator">=</span> <span class="hljs-number">2.5</span>

<span class="hljs-comment">// Pythagorean Theorem 📐🎓</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">distance</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">source</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>),
              <span class="hljs-built_in">to</span> <span class="hljs-built_in">target</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">let</span> distanceX <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(source.x <span class="hljs-operator">-</span> target.x)
  <span class="hljs-keyword">let</span> distanceY <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(source.y <span class="hljs-operator">-</span> target.y)
  <span class="hljs-keyword">return</span> (distanceX <span class="hljs-operator">*</span> distanceX <span class="hljs-operator">+</span>
    distanceY <span class="hljs-operator">*</span> distanceY).squareRoot()
}

<span class="hljs-keyword">func</span> <span class="hljs-number">isInDeliveryRange</span>(<span class="hljs-built_in">location</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-keyword">let</span> deliveryDistance <span class="hljs-operator">=</span>
    distance(from: location, to: restaurantLocation)
  
  <span class="hljs-keyword">let</span> secondDeliveryDistance <span class="hljs-operator">=</span>
    distance(from: location, to: otherRestaurantLocation)
  
  <span class="hljs-keyword">return</span> deliveryDistance <span class="hljs-operator">&lt;</span> restaurantRange <span class="hljs-operator">||</span>
    secondDeliveryDistance <span class="hljs-operator">&lt;</span> otherRestaurantRange
}

isInDeliveryRange(location: (x: <span class="hljs-number">5</span>, y: <span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span></pre>
<p class="calibre1"><code class="calibre9">isInDeliveryRange(location:)</code>  checks both locations to see if you can get your pizza from either one.
</p>
<p class="calibre1">Eventually, the rising number of customers will force the business to expand, and soon it might grow to a total of 10 stores! Then what? Do you keep updating your function to check against all these sets of coordinates and ranges?
</p><div class="image3"><img src="images/000030.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You might briefly consider creating an array of x/y coordinate tuples to keep track of your pizza restaurants, but that would be both difficult to read and maintain. Fortunately, Swift has additional tools to help you simplify the problem.
</p>
<h3 class="segment-title2">Your first structure</h3>

<p class="calibre1">Structures are one of the named types in Swift that allow you to encapsulate related properties and behaviors. You can declare a new type, give it a name, and then use it in your code.
</p>
<p class="calibre1">In the pizza business example, you’ve been using x/y coordinate tuples to represent locations.
</p>
<p class="calibre1">As a first example of structures, promote locations from tuples to a structure type:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Location</span> {
  <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span>
}</pre>
<p class="calibre1">This block of code demonstrates the basic syntax for defining a structure. In this case, the code declares a type named <code class="calibre9">Location</code> that combines both x and y coordinates.
</p>
<p class="calibre1">The basic syntax begins with the <code class="calibre9">struct</code> keyword followed by the name of the type and a pair of curly braces. Everything between the curly braces is a <i class="calibre2">member</i> of the struct.
</p>
<p class="calibre1">In <code class="calibre9">Location</code>, both members, <code class="calibre9">x</code> and <code class="calibre9">y</code>, are <em class="calibre5">properties</em>. Properties are constants or variables that are declared as part of a type. Every instance of the type will have these properties. This means that in our example, every <code class="calibre9">Location</code> will have both an <code class="calibre9">x</code> and a <code class="calibre9">y</code> property.
</p>
<p class="calibre1">You can instantiate a structure and store it in a constant or variable just like any other type you’ve worked with:
</p><pre class="code-block"><span class="hljs-keyword">let</span> storeLocation <span class="hljs-operator">=</span> <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span>)</pre>
<p class="calibre1">To create the <code class="calibre9">Location</code> value, you use the name of the type along with a parameter list in parentheses. This parameter list provides a way to specify the values for the properties <code class="calibre9">x</code> and <code class="calibre9">y</code>. This is an example of an <em class="calibre5">initializer</em>.
</p>
<p class="calibre1">Initializers enforce that all properties are set before you start using them. This is one of the key safety features of Swift. Accidentally using uninitialized variables is a significant source of bugs in other languages. Another handy Swift feature is that you don’t need to declare this initializer in the <code class="calibre9">Location</code> type. Swift automatically provides initializers for structures with all the properties in the parameter list. You’ll learn a lot more about initializers in Chapter 12, “Methods.”
</p>
<p class="calibre1">You may remember that there’s also a range involved, and now that the pizza business is expanding, there may be different ranges associated with different restaurants. You can create another struct to represent the delivery area of a restaurant, like so:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">DeliveryArea</span> {
  <span class="hljs-keyword">let</span> center: <span class="hljs-built_in">Location</span>
  <span class="hljs-keyword">var</span> radius: <span class="hljs-built_in">Double</span>
}

<span class="hljs-keyword">var</span> storeArea <span class="hljs-operator">=</span> <span class="hljs-built_in">DeliveryArea</span>(center: storeLocation, radius: <span class="hljs-number">2.5</span>)</pre>
<p class="calibre1">Now there’s a new structure named <code class="calibre9">DeliveryArea</code> that contains a constant <code class="calibre9">center</code> property along with a variable <code class="calibre9">radius</code> property. As you can see, you can have a structure value inside a structure value; here, you use the <code class="calibre9">Location</code> type as the type of the <code class="calibre9">center</code> property of the <code class="calibre9">DeliveryArea</code> struct.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a structure that represents a pizza order. Include toppings, size and any other option you’d want for a pizza.
</p>
<h2 class="segment-chapter1">Accessing members</h2>

<p class="calibre1">With your <code class="calibre9">DeliveryArea</code> defined and an instantiated value in hand, you may be wondering how you can <i class="calibre2">use</i> these values. Just as you have been doing with <code class="calibre9">Strings</code>, <code class="calibre9">Arrays</code>, and <code class="calibre9">Dictionaries</code>, you use <em class="calibre5">dot syntax</em> to access members:
</p><pre class="code-block">storeArea.radius <span class="hljs-comment">// 2.5</span></pre>
<p class="calibre1">You can even access <i class="calibre2">members of members</i> using dot syntax:
</p><pre class="code-block">storeArea.center.x <span class="hljs-comment">// 3</span></pre>
<p class="calibre1">Similar to how you can read values with dot syntax, you can also <i class="calibre2">assign</i> them. If the delivery radius of one pizza location becomes larger, you could assign the new value to the existing property:
</p><pre class="code-block">storeArea.radius <span class="hljs-operator">=</span> <span class="hljs-number">3.5</span></pre>
<p class="calibre1">Defining a property as constant or variable determines if you can change it. In this case, you can assign to <code class="calibre9">radius</code> because you declared it with <code class="calibre9">var</code>.
</p>
<p class="calibre1">On the other hand, you declared <code class="calibre9">center</code> with <code class="calibre9">let</code>, so you can’t modify it. Your <code class="calibre9">DeliveryArea</code> struct allows a pizza restaurant’s delivery range to be changed, but not its location!
</p>
<p class="calibre1">In addition to choosing whether your properties should be variable or constants, you must also declare the structure itself as a variable if you want to be able to modify it after it is initialized:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fixedArea <span class="hljs-operator">=</span> <span class="hljs-built_in">DeliveryArea</span>(center: storeLocation, radius: <span class="hljs-number">4</span>)

<span class="hljs-comment">// Error: Cannot assign to property</span>
fixedArea.radius <span class="hljs-operator">=</span> <span class="hljs-number">3.5</span></pre>
<p class="calibre1">Even though <code class="calibre9">radius</code> was declared with <code class="calibre9">var</code>, the enclosing type <code class="calibre9">fixedArea</code> is constant, so it can’t be changed. The compiler correctly emits an error. Change <code class="calibre9">fixedArea</code> from a <code class="calibre9">let</code> constant to a <code class="calibre9">var</code> variable to make it mutable.
</p>
<p class="calibre1">Now you’ve learned how to control the mutability of the properties in your structure.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Rewrite <code class="calibre9">isInDeliveryRange</code> to use <code class="calibre9">Location</code> and <code class="calibre9">DeliveryArea</code>.
</p>
<h2 class="segment-chapter1">Introducing methods</h2>

<p class="calibre1">Using some of the capabilities of structures, you could now make a pizza delivery range calculator that looks something like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> areas <span class="hljs-operator">=</span> [
  <span class="hljs-built_in">DeliveryArea</span>(center: <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span>), radius: <span class="hljs-number">2.5</span>),
  <span class="hljs-built_in">DeliveryArea</span>(center: <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">8</span>, y: <span class="hljs-number">8</span>), radius: <span class="hljs-number">2.5</span>)
]

<span class="hljs-keyword">func</span> <span class="hljs-number">isInDeliveryRange</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">location</span>: <span class="hljs-built_in">Location</span>) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-keyword">for</span> area <span class="hljs-keyword">in</span> areas {
    <span class="hljs-keyword">let</span> distanceToStore <span class="hljs-operator">=</span> 
      distance(from: (area.center.x, area.center.y),
                 to: (location.x, location.y))

    <span class="hljs-keyword">if</span> distanceToStore <span class="hljs-operator">&lt;</span> area.radius {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
}

<span class="hljs-keyword">let</span> customerLocation1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">5</span>, y: <span class="hljs-number">5</span>)
<span class="hljs-keyword">let</span> customerLocation2 <span class="hljs-operator">=</span> <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">7</span>, y: <span class="hljs-number">7</span>)

isInDeliveryRange(customerLocation1) <span class="hljs-comment">// false</span>
isInDeliveryRange(customerLocation2) <span class="hljs-comment">// true</span></pre>
<p class="calibre1">In this example, there’s an array, <code class="calibre9">areas</code>, and a function that uses that array to determine if a customer’s location is within any of these areas.
</p>
<p class="calibre1">Being in range is something you want to know about a particular restaurant. It’d be great if <code class="calibre9">DeliveryArea</code> could tell you if the restaurant could deliver to a location.
</p>
<p class="calibre1">Much like a structure can have constants and variables, it can also define its own functions. In your playground, locate the implementation of <code class="calibre9">DeliveryArea</code>. Just before the closing curly brace, add the following code:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">contains</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">location</span>: <span class="hljs-built_in">Location</span>) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-keyword">let</span> distanceFromCenter <span class="hljs-operator">=</span>
    distance(from: (center.x, center.y),
               to: (location.x, location.y))

  <span class="hljs-keyword">return</span> distanceFromCenter <span class="hljs-operator">&lt;</span> radius
}</pre>
<p class="calibre1">This code defines a function <code class="calibre9">contains</code>, which is now a member of <code class="calibre9">DeliveryArea</code>. Functions that are members of types are called <em class="calibre5">methods</em>. Notice how <code class="calibre9">contains</code> uses the <code class="calibre9">center</code> and <code class="calibre9">radius</code> properties of the current location. This implicit access to properties and other members inside the structure makes methods different from regular functions. You’ll learn more about methods in Chapter 12, “Methods”.
</p>
<p class="calibre1">Just like other members of structures, you can use dot syntax to access a method:
</p><pre class="code-block"><span class="hljs-keyword">let</span> area <span class="hljs-operator">=</span> <span class="hljs-built_in">DeliveryArea</span>(center: <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">8</span>, y: <span class="hljs-number">8</span>), radius: <span class="hljs-number">2.5</span>)
<span class="hljs-keyword">let</span> customerLocation <span class="hljs-operator">=</span> <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">7</span>, y: <span class="hljs-number">7</span>)
area.contains(customerLocation) <span class="hljs-comment">// true</span></pre>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Change <code class="calibre9">distance(from:to:)</code> to use <code class="calibre9">Location</code> as your parameters instead of x-y tuples.
</p></li>

<li class="calibre4">
<p class="calibre1">Change <code class="calibre9">contains(_:)</code> to call the new <code class="calibre9">distance(from:to:)</code> with <code class="calibre9">Location</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Add a method <code class="calibre9">overlaps(with:)</code> on <code class="calibre9">DeliveryArea</code> that can tell you if the area overlaps with another area.
</p></li>
</ol>

<h2 class="segment-chapter1">Structures as values</h2>

<p class="calibre1">The term <em class="calibre5">value</em> has an important meaning for structures in Swift, and that’s because structures create what are known as <em class="calibre5">value types</em>.
</p>
<p class="calibre1">A value type is a type whose instances are <i class="calibre2">copied</i> on assignment.
</p><pre class="code-block"><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> b <span class="hljs-operator">=</span> a

a <span class="hljs-comment">// 5</span>
b <span class="hljs-comment">// 5</span>

a <span class="hljs-operator">=</span> <span class="hljs-number">10</span>

a <span class="hljs-comment">// 10</span>
b <span class="hljs-comment">// 5</span></pre>
<p class="calibre1">This <em class="calibre5">copy</em><em class="calibre5">-</em><em class="calibre5">on</em><em class="calibre5">-</em><em class="calibre5">assignment</em> behavior means that when <code class="calibre9">a</code> is assigned to <code class="calibre9">b</code>, the value of <code class="calibre9">a</code> is copied into <code class="calibre9">b</code>. But later, when you change the value of <code class="calibre9">a</code>, the value of <code class="calibre9">b</code> stays the same. That’s why it’s important to read <code class="calibre9">=</code> as “assign”, not “is equal to”. Read the statement <code class="calibre9">b = a</code> as “Assign the value of <code class="calibre9">a</code> to <code class="calibre9">b</code>”.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You use <code class="calibre9">==</code> to calculate equality: <code class="calibre9">2 + 2 == 4</code>. Read this expression as a question: “Is 2 + 2 equal to 4?”.
</p></div>

<p class="calibre1">How about the same principle, except with the <code class="calibre9">DeliveryArea</code> struct:
</p><pre class="code-block"><span class="hljs-keyword">var</span> area1 <span class="hljs-operator">=</span> <span class="hljs-built_in">DeliveryArea</span>(center: <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span>), radius: <span class="hljs-number">2.5</span>)
<span class="hljs-keyword">var</span> area2 <span class="hljs-operator">=</span> area1

area1.radius <span class="hljs-comment">// 2.5</span>
area2.radius <span class="hljs-comment">// 2.5</span>

area1.radius <span class="hljs-operator">=</span> <span class="hljs-number">4</span>

area1.radius <span class="hljs-comment">// 4.0</span>
area2.radius <span class="hljs-comment">// 2.5</span></pre>
<p class="calibre1">As with the previous example, <code class="calibre9">area2.radius</code> didn’t pick up the new value set in <code class="calibre9">area1.radius</code>. The disconnection demonstrates the <em class="calibre5">value semantics</em> of working with structures. When you assign <code class="calibre9">area2</code> the value of <code class="calibre9">area1</code>, it gets an exact copy of this value. <code class="calibre9">area1</code> and <code class="calibre9">area2</code> are still completely independent!
</p>
<p class="calibre1">Thanks to value semantics and copying, structures are <i class="calibre2">safe</i>, so you’ll never need to worry about values being shared and possibly being changed behind your back by another piece of code.
</p>
<h2 class="segment-chapter1">Structures everywhere</h2>

<p class="calibre1">You saw how the <code class="calibre9">Location</code> struct and a simple <code class="calibre9">Int</code> share the same copy-on-assignment behavior. They share the behavior because they are both value types, and both have value semantics.
</p>
<p class="calibre1">You know structures represent values, so what exactly is an <code class="calibre9">Int</code> then? If you were to look at the definition of <code class="calibre9">Int</code> in the Swift library, you might be a bit surprised:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Int</span> : <span class="hljs-number">FixedWidthInteger</span>, <span class="hljs-number">SignedInteger</span> {
 <span class="hljs-comment">// …</span>
}</pre>
<p class="calibre1">The <code class="calibre9">Int</code> type is <i class="calibre2">also</i> a structure. Many standard Swift types are structures, such as: <code class="calibre9">Double</code>, <code class="calibre9">String</code>, <code class="calibre9">Bool</code>, <code class="calibre9">Array</code> and <code class="calibre9">Dictionary</code>. As you’ll learn in future chapters, the value semantics of structures provide many other advantages over their reference type counterparts that make them ideal for representing core Swift types.
</p>
<h2 class="segment-chapter1">Conforming to a protocol</h2>

<p class="calibre1">You may have noticed some unfamiliar parts to the <code class="calibre9">Int</code> definition from the Swift standard library above. The types <code class="calibre9">FixedWidthInteger</code> and <code class="calibre9">SignedInteger</code> appear right after the declaration of <code class="calibre9">Int</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Int</span> : <span class="hljs-number">FixedWidthInteger</span>, <span class="hljs-number">SignedInteger</span> {
  <span class="hljs-comment">// …</span>
}</pre>
<p class="calibre1">These types are known as <i class="calibre2">protocols</i>. By putting them after a colon when <code class="calibre9">Int</code> is declared, you signal that <code class="calibre9">Int</code> <i class="calibre2">conforms</i> to these protocols.
</p>
<p class="calibre1">Protocols contain a set of requirements that conforming types <em class="calibre5">must</em> satisfy. A simple example from the standard library is <code class="calibre9">CustomStringConvertible</code>:
</p><pre class="code-block"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-comment">/// A textual representation of this instance.</span>
  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">This protocol contains one property requirement: <code class="calibre9">description</code>. The documentation refers to <code class="calibre9">description</code> as “A textual representation of this instance.”
</p>
<p class="calibre1">If you were to modify <code class="calibre9">DeliveryArea</code> to conform to <code class="calibre9">CustomStringConvertible</code>, you would be required to add a <code class="calibre9">description</code> property with a “textual representation” of the instance. Try this now. Change <code class="calibre9">DeliveryArea</code> to:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">DeliveryArea</span>: <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-keyword">let</span> center: <span class="hljs-built_in">Location</span>
  <span class="hljs-keyword">var</span> radius: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"""
    Area with center: (x: <span class="hljs-subst">\(center.x)</span>, y: <span class="hljs-subst">\(center.y)</span>),
    radius: <span class="hljs-subst">\(radius)</span>
    """</span>
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">contains</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">location</span>: <span class="hljs-built_in">Location</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    distance(from: center, to: location) <span class="hljs-operator">&lt;</span> radius
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">overlaps</span>(<span class="hljs-built_in">with</span> <span class="hljs-built_in">area</span>: <span class="hljs-built_in">DeliveryArea</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    distance(from: center, to: area.center) <span class="hljs-operator">&lt;=</span>
    (radius <span class="hljs-operator">+</span> area.radius)
  }
}</pre>
<p class="calibre1">The value of the <code class="calibre9">description</code> property contains the center and current radius. A value that updates in response to changes elsewhere is called a <i class="calibre2">computed</i> property.
</p>
<p class="calibre1">You’ll learn all about computed properties &mdash; and more &mdash; in Chapter 11, “Properties”!
</p>
<p class="calibre1">So what exactly does conforming to a protocol do? Because any type conforming to <code class="calibre9">CustomStringConvertible</code> must define <code class="calibre9">description</code>, so you can call <code class="calibre9">description</code> on any instance of any type that conforms to <code class="calibre9">CustomStringConvertible</code>. The Swift standard library takes advantage of this with the <code class="calibre9">print()</code> function. That function will use <code class="calibre9">description</code> in the console instead of a rather noisy default description:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(area1) <span class="hljs-comment">// Area with center: (x: 3, y: 3), radius: 4.0</span>
<span class="hljs-built_in">print</span>(area2) <span class="hljs-comment">// Area with center: (x: 3, y: 3), radius: 2.5</span></pre>
<p class="calibre1">Any named type can use protocols to extend its behavior. In this case, you conformed your structure to a protocol defined in the Swift standard library.  In Chapter 16, “Protocols”, you’ll learn more about defining, using and conforming to protocols.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of structures. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Fruit tree farm</h3>

<p class="calibre1">Imagine you’re at a fruit tree farm, and you grow different kinds of fruits: pears, apples, and oranges. After the fruits are picked, a truck brings them in to be processed at the central facility. Since the fruits are all mixed together on the truck, the workers in the central facility have to sort them into the correct inventory container one by one.
</p>
<p class="calibre1">Implement an algorithm that receives a truck full of different kinds of fruits and places each fruit into the correct inventory container.
</p>
<p class="calibre1">Keep track of the total weight of fruit processed by the facility and print out how many of each fruit is in the inventory.
</p>
<h3 class="segment-title2">Challenge 2: A T-shirt model</h3>

<p class="calibre1">Create a T-shirt structure that has size, color and material options. Provide a method to calculate the cost of a shirt based on its attributes.
</p>
<h3 class="segment-title2">Challenge 3: Battleship</h3>

<p class="calibre1">Write the engine for a Battleship-like game. If you aren’t familiar with Battleship, you can brush up on the details at this webpage: <a href="http://bit.ly/2nT3JBU" class="calibre6">http://bit.ly/2nT3JBU</a>
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Use an (x, y) coordinate system for your locations modeled using a structure.
</p></li>

<li class="calibre4">
<p class="calibre1">Ships should also be modeled with structures. Record an origin, direction and length.
</p></li>

<li class="calibre4">
<p class="calibre1">Each ship should be able to report if a “shot” has resulted in a “hit”.
</p></li>
</ul>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Structures are named types you can define and use in your code.
</p></li>

<li class="calibre4">
<p class="calibre1">Structures are <em class="calibre5">value types</em>, which means their values are copied on assignment.
</p></li>

<li class="calibre4">
<p class="calibre1">You use dot syntax to access the members of named types such as structures.
</p></li>

<li class="calibre4">
<p class="calibre1">Named types can have their own variables and functions, which are called properties and methods.
</p></li>

<li class="calibre4">
<p class="calibre1">Conforming to a protocol requires implementing the properties and methods required by that protocol.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-13">


<h1 class="segment-chapter">Chapter 11: Properties</h1>

<p class="calibre1">Chapter 10, “Structures”, showed that you can use structures to group related properties and behaviors into a custom type.
</p>
<p class="calibre1">In the example below, the <code class="calibre9">Car</code> structure has two properties; both are constants that store <code class="calibre9">String</code> values:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Car</span> {
  <span class="hljs-keyword">let</span> make: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> color: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">The values inside a structure are called <em class="calibre5">properties</em>. The two properties of <code class="calibre9">Car</code> are <em class="calibre5">stored properties</em>, which means they store actual string values for each instance of <code class="calibre9">Car</code>.
</p>
<p class="calibre1">Some properties calculate values rather than store them.  In other words, there’s no actual memory allocated for them; instead, they get calculated on-the-fly each time you access them. Naturally, these are called <em class="calibre5">computed properties</em>.
</p>
<p class="calibre1">In this chapter, you’ll learn about both kinds of properties. You’ll also learn some other neat tricks for working with properties, such as how to monitor changes in a property’s value and delay initialization of a stored property.
</p>
<h2 class="segment-chapter1">Stored properties</h2>

<p class="calibre1">As you may have guessed from the example in the introduction, you’re already familiar with the features of stored properties.
</p>
<p class="calibre1">To review, imagine you’re building an address book. The common unit you’ll need is a <code class="calibre9">Contact</code>.
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Contact</span> {
  <span class="hljs-keyword">var</span> fullName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> emailAddress: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">You can use this structure repeatedly, letting you build an array of contacts, each with a different value. The properties you want to store are an individual’s full name and email address.
</p><div class="image3"><img src="images/000055.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">These are the properties of the <code class="calibre9">Contact</code> structure. You provide a data type for each but opt not to assign a default value because you plan to assign the value upon initialization. After all, the values will be different for each instance of <code class="calibre9">Contact</code>.
</p>
<p class="calibre1">Remember that Swift automatically creates an initializer for you based on the properties you defined in your structure:
</p><pre class="code-block"><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-built_in">Contact</span>(fullName: <span class="hljs-string">"Grace Murray"</span>,
                 emailAddress: <span class="hljs-string">"grace@navy.mil"</span>)</pre>
<p class="calibre1">You can access the individual properties using dot notation:
</p><pre class="code-block">person.fullName <span class="hljs-comment">// Grace Murray</span>
person.emailAddress <span class="hljs-comment">// grace@navy.mil</span></pre>
<p class="calibre1">You can assign values to properties as long as they’re defined as variables and the parent instance is stored in a variable. That means both the property and the structure containing the property must be declared with <code class="calibre9">var</code> instead of <code class="calibre9">let</code>.
</p>
<p class="calibre1">When Grace married, she changed her last name:
</p><pre class="code-block">person.fullName <span class="hljs-operator">=</span> <span class="hljs-string">"Grace Hopper"</span>
person.fullName <span class="hljs-comment">// Grace Hopper</span></pre>
<p class="calibre1">Since the property is a variable, she could update her name.
</p>
<p class="calibre1">If you’d like to prevent a value from changing, you can define a property as a constant using <code class="calibre9">let</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Contact</span> {
  <span class="hljs-keyword">var</span> fullName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> emailAddress: <span class="hljs-built_in">String</span>
}

<span class="hljs-comment">// Error: cannot assign to a constant</span>
person.emailAddress <span class="hljs-operator">=</span> <span class="hljs-string">"grace@gmail.com"</span></pre>
<p class="calibre1">Once you’ve initialized an instance of this structure, you can’t change <code class="calibre9">emailAddress</code>.
</p>
<h3 class="segment-title2">Default values</h3>

<p class="calibre1">If you can make a reasonable assumption about the value of a property when the type is initialized, you can give that property a default value.
</p>
<p class="calibre1">It doesn’t make sense to create a default name or email address for a contact, but imagine you add a new property <code class="calibre9">relationship</code> to indicate what kind of contact it is:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Contact</span> {
  <span class="hljs-keyword">var</span> fullName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> emailAddress: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> relationship <span class="hljs-operator">=</span> <span class="hljs-string">"Friend"</span>
}</pre>
<p class="calibre1">By assigning a value in the definition of <code class="calibre9">relationship</code>, you give this property a default value. Any contact created will automatically be a friend unless you change the value of <code class="calibre9">relationship</code> to something like “Work” or “Family”.
</p>
<p class="calibre1">Swift will notice which properties you have defaulted and create the member-wise initializer with parameters also defaulted, so you don’t need to specify them unless you want to.
</p><pre class="code-block"><span class="hljs-keyword">var</span> person <span class="hljs-operator">=</span> <span class="hljs-built_in">Contact</span>(fullName: <span class="hljs-string">"Grace Murray"</span>,
                     emailAddress: <span class="hljs-string">"grace@navy.mil"</span>)
person.relationship <span class="hljs-comment">// Friend</span>

<span class="hljs-keyword">var</span> boss <span class="hljs-operator">=</span> <span class="hljs-built_in">Contact</span>(fullName: <span class="hljs-string">"Ray Wenderlich"</span>,
                   emailAddress: <span class="hljs-string">"ray@raywenderlich.com"</span>,
                   relationship: <span class="hljs-string">"Boss"</span>)                     </pre>
<p class="calibre1">You can choose to specify the <code class="calibre9">relationship</code> if you want to; otherwise, it takes on the value <code class="calibre9">"Friend"</code>.
</p>
<h2 class="segment-chapter1">Computed properties</h2>

<p class="calibre1">Most of the time, properties are stored data, but some properties can just be computed, which means they perform a calculation before returning a value.
</p>
<p class="calibre1">While a stored property can be a constant or a variable, a computed property must be defined as a variable.
</p>
<p class="calibre1">Computed properties must also include a type because the compiler needs to know what to expect as a return value.
</p>
<p class="calibre1">The measurement for a TV is the perfect use case for a computed property:
</p><div class="image2"><img src="images/000068.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The industry definition of the screen size of a TV isn’t the screen’s height or width, but its diagonal measurement:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">TV</span> {
  <span class="hljs-keyword">var</span> height: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">var</span> width: <span class="hljs-built_in">Double</span>
  
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> diagonal: <span class="hljs-built_in">Int</span> {
    <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> (height <span class="hljs-operator">*</span> height <span class="hljs-operator">+</span>
      width <span class="hljs-operator">*</span> width).squareRoot().rounded()
    <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int</span>(result)
  }
}</pre>
<p class="calibre1">Let’s go through this code one step at a time:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">You use an <code class="calibre9">Int</code> type for your <code class="calibre9">diagonal</code> property. Although <code class="calibre9">height</code> and <code class="calibre9">width</code> are <code class="calibre9">Double</code> types, TV sizes are usually advertised as nice, round numbers such as 50” rather than 49.52”. Instead of the usual assignment operator <code class="calibre9">=</code> to assign a value as you would for a stored property, you use curly braces to enclose your computed property’s calculation.
</p></li>

<li class="calibre4">
<p class="calibre1">As you’ve seen before in this book, geometry can be handy; once you have the width and height, you can use the Pythagorean theorem to calculate the diagonal length. You use the <code class="calibre9">rounded</code> method to round the value with the standard rule: If the decimal is 0.5 or above, it rounds up; otherwise, it rounds down.
</p></li>

<li class="calibre4">
<p class="calibre1">Now that you’ve got a properly-rounded number, you return it as an <code class="calibre9">Int</code>. Had you converted <code class="calibre9">result</code> directly to <code class="calibre9">Int</code> without rounding first, the result would have been truncated, so 109.99 would have become 109.
</p></li>
</ol>

<p class="calibre1">Computed properties don’t store any values; they return values based on calculations. From outside of the structure, a computed property can be accessed just like a stored property.
</p>
<p class="calibre1">Test this with the TV size calculation:
</p><pre class="code-block"><span class="hljs-keyword">var</span> tv <span class="hljs-operator">=</span> <span class="hljs-built_in">TV</span>(height: <span class="hljs-number">53.93</span>, width: <span class="hljs-number">95.87</span>)
tv.diagonal <span class="hljs-comment">// 110</span></pre>
<p class="calibre1">You have a 110-inch TV. Let’s say you decide you don’t like the standard movie aspect ratio and would instead prefer a square screen. You cut off some of the screen’s width to make it equivalent to the height:
</p><pre class="code-block">tv.width <span class="hljs-operator">=</span> tv.height
tv.diagonal <span class="hljs-comment">// 76</span></pre>
<p class="calibre1">Now you <i class="calibre2">only</i> have a 76-inch square screen. The computed property automatically provides the new value based on the new width.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Do you have a television or a computer monitor? Measure the height and width, plug it into a <code class="calibre9">TV</code> struct, and see if the diagonal measurement matches what you think it is.
</p>
<h3 class="segment-title2">Getter and setter</h3>

<p class="calibre1">The computed property you wrote in the previous section is called a <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">only computed property</em>. It has a block of code to compute the property’s value, called the <em class="calibre5">getter</em>.
</p>
<p class="calibre1">It’s also possible to create a <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">write computed property</em> with two code blocks: a getter and a <em class="calibre5">setter</em>.
</p>
<p class="calibre1">This setter works differently than you might expect.
</p>
<p class="calibre1">As the computed property has no place to store a value, the setter usually sets one or more related <i class="calibre2">stored</i> properties indirectly:
</p><pre class="code-block"><span class="hljs-keyword">var</span> diagonal: <span class="hljs-built_in">Int</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">get</span> {
    <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> (height <span class="hljs-operator">*</span> height <span class="hljs-operator">+</span>
      width <span class="hljs-operator">*</span> width).squareRoot().rounded()
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int</span>(result)
  }
  <span class="hljs-keyword">set</span> {
    <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">let</span> ratioWidth <span class="hljs-operator">=</span> <span class="hljs-number">16.0</span>
    <span class="hljs-keyword">let</span> ratioHeight <span class="hljs-operator">=</span> <span class="hljs-number">9.0</span>
    <span class="hljs-comment">// 4</span>
    <span class="hljs-keyword">let</span> ratioDiagonal <span class="hljs-operator">=</span> (ratioWidth <span class="hljs-operator">*</span> ratioWidth <span class="hljs-operator">+</span>
      ratioHeight <span class="hljs-operator">*</span> ratioHeight).squareRoot()
    height <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(newValue) <span class="hljs-operator">*</span> ratioHeight <span class="hljs-operator">/</span> ratioDiagonal
    width <span class="hljs-operator">=</span> height <span class="hljs-operator">*</span> ratioWidth <span class="hljs-operator">/</span> ratioHeight
  }
}</pre>
<p class="calibre1">Here’s what’s happening in this code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Because you want to include a setter, you now have to be explicit about which calculations comprise the getter and which the setter, so you surround each code block with curly braces and precede it with either <code class="calibre9">get</code> or <code class="calibre9">set</code>. This specificity isn’t required for read-only computed properties, as their single code block is implicitly a getter.
</p></li>

<li class="calibre4">
<p class="calibre1">You use the same code as before to get the computed value.
</p></li>

<li class="calibre4">
<p class="calibre1">For a setter, you usually have to make some kind of assumption. In this case, you provide a reasonable default value for the screen ratio.
</p></li>
</ol>

<ol start="4" class="calibre11">
<li class="calibre4">
<p class="calibre1">The formulas to calculate height and width, given a diagonal and a ratio, are a bit deep. You could work them out with a bit of time, but I’ve done the dirty work for you and provided them here. The important parts to focus on are:
</p></li>
</ol>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The <code class="calibre9">newValue</code> constant lets you use whatever value was passed in during the assignment.
</p></li>

<li class="calibre4">
<p class="calibre1">Remember, the <code class="calibre9">newValue</code> is an <code class="calibre9">Int</code>, so to use it in a calculation with a <code class="calibre9">Double</code>, you must first convert it to a <code class="calibre9">Double</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Once you’ve done the calculations, you assign the height and width properties of the <code class="calibre9">TV</code> structure.
</p></li>
</ul>

<p class="calibre1">In addition to setting the height and width directly, you can set them <i class="calibre2">indirectly</i> by setting the <code class="calibre9">diagonal</code> computed property. When you set this value, your setter will calculate and store the height and width.
</p>
<p class="calibre1">Notice that there’s no <code class="calibre9">return</code> statement in a setter &mdash; it only modifies the other stored properties. With the setter in place, you have a nice little screen size calculator:
</p><pre class="code-block">tv.diagonal <span class="hljs-operator">=</span> <span class="hljs-number">70</span>
tv.height <span class="hljs-comment">// 34.32...</span>
tv.width <span class="hljs-comment">// 61.01...</span></pre>
<p class="calibre1">Now you can finally figure out the biggest TV you can cram into your cabinet &mdash; you’re so welcome.  :]
</p>
<h2 class="segment-chapter1">Type properties</h2>

<p class="calibre1">In the previous section, you learned how to declare stored and computed properties for instances of a particular type. The properties on your instance of <code class="calibre9">TV</code> are separate from the properties on my instance of <code class="calibre9">TV</code>.
</p>
<p class="calibre1">However, the type <i class="calibre2">itself</i> may also need properties that are common across all instances. These properties are called <em class="calibre5">type properties</em>.
</p>
<p class="calibre1">Imagine you’re building a game with many levels. Each level has a few attributes or stored properties:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Level</span> {
  <span class="hljs-keyword">let</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> boss: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> unlocked: <span class="hljs-built_in">Bool</span>
}

<span class="hljs-keyword">let</span> level1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Level</span>(id: <span class="hljs-number">1</span>, boss: <span class="hljs-string">"Chameleon"</span>, unlocked: <span class="hljs-keyword">true</span>)
<span class="hljs-keyword">let</span> level2 <span class="hljs-operator">=</span> <span class="hljs-built_in">Level</span>(id: <span class="hljs-number">2</span>, boss: <span class="hljs-string">"Squid"</span>, unlocked: <span class="hljs-keyword">false</span>)
<span class="hljs-keyword">let</span> level3 <span class="hljs-operator">=</span> <span class="hljs-built_in">Level</span>(id: <span class="hljs-number">3</span>, boss: <span class="hljs-string">"Chupacabra"</span>, unlocked: <span class="hljs-keyword">false</span>)
<span class="hljs-keyword">let</span> level4 <span class="hljs-operator">=</span> <span class="hljs-built_in">Level</span>(id: <span class="hljs-number">4</span>, boss: <span class="hljs-string">"Yeti"</span>, unlocked: <span class="hljs-keyword">false</span>)</pre>
<p class="calibre1">You can use a type property to store the game’s progress as the player unlocks each level. A type property is declared with the modifier <code class="calibre9">static</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Level</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> highestLevel <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> boss: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> unlocked: <span class="hljs-built_in">Bool</span>
}</pre>
<p class="calibre1">Here, <code class="calibre9">highestLevel</code> is a property on <code class="calibre9">Level</code> itself rather than on the instances. That means you don’t access this property on an instance:
</p><pre class="code-block"><span class="hljs-comment">// Error: you can’t access a type property on an instance</span>
<span class="hljs-keyword">let</span> highestLevel <span class="hljs-operator">=</span> level3.highestLevel</pre>
<p class="calibre1">Instead, you access it on the type itself:
</p><pre class="code-block"><span class="hljs-built_in">Level</span>.highestLevel <span class="hljs-comment">// 1</span></pre>
<p class="calibre1">Using a type property means you can retrieve the same stored property value from anywhere in the code for your app or algorithm. The game’s progress is accessible from any level or any other place in the game, like the main menu.
</p>
<h2 class="segment-chapter1">Property observers</h2>

<p class="calibre1">For your <code class="calibre9">Level</code> implementation, it would be useful to automatically set the <code class="calibre9">highestLevel</code> when the player unlocks a new one. For that, you’ll need a way to listen to property changes. Thankfully, there are a couple of <em class="calibre5">property observers</em> that get called before and after property changes.
</p>
<p class="calibre1">A <code class="calibre9">willSet</code> observer is called when a property is about to be changed while a <code class="calibre9">didSet</code> observer is called after a property has been changed. Their syntax is similar to getters and setters:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Level</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> highestLevel <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> boss: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> unlocked: <span class="hljs-built_in">Bool</span> {
    <span class="hljs-keyword">didSet</span> {
      <span class="hljs-keyword">if</span> unlocked <span class="hljs-operator">&amp;&amp;</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">Self</span>.highestLevel {
        <span class="hljs-keyword">Self</span>.highestLevel <span class="hljs-operator">=</span> id
      }
    }
  }
}</pre>
<p class="calibre1">Now, when the player unlocks a new level, it will update the <code class="calibre9">highestLevel</code> type property if the level is a new high. There are a couple of things to note here:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You <i class="calibre2">can</i> access the value of <code class="calibre9">unlocked</code> from inside the <code class="calibre9">didSet</code> observer. Remember that <code class="calibre9">didSet</code> gets called <i class="calibre2">after</i> the value has been set.
</p></li>

<li class="calibre4">
<p class="calibre1">Even though you’re inside an instance of the type, you still have to access type properties with the type name prefix. You are required to use the full name <code class="calibre9">Level.highestLevel</code> rather than just <code class="calibre9">highestLevel</code> alone to indicate you’re accessing a type property. You can also refer to the static property from within the type as <code class="calibre9">Self.highestLevel</code>.  Using <code class="calibre9">Self</code> here is preferred because even if you change the name of the type to something else &mdash; say, <code class="calibre9">GameLevel</code> &mdash; the code would still work. The uppercase <code class="calibre9">Self</code> indicates you’re accessing a property on the type itself, not an instance property.
</p></li>
</ul>

<p class="calibre1"><code class="calibre9">willSet</code> and <code class="calibre9">didSet</code> observers are only available for stored properties. If you want to listen for changes to a computed property, simply add the relevant code to the property’s setter.
</p>
<p class="calibre1">Also, keep in mind that the <code class="calibre9">willSet</code> and <code class="calibre9">didSet</code> observers are <i class="calibre2">not</i> called when a property is set during initialization; they only get called when you assign a new value to a fully initialized instance. That means property observers are only useful for variable properties since constant properties are only set during initialization. Select between <code class="calibre9">var</code> and <code class="calibre9">let</code> accordingly to match your needs.
</p>
<h3 class="segment-title2">Limiting a variable</h3>

<p class="calibre1">You can also use property observers to limit the value of a variable. Say you had a light bulb that could only support a maximum current flowing through its filament.
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">LightBulb</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> maxCurrent <span class="hljs-operator">=</span> <span class="hljs-number">40</span>
  <span class="hljs-keyword">var</span> current <span class="hljs-operator">=</span> <span class="hljs-number">0</span> {
    <span class="hljs-keyword">didSet</span> {
      <span class="hljs-keyword">if</span> current <span class="hljs-operator">&gt;</span> <span class="hljs-built_in">LightBulb</span>.maxCurrent {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"""
              Current is too high,
              falling back to previous setting.
              """</span>)
        current <span class="hljs-operator">=</span> oldValue
      }
    }
  }
}</pre>
<p class="calibre1">In this example, if the current flowing into the bulb exceeds the maximum value, it will revert to its last successful value. Notice there’s a helpful <code class="calibre9">oldValue</code> constant available in <code class="calibre9">didSet</code> to access the previous value.
</p>
<p class="calibre1">Give it a try:
</p><pre class="code-block"><span class="hljs-keyword">var</span> light <span class="hljs-operator">=</span> <span class="hljs-built_in">LightBulb</span>()
light.current <span class="hljs-operator">=</span> <span class="hljs-number">50</span>
light.current <span class="hljs-comment">// 0</span>
light.current <span class="hljs-operator">=</span> <span class="hljs-number">40</span>
light.current <span class="hljs-comment">// 40</span></pre>
<p class="calibre1">You try to set the light bulb to 50 amps, but the bulb rejected that input. Pretty cool!
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> Do not confuse property observers with getters and setters. A stored property can have a <code class="calibre9">didSet</code> and a <code class="calibre9">willSet</code> observer. A computed property has a getter and optionally a setter. These, even though the syntax is similar, are entirely different concepts!
</p></div>

<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">In the light bulb example, the bulb goes back to a successful setting if the current gets too high. In real life, that wouldn’t work, and the bulb would burn out!Your task is to rewrite the structure so that the bulb turns off before the current burns it out.
</p>
<p class="calibre1">Hint: You’ll need to use the <code class="calibre9">willSet</code> observer that gets called before value is changed. The value that is about to be set is available in the constant <code class="calibre9">newValue</code>. The trick is that you can’t change this <code class="calibre9">newValue</code>, and it will still be set, so you’ll have to go beyond adding a <code class="calibre9">willSet</code> observer. :]
</p>
<h2 class="segment-chapter1">Lazy properties</h2>

<p class="calibre1">If you have a property that might take some time to calculate, you don’t want to slow things down until you need the property. Say hello to the <em class="calibre5">lazy stored property</em>. It is useful for such things as downloading a user’s profile picture or making a serious calculation.
</p>
<p class="calibre1">Look at this example of a <code class="calibre9">Circle</code> structure that uses pi in its circumference calculation:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Circle</span> {
  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> pi <span class="hljs-operator">=</span> {
    ((<span class="hljs-number">4.0</span> <span class="hljs-operator">*</span> atan(<span class="hljs-number">1.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">5.0</span>)) <span class="hljs-operator">-</span> atan(<span class="hljs-number">1.0</span> <span class="hljs-operator">/</span> <span class="hljs-number">239.0</span>)) <span class="hljs-operator">*</span> <span class="hljs-number">4.0</span>
  }()
  <span class="hljs-keyword">var</span> radius <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>
  <span class="hljs-keyword">var</span> circumference: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> {
      pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> <span class="hljs-number">2</span>
    }
  }
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">radius</span>: <span class="hljs-built_in">Double</span>) {
    <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius
  }
}</pre>
<p class="calibre1">Here, you’re not trusting the value of pi available to you from the standard library; you want to calculate it yourself.
</p><div class="image3"><img src="images/000078.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can create a new <code class="calibre9">Circle</code> with its initializer, and the pi calculation won’t run yet:
</p><pre class="code-block"><span class="hljs-keyword">var</span> circle <span class="hljs-operator">=</span> <span class="hljs-built_in">Circle</span>(radius: <span class="hljs-number">5</span>) <span class="hljs-comment">// got a circle, pi has not been run</span></pre>
<p class="calibre1">The calculation of <code class="calibre9">pi</code> defers until you need it. Only when you ask for the circumference property is <code class="calibre9">pi</code> calculated and assigned a value.
</p><pre class="code-block">circle.circumference <span class="hljs-comment">// 31.42</span>
<span class="hljs-comment">// also, pi now has a value</span></pre>
<p class="calibre1">Since you’ve got eagle eyes, you’ve noticed that <code class="calibre9">pi</code> uses a <code class="calibre9">{ }()</code> self-executing closure pattern to calculate its value, even though it’s a stored property. The trailing parentheses execute the code inside the closure curly braces immediately. But since <code class="calibre9">pi</code> is marked as <code class="calibre9">lazy</code>, this calculation is postponed until the first time you access the property.
</p>
<p class="calibre1">For comparison, <code class="calibre9">circumference</code> is a computed property and is calculated every time it’s accessed. You expect the circumference’s value to change if the radius changes. <code class="calibre9">pi</code>, as a lazy stored property, is only calculated the first time. That’s great because who wants to calculate the same thing over and over again?
</p>
<p class="calibre1">The lazy property must be a variable, defined with <code class="calibre9">var</code>, instead of a constant defined with <code class="calibre9">let</code>. When you first initialize the structure, the property effectively has no value. Then when some part of your code requests the property, its value will be calculated. So even though the value only changes once, you still use <code class="calibre9">var</code>.
</p>
<p class="calibre1">Here are two more advanced features of the code:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Since the value of <code class="calibre9">pi</code> changes, the <code class="calibre9">circumference</code> getter must be marked as <code class="calibre9">mutating</code>. Accessing the value of <code class="calibre9">pi</code> changes the value of the structure.
</p></li>

<li class="calibre4">
<p class="calibre1">Since <code class="calibre9">pi</code> is a stored property of the structure, you need a custom initializer to use only the <code class="calibre9">radius</code>. Remember, the automatic initializer of a structure includes all of the stored properties.
</p></li>
</ul>

<p class="calibre1">Don’t worry about those advanced features too much for now. You’ll learn more about both the <code class="calibre9">mutating</code> keyword and custom initializers in Chapter 12, “Methods”. The important part to wrap your mind around is how the <code class="calibre9">lazy</code> stored property works. The rest of the details are window dressing that you’ll get more comfortable with in time.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The <code class="calibre9">lazy</code> keyword is a <i class="calibre2">property wrapper</i>. Since <code class="calibre9">lazy</code> is common and has been in use for many years, it is afforded the luxury of omitting the <code class="calibre9">@</code> symbol that usually prefixes property wrappers. When you build apps with SwiftUI, you will see many other property wrappers, like <code class="calibre9">@State</code>, <code class="calibre9">@Binding</code>, and <code class="calibre9">@EnvironmentObject</code>. Property wrappers allow you to generalize behavior so that you can write complex logic once and re-use it. Any property that is declared as <code class="calibre9">lazy</code> will use the behavior defined in the property wrapper definition. To understand the underlying mechanics of property wrappers, you’ll first need to learn more Swift language features. You’ll see them again in Chapter 26, “Property Wrappers”.
</p></div>

<h3 class="segment-title2">Mini-exercises</h3>

<p class="calibre1">Of course, you should trust the value of pi from the standard library. It’s a type property, and you can access it as <code class="calibre9">Double.pi</code>. Given the <code class="calibre9">Circle</code> example above:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Remove the lazy stored property <code class="calibre9">pi</code>. Use the value of pi from the Swift standard library instead.
</p></li>

<li class="calibre4">
<p class="calibre1">Remove the initializer. Since <code class="calibre9">radius</code> is the only stored property now, you can rely on the automatically included initializer.
</p></li>
</ol>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of properties. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Ice Cream</h3>

<p class="calibre1">Rewrite the <code class="calibre9">IceCream</code> structure below to use default values and lazy initialization:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">IceCream</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> ingredients: [<span class="hljs-built_in">String</span>]
}</pre>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Use default values for the properties.
</p></li>

<li class="calibre4">
<p class="calibre1">Lazily initialize the <code class="calibre9">ingredients</code> array.
</p></li>
</ol>

<h3 class="segment-title2">Challenge 2: Car and Fuel Tank</h3>

<p class="calibre1">At the beginning of the chapter, you saw a <code class="calibre9">Car</code> structure. Dive into the inner workings of the car and rewrite the <code class="calibre9">FuelTank</code> structure below with property observer functionality:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">FuelTank</span> {
  <span class="hljs-keyword">var</span> level: <span class="hljs-built_in">Double</span> <span class="hljs-comment">// decimal percentage between 0 and 1</span>
}</pre>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Add a <code class="calibre9">lowFuel</code> stored property of Boolean type to the structure.
</p></li>

<li class="calibre4">
<p class="calibre1">Flip the <code class="calibre9">lowFuel</code> Boolean when the <code class="calibre9">level</code> drops below 10%.
</p></li>

<li class="calibre4">
<p class="calibre1">Ensure that when the tank fills back up, the <code class="calibre9">lowFuel</code> warning will turn off.
</p></li>

<li class="calibre4">
<p class="calibre1">Set the <code class="calibre9">level</code> to a minimum of <code class="calibre9">0</code> or a maximum of <code class="calibre9">1</code> if it gets set above or below the expected values.
</p></li>

<li class="calibre4">
<p class="calibre1">Add a <code class="calibre9">FuelTank</code> property to <code class="calibre9">Car</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Properties</em> are variables and constants that are part of a named type.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Stored properties</em> allocate memory to store a value.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Computed properties</em> are calculated each time your code requests them and aren’t stored as a value in memory.
</p></li>

<li class="calibre4">
<p class="calibre1">The <em class="calibre5">static</em> modifier marks a <em class="calibre5">type property</em> that’s universal to all instances of a particular type.
</p></li>

<li class="calibre4">
<p class="calibre1">The <em class="calibre5">lazy</em> modifier prevents a value of a stored property from being calculated until your code uses it for the first time. You’ll want to use <em class="calibre5">lazy initialization</em> when a property’s initial value is computationally intensive or when you won’t know the initial value of a property until after you’ve initialized the object.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-28">


<h1 class="segment-chapter">Chapter 12: Methods</h1>

<p class="calibre1">In Chapter 11, “Properties”, you learned about properties, which are constants and variables that are part of structures. <em class="calibre5">Methods</em>, as you’ve already seen, are functions that reside inside a structure.
</p>
<p class="calibre1">In this chapter, you’ll take a closer look at methods and initializers. As with properties, you’ll begin to design more complex structures. The things you learn in this chapter will apply to methods across all named types, including classes and enumerations, which you’ll see in later chapters.
</p>
<h2 class="segment-chapter1">Method refresher</h2>

<p class="calibre1">Remember <code class="calibre9">Array.removeLast()</code>? It pops the last item off an instance of an array:
</p><pre class="code-block"><span class="hljs-keyword">var</span> numbers <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
numbers.removeLast()
numbers <span class="hljs-comment">// [1, 2]</span></pre><div class="image3"><img src="images/000100.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Methods like <code class="calibre9">removeLast()</code> help you control the data in the structure.
</p>
<h3 class="segment-title2">Comparing methods to computed properties</h3>

<p class="calibre1">With computed properties, you saw in Chapter 11, “Properties”, that you could run code from inside a structure. That sounds a lot like a method. What’s the difference? It comes down to a matter of style, but there are a few helpful thoughts to help you decide. Properties hold values that you can get and set while methods perform work. Sometimes this distinction gets fuzzy when a method’s sole purpose is to return a single value.
</p><div class="image8"><img src="images/000111.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Ask yourself whether you want to be able to set a value as well as get the value. A computed property can have a setter component inside to write values. Another question to consider is whether the calculation requires extensive computation or reads from a database. Even for a simple value, a method helps you indicate to future developers that the call is expensive in time and computational resources. If the call is cheap (as in constant time O(1)), stick with a computed property.
</p>
<h3 class="segment-title2">Turning a function into a method</h3>

<p class="calibre1">To explore methods and initializers, you will create a simple model for dates called <code class="calibre9">SimpleDate</code>.  Be aware that Apple’s <code class="calibre9">Foundation</code> framework contains a robust, production-ready <code class="calibre9">Date</code> class that correctly handles all of the subtle intricacies of dealing with dates and times. For learning purposes, though, we’ll explore how you might construct <code class="calibre9">SimpleDate</code> to be useful in many contexts.
</p>
<p class="calibre1">In the code below, how could you convert <code class="calibre9">monthsUntilWinterBreak(date:)</code> into a method?
</p><pre class="code-block"><span class="hljs-keyword">let</span> months <span class="hljs-operator">=</span> [<span class="hljs-string">"January"</span>, <span class="hljs-string">"February"</span>, <span class="hljs-string">"March"</span>,
              <span class="hljs-string">"April"</span>, <span class="hljs-string">"May"</span>, <span class="hljs-string">"June"</span>,
              <span class="hljs-string">"July"</span>, <span class="hljs-string">"August"</span>, <span class="hljs-string">"September"</span>,
              <span class="hljs-string">"October"</span>, <span class="hljs-string">"November"</span>, <span class="hljs-string">"December"</span>]

<span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">var</span> month: <span class="hljs-built_in">String</span>
}

<span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">date</span>: <span class="hljs-built_in">SimpleDate</span>) -&gt; <span class="hljs-built_in">Int</span> {
  months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
  months.firstIndex(of: date.month)<span class="hljs-operator">!</span>
}</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: This example is fragile because it force unwraps an index that might not be valid. You would not want to do this in production code. Also, if you live in the southern hemisphere, you might be disappointed with the result since the winter season starts in June. Dealing with time is hard. :]
</p></div>

<p class="calibre1">Making a method is as easy as moving the function inside the structure definition:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">var</span> month: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">date</span>: <span class="hljs-built_in">SimpleDate</span>) -&gt; <span class="hljs-built_in">Int</span> {
    months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
    months.firstIndex(of: date.month)<span class="hljs-operator">!</span>
  }
}</pre>
<p class="calibre1">There’s no identifying keyword for a method; it is just a function inside a named type. You call methods on an instance using dot syntax just as you do for properties:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"October"</span>)
date.monthsUntilWinterBreak(from: date) <span class="hljs-comment">// 2</span></pre>
<p class="calibre1">And just like properties, as soon as you start typing a method name, Xcode will provide suggestions. You can select one with the Up and Down arrow keys on your keyboard, and you can autocomplete the call by pressing Tab:
</p><div class="image"><img src="images/000121.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">If you think about this code for a minute, you’ll realize that the method’s definition is awkward. There must be an alternative for accessing content stored by the instance instead of passing the instance itself as a parameter to the method. It would be so much nicer to call this:
</p><pre class="code-block">date.monthsUntilWinterBreak() <span class="hljs-comment">// Error!</span></pre>
<h2 class="segment-chapter1">Introducing self</h2>

<p class="calibre1">You already saw <code class="calibre9">Self</code> (spelled with an uppercase S) in Chapter 11, “Properties”, as a way to access static properties from inside a struct.  Now we look at lowercase <code class="calibre9">self</code>. A structure definition (uppercase first letter) is like a blueprint, whereas an instance (lowercase first letter) is a real object. To access the value of an <i class="calibre2">instance</i>, you use the keyword <em class="calibre5">self</em> inside the structure. The Swift compiler passes it into your method as a secret parameter.
</p>
<p class="calibre1">The method definition transforms into this:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>() -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-comment">// 2</span>
  months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
    months.firstIndex(of: <span class="hljs-keyword">self</span>.month)<span class="hljs-operator">!</span>
}</pre>
<p class="calibre1">Here’s what changed:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Now, there’s no parameter in the method definition.
</p></li>

<li class="calibre4">
<p class="calibre1">In the implementation, <code class="calibre9">self</code> replaces the old parameter name.
</p></li>
</ol>

<p class="calibre1">You can now call the method without passing a parameter:
</p><pre class="code-block">date.monthsUntilWinterBreak() <span class="hljs-comment">// 2</span></pre>
<p class="calibre1">That’s looking a lot cleaner! One more thing you can do to simplify the code is to remove <code class="calibre9">self.</code>. …and you’re saying to yourself, “But you just told me to add it!”
</p>
<p class="calibre1"><code class="calibre9">self</code> is your reference to the instance, but most of the time, you don’t need to use it because Swift understands your intent if you just use a variable name. While you can always use <code class="calibre9">self</code> to access the properties and methods of the current instance, most of the time, you don’t need to. In <code class="calibre9">monthsUntilWinterBreak()</code>, you can just say <code class="calibre9">month</code> instead of <code class="calibre9">self.month</code>:
</p><pre class="code-block">months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
  months.firstIndex(of: month)<span class="hljs-operator">!</span></pre>
<p class="calibre1">Most programmers use <code class="calibre9">self</code> only when required, such as disambiguating between a local variable and a property with the same name. You’ll get more practice using <code class="calibre9">self</code> a little later.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Since <code class="calibre9">monthsUntilWinterBreak()</code> returns a single value and there’s not much calculation involved, transform the method into a computed property with a getter component.
</p>
<h2 class="segment-chapter1">Introducing initializers</h2>

<p class="calibre1">You learned about initializers in Chapter 10, “Structures”, and Chapter 11, “Properties”, but let’s look at them again with your newfound knowledge of methods.
</p>
<p class="calibre1">Initializers are special methods you call to create a new instance. They omit the <code class="calibre9">func</code> keyword and even a name, and instead, they use <code class="calibre9">init</code>. An initializer can have parameters, but it doesn’t have to.
</p>
<p class="calibre1">Right now, when you create a new instance of the <code class="calibre9">SimpleDate</code> structure, you have to specify a value for the <code class="calibre9">month</code> property:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"October"</span>)</pre>
<p class="calibre1">You might find it more efficient to have a handy no-parameter initializer. An empty initializer would create a new <code class="calibre9">SimpleDate</code> instance with a reasonable default value:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>() <span class="hljs-comment">// Error!</span></pre>
<p class="calibre1">While the compiler gives you an error now, you can provide the no-parameter initializer. By implementing <code class="calibre9">init</code>, you can create the most straightforward path to initialization with default values.
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">var</span> month: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>() {
    month <span class="hljs-operator">=</span> <span class="hljs-string">"January"</span>
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>() -&gt; <span class="hljs-built_in">Int</span> {
    months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
      months.firstIndex(of: month)<span class="hljs-operator">!</span>
  }
}</pre>
<p class="calibre1">Here’s what’s happening in that code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The <code class="calibre9">init()</code> definition requires neither the <code class="calibre9">func</code> keyword nor a name. You always use the name of the type to call an initializer.
</p></li>

<li class="calibre4">
<p class="calibre1">Like a function, an initializer must have a parameter list, even if it is empty.
</p></li>

<li class="calibre4">
<p class="calibre1">In the initializer, you assign values for all the stored properties of a structure.
</p></li>

<li class="calibre4">
<p class="calibre1">An initializer never returns a value. Its task is solely to initialize a new instance.
</p></li>
</ol>

<p class="calibre1">When you create even one custom initializer, you forgo the option to use the automatic  <em class="calibre5">memberwise initializer</em>. So this code doesn’t work right now:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"October"</span>) <span class="hljs-comment">// Error!</span></pre>
<p class="calibre1">For now, comment out that code. Click somewhere in that line and press <em class="calibre5">Command</em><em class="calibre5">-</em><em class="calibre5">/</em> to comment it out. You’ll add the memberwise initalizer back in soon.
</p>
<p class="calibre1">For now, use your new simple, empty initializer to create an instance:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>()
date.month <span class="hljs-comment">// January</span>
date.monthsUntilWinterBreak() <span class="hljs-comment">// 11</span></pre>
<p class="calibre1">You can test a change to the value in the initializer:
</p><pre class="code-block"><span class="hljs-keyword">init</span>() {
  month <span class="hljs-operator">=</span> <span class="hljs-string">"March"</span>
}</pre>
<p class="calibre1">The value of <code class="calibre9">monthsUntilWinterBreak()</code> will change accordingly:
</p><pre class="code-block"><span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>()
date.month <span class="hljs-comment">// March</span>
date.monthsUntilWinterBreak() <span class="hljs-comment">// 9</span></pre>
<p class="calibre1">As you think about the implementation, a good user experience optimization would have the initializer use a default value based on today’s date.
</p>
<p class="calibre1">In the future, you’ll be capable of retrieving the current date.  Eventually, you’ll use the <code class="calibre9">Date</code> class from the <code class="calibre9">Foundation</code> framework to work with dates.
</p>
<p class="calibre1">Before you get carried away with all the power that these frameworks provide, let’s continue implementing your own <code class="calibre9">SimpleDate</code> type from the ground up.
</p>
<h3 class="segment-title2">Initializers in structures</h3>

<p class="calibre1">Add a <code class="calibre9">day</code> property to <code class="calibre9">SimpleDate</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">var</span> month: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> day: <span class="hljs-built_in">Int</span>
  
  <span class="hljs-keyword">init</span>() {
    month <span class="hljs-operator">=</span> <span class="hljs-string">"January"</span>
    day <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>() -&gt; <span class="hljs-built_in">Int</span> {
    months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
    months.firstIndex(of: month)<span class="hljs-operator">!</span>
  }
}</pre>
<p class="calibre1">Since initializers ensure all properties are set before the instance is ready to use, you have to set <code class="calibre9">day</code> inside <code class="calibre9">init()</code>. If you tried to create an initializer without setting the <code class="calibre9">day</code> property, the compiler would complain.
</p>
<p class="calibre1">Recall that the auto-generated memberwise initializer accepts all the properties as parameters, such as <code class="calibre9">init(month:day:)</code>, for the <code class="calibre9">SimpleDate</code> structure. However, when you add a custom initializer, the compiler always scraps the one created automatically.
</p>
<p class="calibre1">So this code won’t work right now:
</p><pre class="code-block"><span class="hljs-keyword">let</span> valentinesDay <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"February"</span>,
                               day: <span class="hljs-number">14</span>) <span class="hljs-comment">// Error!</span></pre>
<p class="calibre1">Instead, you’ll have to define your own initializer with parameters. Add it right below the empty parameter list <code class="calibre9">init()</code>:
</p><pre class="code-block"><span class="hljs-keyword">init</span>(<span class="hljs-built_in">month</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">day</span>: <span class="hljs-built_in">Int</span>) {
  <span class="hljs-keyword">self</span>.month <span class="hljs-operator">=</span> month
  <span class="hljs-keyword">self</span>.day <span class="hljs-operator">=</span> day
}</pre>
<p class="calibre1">In that code, you assign the incoming parameters to the properties of the structure. Notice how <code class="calibre9">self</code> is used to tell the compiler that you’re referring to the property rather than the local parameter.
</p>
<p class="calibre1"><code class="calibre9">self</code> wasn’t necessary in the simple initializer:
</p><pre class="code-block"><span class="hljs-keyword">init</span>() {
  month <span class="hljs-operator">=</span> <span class="hljs-string">"January"</span>
  day <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
}</pre>
<p class="calibre1">In that code, there aren’t any parameters with the same names as the properties. Therefore, <code class="calibre9">self</code> isn’t necessary for the compiler to understand you’re referring to properties.
</p>
<p class="calibre1">With the complex initializer in place, you can call the new initializer the same way you used to call the automatically generated initializer:
</p><pre class="code-block"><span class="hljs-keyword">let</span> valentinesDay <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"February"</span>, day: <span class="hljs-number">14</span>)
valentinesDay.month <span class="hljs-comment">// February</span>
valentinesDay.day <span class="hljs-comment">// 14</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Xcode 13 give you a shortcut
</p></div>

<h3 class="segment-title2">Default values and initializers</h3>

<p class="calibre1">There is a more straightforward way to make a no-argument initializer.
</p>
<p class="calibre1">When you set default values for parameters, the automatic memberwise initializer will use them.
</p>
<p class="calibre1">In your structure, remove both initializers and then add default values for <code class="calibre9">month</code> and <code class="calibre9">day</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> month <span class="hljs-operator">=</span> <span class="hljs-string">"January"</span>
  <span class="hljs-keyword">var</span> day <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  
  <span class="hljs-comment">//2</span>
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>() -&gt; <span class="hljs-built_in">Int</span> {
    months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
    months.firstIndex(of: month)<span class="hljs-operator">!</span>
  }
}</pre>
<p class="calibre1">Here’s what’s happening in that code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Both properties now have an assignment with a reasonable default value: January 1st.
</p></li>

<li class="calibre4">
<p class="calibre1">Both initializers, <code class="calibre9">init()</code> and <code class="calibre9">init(month:day:)</code> have been removed. …Look ma’, no initializers!
</p></li>
</ol>

<p class="calibre1">Even though the initalizers are gone, you can still use both initializer styles:
</p><pre class="code-block"><span class="hljs-keyword">let</span> newYearsDay <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>()
newYearsDay.month <span class="hljs-comment">// January</span>
newYearsDay.day <span class="hljs-comment">// 1</span>

<span class="hljs-keyword">let</span> valentinesDay <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"February"</span>, day: <span class="hljs-number">14</span>)
valentinesDay.month <span class="hljs-comment">// February</span>
valentinesDay.day <span class="hljs-comment">// 14</span></pre>
<p class="calibre1">What’s happening is that the automatic memberwise initializer is available since you didn’t declare any custom initializers. It provides <code class="calibre9">init(month:day)</code> for you since those parameters are the properties. However, it is also smart enough to realize that the properties have default values when declared and therefore do not need to be passed into the initializer. So that is how you get <code class="calibre9">init()</code> as well. What’s cool is that you can also mix and match, passing only the properties that you care to set:
</p><pre class="code-block"><span class="hljs-keyword">let</span> octoberFirst <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"October"</span>)
octoberFirst.month <span class="hljs-comment">// October</span>
octoberFirst.day <span class="hljs-comment">// 1</span>

<span class="hljs-keyword">let</span> januaryTwentySecond <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(day: <span class="hljs-number">22</span>)
januaryTwentySecond.month <span class="hljs-comment">// January</span>
januaryTwentySecond.day <span class="hljs-comment">// 22</span></pre>
<p class="calibre1">In that code, you only passed the  <code class="calibre9">month</code> into the first instance and only the <code class="calibre9">day</code> into the second instance. Pretty slick, eh!
</p>
<h2 class="segment-chapter1">Introducing mutating methods</h2>

<p class="calibre1">Methods in structures cannot change the values of the instance without being marked as <code class="calibre9">mutating</code>. You can imagine a method in the <code class="calibre9">SimpleDate</code> structure that advances to the next day:
</p><pre class="code-block"><span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-number">advance</span>() {
  day <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
}</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The implementation above is a naive way of writing <code class="calibre9">advance()</code> because it doesn’t account for what happens at the end of a month. In a challenge at the end of this chapter, you’ll create a more robust version.
</p></div>

<p class="calibre1">The <code class="calibre9">mutating</code> keyword marks a method that changes a structure’s value. Since a structure is a value type, the system copies it each time it’s passed around an app. If a method changes the value of one of the properties, then the original instance and the copied instance will no longer be equivalent.
</p>
<p class="calibre1">By marking a method as <code class="calibre9">mutating</code>, you’re also telling the Swift compiler this method must not be called on constants. This is how Swift knows which methods to allow and which to reject at compile time. If you call a mutating method on a constant instance of a structure, the compiler will flag it as an error that must be corrected before you can run your program.
</p>
<p class="calibre1">For mutating methods, Swift secretly passes in <code class="calibre9">self</code> just like it did for normal methods. But for mutating methods, the secret <code class="calibre9">self</code> gets marked as an <code class="calibre9">inout</code> parameter. Whatever happens inside the mutating method will impact everything that relies on the type externally.
</p>
<h2 class="segment-chapter1">Type methods</h2>

<p class="calibre1">Like type properties, you can use <em class="calibre5">type methods</em> to access data across all instances. You call type methods on the type itself instead of on an instance. To define a type method, you prefix it with the <code class="calibre9">static</code> modifier.
</p>
<p class="calibre1">Type methods are useful for things that are <i class="calibre2">about</i> a type in general, rather than something about specific instances.
</p>
<p class="calibre1">For example, you could use type methods to group similar methods into a structure:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Math</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">factorial</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
    <span class="hljs-comment">// 2</span>
    (<span class="hljs-number">1</span><span class="hljs-operator">...</span>number).reduce(<span class="hljs-number">1</span>, <span class="hljs-operator">*</span>)
  }
}
<span class="hljs-comment">// 3</span>
<span class="hljs-built_in">Math</span>.factorial(of: <span class="hljs-number">6</span>) <span class="hljs-comment">// 720</span></pre>
<p class="calibre1">You might have custom calculations for things such as factorial. Instead of having many free-standing functions, you can group related functions as type methods in a structure. The structure is said to act as a <em class="calibre5">namespace</em>.
</p>
<p class="calibre1">Here’s what’s happening:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">You use <code class="calibre9">static</code> to declare the type method, which accepts an integer and returns an integer.
</p></li>

<li class="calibre4">
<p class="calibre1">The implementation uses a higher-order function called <code class="calibre9">reduce(_:_:)</code>. It effectively follows the formula for calculating a factorial: “The product of all the whole numbers from 1 to n”. You could write this using a <code class="calibre9">for</code> loop, but the higher-order function expresses your intent in a cleaner way.
</p></li>

<li class="calibre4">
<p class="calibre1">You call the type method on <code class="calibre9">Math</code> rather than on an instance of the type.
</p></li>
</ol>
<div class="image3"><img src="images/000043.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Type methods gathered into a structure will advantageously code complete in Xcode. In this example, you can see all the math utility methods available to you by typing <code class="calibre9">Math.</code>.
</p><div class="image2"><img src="images/000034.png" alt="" title="" class="calibre7" /></div>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Add a type method to the <code class="calibre9">Math</code> structure that calculates the <i class="calibre2">n</i>-th triangle number. It will be very similar to the factorial formula, except instead of multiplying the numbers, you add them.
</p>
<h2 class="segment-chapter1">Adding to an existing structure with extensions</h2>

<p class="calibre1">Sometimes you want to add functionality to a structure but don’t want to muddy up the original definition. And sometimes, you can’t add the functionality because you don’t have access to the source code.
</p>
<p class="calibre1">It is possible to <i class="calibre2">open</i> an existing structure (even one you do not have the source code for) and add methods, initializers and computed properties to it. This can be useful for code organization and is discussed in greater detail in Chapter 18, “Access Control, Code Organization &amp; Testing”. Doing so is as easy as using the keyword, <code class="calibre9">extension</code>.
</p>
<p class="calibre1">At the bottom of your playground, outside the definition of <code class="calibre9">Math</code>, add this type method named <code class="calibre9">primeFactors(of:)</code> using an extension:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Math</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">primeFactors</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) -&gt; [<span class="hljs-built_in">Int</span>] {
    <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">var</span> remainingValue <span class="hljs-operator">=</span> value
    <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">var</span> testFactor <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">var</span> primes: [<span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> []
    <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">while</span> testFactor <span class="hljs-operator">*</span> testFactor <span class="hljs-operator">&lt;=</span> remainingValue {
      <span class="hljs-keyword">if</span> remainingValue <span class="hljs-operator">%</span> testFactor <span class="hljs-operator">==</span> <span class="hljs-number">0</span> {
        primes.append(testFactor)
        remainingValue <span class="hljs-operator">/=</span> testFactor
      }
      <span class="hljs-keyword">else</span> {
        testFactor <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
      }
    }
    <span class="hljs-keyword">if</span> remainingValue <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> {
      primes.append(remainingValue)
    }
    <span class="hljs-keyword">return</span> primes
  }
}</pre>
<p class="calibre1">This method finds the prime factors for a given number. For example, 81 returns <code class="calibre9">[3, 3, 3, 3]</code>. Here’s what’s happening in the code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The <code class="calibre9">value</code> passed in as a parameter is assigned to the mutable variable, <code class="calibre9">remainingValue</code>, so that it can be changed as the calculation runs.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">testFactor</code> starts as two and will be divided into <code class="calibre9">remainingValue</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">The logic runs a loop until the <code class="calibre9">remainingValue</code> is exhausted. If it evenly divides, meaning there’s no remainder, that value of the <code class="calibre9">testFactor</code> is set aside as a prime factor. If it doesn’t evenly divide, <code class="calibre9">testFactor</code> is incremented for the next loop.
</p></li>
</ol>

<p class="calibre1">This algorithm is a brute force one but does contain one optimization: the square of the <code class="calibre9">testFactor</code> should never be larger than the <code class="calibre9">remainingValue</code>. If it is, the <code class="calibre9">remainingValue</code> itself must be prime and added to the <code class="calibre9">primes</code> list.
</p>
<p class="calibre1">You’ve now added a method to <code class="calibre9">Math</code> without changing its original definition. Verify that the extension works with this code:
</p><pre class="code-block"><span class="hljs-built_in">Math</span>.primeFactors(of: <span class="hljs-number">81</span>) <span class="hljs-comment">// [3, 3, 3, 3]</span></pre>
<p class="calibre1">Pretty slick! You’re about to see how that can be powerful in practice.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> In an extension, you cannot add stored properties to an existing structure because that would change the size and memory layout of the structure and break existing code.
</p></div>

<h3 class="segment-title2">Keeping the compiler-generated initializer using extensions</h3>

<p class="calibre1">With the <code class="calibre9">SimpleDate</code> structure, you saw that once you added your own <code class="calibre9">init()</code>, the compiler-generated memberwise initializer disappeared. It turns out that you can keep both if you add your <code class="calibre9">init()</code> to an extension to <code class="calibre9">SimpleDate</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">var</span> month <span class="hljs-operator">=</span> <span class="hljs-string">"January"</span>
  <span class="hljs-keyword">var</span> day <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>() -&gt; <span class="hljs-built_in">Int</span> {
    months.firstIndex(of: <span class="hljs-string">"December"</span>)<span class="hljs-operator">!</span> <span class="hljs-operator">-</span>
    months.firstIndex(of: month)<span class="hljs-operator">!</span>
  }
  
  <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-number">advance</span>() {
    day <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
  }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">SimpleDate</span> {
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">month</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">day</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">self</span>.month <span class="hljs-operator">=</span> months[month<span class="hljs-operator">-</span><span class="hljs-number">1</span>]
    <span class="hljs-keyword">self</span>.day <span class="hljs-operator">=</span> day
  }
}</pre>
<p class="calibre1"><code class="calibre9">init(month:day:)</code> gets added to <code class="calibre9">SimpleDate</code> without sacrificing the automatically generated memberwise initializer. You can create an instance using the month index <code class="calibre9">Int</code> instead of the month name <code class="calibre9">String</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> halloween <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-number">10</span>, day: <span class="hljs-number">31</span>)
halloween.month <span class="hljs-comment">// October</span>
halloween.day <span class="hljs-comment">// 31</span></pre>
<p class="calibre1">Hooray!
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of methods. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Grow a Circle</h3>

<p class="calibre1">Given the <code class="calibre9">Circle</code> structure below:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Circle</span> {
  
  <span class="hljs-keyword">var</span> radius <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>

  <span class="hljs-keyword">var</span> area: <span class="hljs-built_in">Double</span> {
    .pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> radius
  }

}</pre>
<p class="calibre1">Write a method that can change an instance’s area by a growth factor. For example, if you call <code class="calibre9">circle.grow(byFactor: 3)</code>, the area of the instance will triple.
</p>
<p class="calibre1"><em class="calibre5">Hint:</em> Add a setter to <code class="calibre9">area</code>.
</p>
<h3 class="segment-title2">Challenge 2: A more advanced <code class="calibre12">advance()</code></h3>

<p class="calibre1">Here is a naïve way of writing <code class="calibre9">advance()</code> for the <code class="calibre9">SimpleDate</code> structure you saw earlier in the chapter:
</p><pre class="code-block"><span class="hljs-keyword">let</span> months <span class="hljs-operator">=</span> [<span class="hljs-string">"January"</span>, <span class="hljs-string">"February"</span>, <span class="hljs-string">"March"</span>,
             <span class="hljs-string">"April"</span>, <span class="hljs-string">"May"</span>, <span class="hljs-string">"June"</span>,
             <span class="hljs-string">"July"</span>, <span class="hljs-string">"August"</span>, <span class="hljs-string">"September"</span>,
             <span class="hljs-string">"October"</span>, <span class="hljs-string">"November"</span>, <span class="hljs-string">"December"</span>]

<span class="hljs-keyword">struct</span> <span class="hljs-number">SimpleDate</span> {
 <span class="hljs-keyword">var</span> month: <span class="hljs-built_in">String</span>
 <span class="hljs-keyword">var</span> day: <span class="hljs-built_in">Int</span>

 <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-number">advance</span>() {
   day <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
 }
}

<span class="hljs-keyword">var</span> date <span class="hljs-operator">=</span> <span class="hljs-built_in">SimpleDate</span>(month: <span class="hljs-string">"December"</span>, day: <span class="hljs-number">31</span>)
date.advance()
date.month <span class="hljs-comment">// December; should be January!</span>
date.day <span class="hljs-comment">// 32; should be 1!</span></pre>
<p class="calibre1">What happens when the function should go from the end of one month to the start of the next? Rewrite <code class="calibre9">advance()</code> to account for advancing from December 31st to January 1st.
</p>
<h3 class="segment-title2">Challenge 3: Odd and Even Math</h3>

<p class="calibre1">Add type methods named <code class="calibre9">isEven</code> and <code class="calibre9">isOdd</code> to your <code class="calibre9">Math</code> namespace that return <code class="calibre9">true</code> if a number is even or odd, respectively.
</p>
<h3 class="segment-title2">Challenge 4: Odd and Even Int</h3>

<p class="calibre1">It turns out that <code class="calibre9">Int</code> is simply a struct.  Add the computed properties <code class="calibre9">isEven</code> and <code class="calibre9">isOdd</code> to <code class="calibre9">Int</code> using an extension.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Generally, you want to be careful about what functionality you add to standard library types as it can confuse readers.
</p></div>

<h3 class="segment-title2">Challenge 5: Prime Factors</h3>

<p class="calibre1">Add the method <code class="calibre9">primeFactors()</code> to <code class="calibre9">Int</code>. Since this is an expensive operation, this is best left as an actual method and not a computed property.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Methods</em> are functions associated with a type.
</p></li>

<li class="calibre4">
<p class="calibre1">Methods are the behaviors that define the functionality of a type.
</p></li>

<li class="calibre4">
<p class="calibre1">A method can access the data of an instance by using the keyword <code class="calibre9">self</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Initializers</em> create new instances of a type. They look a lot like methods that are called <code class="calibre9">init</code> with no return value.
</p></li>

<li class="calibre4">
<p class="calibre1">A <em class="calibre5">type method</em> adds behavior to a type instead of the instances of that type. To define a type method, you prefix it with the <code class="calibre9">static</code> modifier.
</p></li>

<li class="calibre4">
<p class="calibre1">You can open an existing structure and add methods, initializers and computed properties to it by using an <code class="calibre9">extension</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">By adding your own initializers in extensions, you can keep the compiler’s member-wise initializer for a structure.
</p></li>

<li class="calibre4">
<p class="calibre1">Methods can exist in all the named types &mdash; structures, classes and enumerations.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-33">


<h1 class="segment-chapter">Chapter 13: Classes</h1>

<p class="calibre1">Structures introduced you to named types. In this chapter, you’ll get acquainted with <em class="calibre5">classes</em>, which are much like structures &mdash; they are named types with properties and methods.
</p>
<p class="calibre1">You’ll learn classes are <i class="calibre2">reference</i> types, as opposed to <i class="calibre2">value</i> types, and have substantially different capabilities and benefits than their structure counterparts. While you’ll often use structures in your apps to represent values, you’ll generally use classes to represent <i class="calibre2">objects</i>.
</p>
<p class="calibre1">What does <i class="calibre2">values</i> vs. <i class="calibre2">objects</i> mean, though?
</p>
<h2 class="segment-chapter1">Creating classes</h2>

<p class="calibre1">Consider the following class definition in Swift:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> lastName: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }

  <span class="hljs-keyword">var</span> fullName: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"<span class="hljs-subst">\(firstName)</span> <span class="hljs-subst">\(lastName)</span>"</span>
  }
}

<span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)</pre>
<p class="calibre1">That’s simple enough! It may surprise you that the definition is almost identical to its struct counterpart. The keyword <code class="calibre9">class</code> is followed by the name of the class, and everything in the curly braces is a member of that class.
</p>
<p class="calibre1">But you can also see some differences between a class and a struct: The class above defines an initializer that sets both <code class="calibre9">firstName</code> and <code class="calibre9">lastName</code> to initial values. Unlike a struct, a class doesn’t provide a memberwise initializer automatically &mdash; which means you must provide it yourself if you need it. If you forget to provide an initializer, the Swift compiler will flag that as an error:
</p><div class="image9"><img src="images/000004.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Default initialization aside, the initialization rules for classes and structs are very similar. Class initializers are functions marked <code class="calibre9">init</code>, and all stored properties must be assigned initial values before the end of <code class="calibre9">init</code>.
</p>
<p class="calibre1">There is  <i class="calibre2">much</i> more to class initialization, but you’ll have to wait until Chapter 14, “Advanced Classes”, which will introduce the concept of <em class="calibre5">inheritance</em> and its effect on initialization rules. This chapter will stick with basic class initializers so that you can get comfortable with classes in Swift.
</p>
<h2 class="segment-chapter1">Reference types</h2>

<p class="calibre1">In Swift, an instance of a structure is an immutable value, whereas an instance of a class is a mutable object.  Classes are reference types, so a variable of a class type doesn’t store an actual instance &mdash; it stores a <em class="calibre5">reference</em> to a location in memory that stores the instance.
</p>
<p class="calibre1">If you created a <code class="calibre9">SimplePerson</code> class instance with only a name like this:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">SimplePerson</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">var</span> var1 <span class="hljs-operator">=</span> <span class="hljs-built_in">SimplePerson</span>(name: <span class="hljs-string">"John"</span>)</pre>
<p class="calibre1">It would look something like this in memory:
</p><div class="image3"><img src="images/000017.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">If you were to create a new variable <code class="calibre9">var2</code> and assign to it the value of <code class="calibre9">var1</code>:
</p><pre class="code-block"><span class="hljs-keyword">var</span> var2 <span class="hljs-operator">=</span> var1</pre>
<p class="calibre1">Then the references inside both <code class="calibre9">var1</code> and <code class="calibre9">var2</code> would reference the same place in memory:
</p><div class="image3"><img src="images/000048.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Conversely, a structure as a value type stores the actual value, providing direct access to it. Replace the <code class="calibre9">SimplePerson</code> class implementation with a struct like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">SimplePerson</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">The variable would not reference an external, shared place in memory but instead belong to <code class="calibre9">var1</code> exclusively:
</p><div class="image3"><img src="images/000056.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The assignment <code class="calibre9">var var2 = var1</code> would <em class="calibre5">copy</em> the <i class="calibre2">value</i> of <code class="calibre9">var1</code> in this case:
</p><div class="image3"><img src="images/000079.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Value types and reference types each have their own distinct advantages &mdash; and disadvantages. Later in the chapter, you’ll consider which type to use in a given situation. For now, let’s examine how classes and structs work under the hood.
</p>
<h3 class="segment-title2">The heap vs. the stack</h3>

<p class="calibre1">When you create a reference type using a class, the system often stores the actual instance in a region of memory known as the <em class="calibre5">heap</em> that has a dynamic lifetime.  Instances of value types typically reside in a region of memory called the <em class="calibre5">stack</em> that lives only as long as the current scope.
</p>
<p class="calibre1">Both the heap and the stack have essential roles in the execution of any program. A general understanding of what they are and how they work will help you visualize the functional differences between a class and a structure:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The system uses the <em class="calibre5">stack</em> to store anything on the immediate thread of execution; it’s tightly managed and optimized by the CPU. A function allocates stack variables on entry and deallocates them on exit. Since the stack is so strictly organized, it’s very efficient.
</p></li>

<li class="calibre4">
<p class="calibre1">The system uses the <em class="calibre5">heap</em> to store instances of reference types. The heap is generally a large pool of memory from which the system can request and dynamically allocate memory blocks. Lifetime is flexible and dynamic.
</p></li>
</ul>

<p class="calibre1">The heap doesn’t automatically deallocate as the stack does; additional work is required. This extra work makes creating and removing data on the heap more involved.
</p>
<p class="calibre1">You may have already figured out how this relates to structs and classes. Take a look at the diagram below:
</p><div class="image3"><img src="images/000101.png" alt="" title="" class="calibre7" /></div>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">When you create an instance of a class, your code requests a block of memory on the heap to store the instance itself; that’s the first name and last name inside the instance on the right side of the diagram. It stores the <i class="calibre2">address</i> of that memory in your named variable on the stack; that’s the <i class="calibre2">reference</i> stored on the left side of the diagram.
</p></li>

<li class="calibre4">
<p class="calibre1">When you create an instance of a struct (that is not part of an instance of a class), the instance itself is stored on the stack, and the heap is never involved.
</p></li>
</ul>

<p class="calibre1">This essential mental model of heaps and stacks is enough to understand the reference semantics of classes. You’ll now get some additional experience working with them.
</p>
<h3 class="segment-title2">Working with references</h3>

<p class="calibre1">In Chapter 10, “Structures”, you saw the copy semantics involved when working with structures and other value types. Here’s a little reminder, using the <code class="calibre9">Location</code> and <code class="calibre9">DeliveryArea</code> structures from that chapter:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Location</span> {
  <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Int</span>
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">DeliveryArea</span> {
  <span class="hljs-keyword">var</span> range: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">let</span> center: <span class="hljs-built_in">Location</span>
}

<span class="hljs-keyword">var</span> area1 <span class="hljs-operator">=</span> <span class="hljs-built_in">DeliveryArea</span>(range: <span class="hljs-number">2.5</span>,
                         center: <span class="hljs-built_in">Location</span>(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">4</span>))
<span class="hljs-keyword">var</span> area2 <span class="hljs-operator">=</span> area1
<span class="hljs-built_in">print</span>(area1.range) <span class="hljs-comment">// 2.5</span>
<span class="hljs-built_in">print</span>(area2.range) <span class="hljs-comment">// 2.5</span>

area1.range <span class="hljs-operator">=</span> <span class="hljs-number">4</span>
<span class="hljs-built_in">print</span>(area1.range) <span class="hljs-comment">// 4.0</span>
<span class="hljs-built_in">print</span>(area2.range) <span class="hljs-comment">// 2.5</span></pre>
<p class="calibre1">When you assign the value of <code class="calibre9">area1</code> into <code class="calibre9">area2</code>, <code class="calibre9">area2</code> receives a <i class="calibre2">copy</i> of the <code class="calibre9">area1</code> value. That way, when <code class="calibre9">area1.range</code> receives a new value of <code class="calibre9">4</code>, the number is only reflected in <code class="calibre9">area1</code> while <code class="calibre9">area2</code> still has the original value of <code class="calibre9">2.5</code>.
</p>
<p class="calibre1">Since a class is a reference type when you assign a class type variable, the system does <i class="calibre2">not</i> copy the instance; it only copies a reference.
</p>
<p class="calibre1">Compare the previous code with the following code:
</p><pre class="code-block"><span class="hljs-keyword">var</span> homeOwner <span class="hljs-operator">=</span> john
john.firstName <span class="hljs-operator">=</span> <span class="hljs-string">"John"</span> <span class="hljs-comment">// John wants to use his short name!</span>
john.firstName <span class="hljs-comment">// "John"</span>
homeOwner.firstName <span class="hljs-comment">// "John"</span></pre>
<p class="calibre1">As you can see, <code class="calibre9">john</code> and <code class="calibre9">homeOwner</code> truly have the same value!
</p>
<p class="calibre1">This implied sharing among class instances results in a new way of thinking when passing things around. For instance, if the <code class="calibre9">john</code> object changes, then anything holding a reference to <code class="calibre9">john</code> will automatically see the update. If you were using a structure, you would have to update each copy individually, or it would still have the old value of “Johnny”.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Change the value of <code class="calibre9">lastName</code> on <code class="calibre9">homeOwner</code>, then try reading <code class="calibre9">fullName</code> on both <code class="calibre9">john</code> and <code class="calibre9">homeOwner</code>. What do you observe?
</p>
<h3 class="segment-title2">Object identity</h3>

<p class="calibre1">In the previous code sample, it’s easy to see that <code class="calibre9">john</code> and <code class="calibre9">homeOwner</code> are pointing to the same object. The code is short, and both references are named variables. What if you want to see if the value behind a variable <i class="calibre2">is</i> John?
</p>
<p class="calibre1">You might think to check the value of <code class="calibre9">firstName</code>, but how would you know it’s the John you’re looking for and not an imposter? Or worse, what if John changed his name again?
</p>
<p class="calibre1">In Swift, the <code class="calibre9">===</code> operator lets you check if the <i class="calibre2">identity</i> of one object is equal to the identity of another:
</p><pre class="code-block">john <span class="hljs-operator">===</span> homeOwner <span class="hljs-comment">// true</span></pre>
<p class="calibre1">Just as the <code class="calibre9">==</code> operator checks if two <i class="calibre2">values</i> are equal, the <code class="calibre9">===</code> identity operator compares the memory address of two <i class="calibre2">references</i>. It tells you whether the value of the references are the same; that is, they point to the same block of data on the heap.
</p>
<p class="calibre1">That means this <code class="calibre9">===</code> operator can tell the difference between the John you’re looking for and an imposter-John:
</p><pre class="code-block"><span class="hljs-keyword">let</span> imposterJohn <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, 
                          lastName: <span class="hljs-string">"Appleseed"</span>)

john <span class="hljs-operator">===</span> homeOwner <span class="hljs-comment">// true</span>
john <span class="hljs-operator">===</span> imposterJohn <span class="hljs-comment">// false</span>
imposterJohn <span class="hljs-operator">===</span> homeOwner <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Assignment of existing variables changes the instances the variables reference.</span>
homeOwner <span class="hljs-operator">=</span> imposterJohn
john <span class="hljs-operator">===</span> homeOwner <span class="hljs-comment">// false</span>

homeOwner <span class="hljs-operator">=</span> john
john <span class="hljs-operator">===</span> homeOwner <span class="hljs-comment">// true</span></pre>
<p class="calibre1">This form of reference equality can be handy when you cannot rely on regular equality (==) to compare and identify objects you care about:
</p><pre class="code-block"><span class="hljs-comment">// Create fake, imposter Johns. Use === to see if any of these imposters are our real John.</span>
<span class="hljs-keyword">var</span> imposters <span class="hljs-operator">=</span> (<span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">100</span>).map { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span>
  <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"John"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
}

<span class="hljs-comment">// Equality (==) is not effective when John cannot be identified by his name alone</span>
imposters.contains {
  <span class="hljs-variable">$0</span>.firstName <span class="hljs-operator">==</span> john.firstName <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">$0</span>.lastName <span class="hljs-operator">==</span> john.lastName
} <span class="hljs-comment">// true</span></pre>
<p class="calibre1">By using the identity operator, you can verify that the <i class="calibre2">references</i> themselves are equal and separate our real John from the crowd:
</p><pre class="code-block"><span class="hljs-comment">// Check to ensure the real John is not found among the imposters.</span>
imposters.contains {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> john
} <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Now hide the "real" John somewhere among the imposters.</span>
imposters.insert(john, at: <span class="hljs-built_in">Int</span>.random(in: <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">100</span>))

<span class="hljs-comment">// John can now be found among the imposters.</span>
imposters.contains {
  <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> john
} <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Since `Person` is a reference type, you can use === to grab the real John out of the list of imposters and modify the value.</span>
<span class="hljs-comment">// The original `john` variable will print the new last name!</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexOfJohn <span class="hljs-operator">=</span> imposters.firstIndex(where: 
                                          { <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> john }) {
  imposters[indexOfJohn].lastName <span class="hljs-operator">=</span> <span class="hljs-string">"Bananapeel"</span>
}

john.fullName <span class="hljs-comment">// John Bananapeel</span></pre>
<p class="calibre1">Because Swift emphasizes value types, you’ll find the reference identity operator <code class="calibre9">===</code> isn’t used that often. What’s important is to understand what it does and what it demonstrates about the properties of reference types.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a function <code class="calibre9">memberOf(person: Person, group: [Person]) -&gt; Bool</code> that will return <code class="calibre9">true</code> if <code class="calibre9">person</code> can be found inside <code class="calibre9">group</code>, and <code class="calibre9">false</code> if it can not.
</p>
<p class="calibre1">Test it by creating two arrays of five <code class="calibre9">Person</code> objects for <code class="calibre9">group</code> and using <code class="calibre9">john</code> as the <code class="calibre9">person</code>. Put <code class="calibre9">john</code> in one of the arrays, but not in the other.
</p>
<h3 class="segment-title2">Methods and mutability</h3>

<p class="calibre1">As you’ve read before, instances of classes are mutable objects, whereas instances of structures are immutable values. The following example illustrates this difference:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Grade</span> {
  <span class="hljs-keyword">let</span> letter: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> points: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">let</span> credits: <span class="hljs-built_in">Double</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> lastName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
    grades.append(grade)
  }
}

<span class="hljs-keyword">let</span> jane <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Jane"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-keyword">let</span> history <span class="hljs-operator">=</span> <span class="hljs-built_in">Grade</span>(letter: <span class="hljs-string">"B"</span>, points: <span class="hljs-number">9.0</span>, credits: <span class="hljs-number">3.0</span>)
<span class="hljs-keyword">var</span> math <span class="hljs-operator">=</span> <span class="hljs-built_in">Grade</span>(letter: <span class="hljs-string">"A"</span>, points: <span class="hljs-number">16.0</span>, credits: <span class="hljs-number">4.0</span>)

jane.recordGrade(history)
jane.recordGrade(math)</pre>
<p class="calibre1">Note that <code class="calibre9">recordGrade(_:)</code> can mutate the array <code class="calibre9">grades</code> by adding more values to the end. The keyword ’ mutating ’ is not required because it mutates the underlying object and not the reference itself.
</p>
<p class="calibre1">If you had tried this with a struct, you’d have wound up with a compiler error because structures methods are, by default, immutable and can’t change any of its properties. The keyword <code class="calibre9">mutating</code> marks structure methods that can change stored properties. This keyword is not used with classes because a class is just a reference to some storage that another client could share and mutate. It would give you a false sense of security about a guarantee that doesn’t exist for methods not marked mutating.
</p>
<h3 class="segment-title2">Mutability and constants</h3>

<p class="calibre1">The previous example may have had you wondering how you could modify <code class="calibre9">jane</code> even though it was defined as a constant. When you define a constant, the value of the constant cannot be changed. If you recall back to the discussion of value types vs. reference types, it’s important to remember that, with reference types, the value is a <i class="calibre2">reference</i>.
</p><div class="image3"><img src="images/000112.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The value of “reference1” in red is the value stored in <code class="calibre9">jane</code>. This value is a reference, and because <code class="calibre9">jane</code> is declared as a constant, this reference is constant. If you were to attempt to assign another student to <code class="calibre9">jane</code>, you would get a compiler error:
</p><pre class="code-block"><span class="hljs-comment">// Error: jane is a `let` constant</span>
jane <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"John"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)</pre>
<p class="calibre1">If you declared <code class="calibre9">jane</code> as a variable instead, you would be able to assign to it another instance of <code class="calibre9">Student</code> on the heap:
</p><pre class="code-block"><span class="hljs-keyword">var</span> jane <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Jane"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
jane <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"John"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)</pre>
<p class="calibre1">After assigning another <code class="calibre9">Student</code> to <code class="calibre9">jane</code>, the reference value behind <code class="calibre9">jane</code> would be updated to point to the new <code class="calibre9">Student</code> object.
</p><div class="image3"><img src="images/000122.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Since nothing would be referencing the original “Jane” object, its memory would be freed to use elsewhere. You’ll learn more about this in Chapter 24, “Memory Management”.
</p>
<p class="calibre1">Any individual member of a class can be protected from modification through the use of constants. Still, because reference types are not treated as values, they are not protected as a whole from mutation.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Add a computed property to <code class="calibre9">Student</code> that returns the student’s Grade Point Average or GPA. A GPA is defined as the number of points earned divided by the number of credits taken. For the example above, Jane earned (9 + 16 = <em class="calibre5">25</em>) points while taking (3 + 4 = <em class="calibre5">7</em>) credits, making her GPA (25 / 7 = <em class="calibre5">3</em><em class="calibre5">.</em><em class="calibre5">57</em>).
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Points in most American universities range from 4 per credit for an A, down to 1 point for a D (with an F being 0 points). For this exercise, you may, of course, use any scale that you want!
</p></div>

<h2 class="segment-chapter1">Understanding state and side effects</h2>

<p class="calibre1">Since the very nature of classes is that they are both referenced and mutable, programmers have many possibilities and many concerns. Remember: If you update a class instance with a new value, every reference to that instance will also see the new value.
</p>
<p class="calibre1">You can use this to your advantage. Perhaps you pass a <code class="calibre9">Student</code> instance to a sports team, a report card and a class roster. Imagine all of these entities need to know the student’s grades, and because they all point to the same instance, they’ll all see new grades as the instance records them.
</p><div class="image3"><img src="images/000008.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The result of this sharing is that class instances have <em class="calibre5">state</em>. State changes can sometimes be obvious, but often they’re not.
</p>
<p class="calibre1">To illustrate this, add a <code class="calibre9">credits</code> property to the <code class="calibre9">Student</code> class.
</p><pre class="code-block"><span class="hljs-keyword">var</span> credits <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span></pre>
<p class="calibre1">and update <code class="calibre9">recordGrade(_:)</code> to use this new property:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
  grades.append(grade)
  credits <span class="hljs-operator">+=</span> grade.credits
}</pre>
<p class="calibre1">In this slightly modified example of <code class="calibre9">Student</code>, <code class="calibre9">recordGrade(_:)</code> now adds the number of credits to the <code class="calibre9">credits</code> property. Calling <code class="calibre9">recordGrade(_:)</code> has the side effect of updating <code class="calibre9">credits</code>.
</p>
<p class="calibre1">Now, observe how side effects can result in non-obvious behavior:
</p><pre class="code-block">jane.credits <span class="hljs-comment">// 7</span>

<span class="hljs-comment">// The teacher made a mistake; math has 5 credits</span>
math <span class="hljs-operator">=</span> <span class="hljs-built_in">Grade</span>(letter: <span class="hljs-string">"A"</span>, points: <span class="hljs-number">20.0</span>, credits: <span class="hljs-number">5.0</span>)
jane.recordGrade(math)

jane.credits <span class="hljs-comment">// 12, not 8!</span></pre>
<p class="calibre1">Whoever wrote the modified <code class="calibre9">Student</code> class did so somewhat naïvely by assuming that the same grade won’t get recorded twice!
</p>
<p class="calibre1">Because class instances are mutable, you need to be careful about unexpected behavior around shared references.
</p>
<p class="calibre1">While confusing in a small example, mutability and state could be highly jarring as classes grow in size and complexity.
</p>
<p class="calibre1">Situations like this would be much more common with a <code class="calibre9">Student</code> class that scales to 20 stored properties and has ten methods.
</p>
<h2 class="segment-chapter1">Extending a class using an extension</h2>

<p class="calibre1">As you saw with structs, classes can be <i class="calibre2">re</i><i class="calibre2">-</i><i class="calibre2">opened</i> using the <code class="calibre9">extension</code> keyword to add methods and computed properties.  Add a <code class="calibre9">fullName</code> computed property to <code class="calibre9">Student</code>:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> fullName: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"<span class="hljs-subst">\(firstName)</span> <span class="hljs-subst">\(lastName)</span>"</span>
  }
}</pre>
<p class="calibre1">Functionality can also be added to classes using <i class="calibre2">inheritance</i>. You can even add new stored properties to inheriting classes. You’ll explore this technique in detail in Chapter 14, “Advanced Classes”.
</p>
<h2 class="segment-chapter1">When to use a class versus a struct</h2>

<p class="calibre1">You may wonder when to use a class vs. a struct. Here are some general guidelines.
</p>
<h4 class="segment-title2">Values vs. objects</h4>

<p class="calibre1">While there are no hard-and-fast rules, you should consider value versus reference semantics and use structures as <i class="calibre2">values</i> and classes as <i class="calibre2">objects with identity</i>.
</p>
<p class="calibre1">An <em class="calibre5">object</em> is an instance of a reference type, and such instances have <em class="calibre5">identity</em> meaning that every object is unique. Two objects may not be equal simply because they hold the same state. Hence, you use <code class="calibre9">===</code> to see if objects refer to the same place in memory. In contrast, instances of value types, which <i class="calibre2">are</i> values, are considered equal if they are the same value.
</p>
<p class="calibre1">For example: A delivery range is a value, so you implement it as a struct. A student is an object, so you implement it as a class. In non-technical terms, no two students are considered equal, even if they have the same name!
</p>
<h4 class="segment-title2">Speed</h4>

<p class="calibre1">Speed considerations are a thing, as structs rely on the faster stack while classes rely on the slower heap. If you’ll have many more instances (hundreds and greater), or if these instances will only exist in memory for a  short time &mdash; lean towards using a struct. If your instance will have a longer lifecycle in memory, or if you’ll create relatively few instances, then class instances on the heap shouldn’t create much overhead.
</p>
<p class="calibre1">For instance, you’d use a struct to calculate the total distance of a running route using many GPS-based waypoints, such as the <code class="calibre9">Location</code> struct you used in Chapter 10, “Structures”. You’ll create many waypoints, but they’ll be quickly created and destroyed as you modify the route.
</p>
<p class="calibre1">You could also use a class for an object to store route history, as there would be only one object for each user, and you’d likely use the same history object for the user’s lifetime.
</p>
<h4 class="segment-title2">Minimalist approach</h4>

<p class="calibre1">Another approach is to use only what you need. If your data will never change or you need a simple data store, then use structures. If you need to update your data and you need it to contain logic to update its own state, then use a class. Often, it’s best to begin with a struct. If you need the added capabilities of a class sometime later, you just convert the struct to a class.
</p>
<h3 class="segment-title2">Structures vs. classes recap</h3>

<h4 class="segment-title2">Structures</h4>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Useful for representing values.
</p></li>

<li class="calibre4">
<p class="calibre1">Implicit copying of values.
</p></li>

<li class="calibre4">
<p class="calibre1">Becomes completely immutable when declared with <code class="calibre9">let</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Fast memory allocation (stack).
</p></li>
</ul>

<h4 class="segment-title2">Classes</h4>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Useful for representing objects with an identity.
</p></li>

<li class="calibre4">
<p class="calibre1">Implicit sharing of objects.
</p></li>

<li class="calibre4">
<p class="calibre1">Internals can remain mutable even when declared with <code class="calibre9">let</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Slower memory allocation (heap).
</p></li>
</ul>

<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your classes knowledge. It’s best to try and solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Movie lists</h3>

<p class="calibre1">Imagine you’re writing a movie-viewing app in Swift. Users can create lists of movies and share those lists with other users. Create a <code class="calibre9">User</code> and a <code class="calibre9">List</code> class that uses reference semantics to help maintain lists between users.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">User</code>: Has a method <code class="calibre9">addList(_:)</code> that adds the given list to a dictionary of <code class="calibre9">List</code> objects (using the <code class="calibre9">name</code> as a key), and <code class="calibre9">list(forName:) -&gt; List?</code> that returns the <code class="calibre9">List</code> for the provided name.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">List</code>: Contains a name and an array of movie titles. A <code class="calibre9">print</code> method will print all the movies in the list.
</p></li>

<li class="calibre4">
<p class="calibre1">Create <code class="calibre9">jane</code> and <code class="calibre9">john</code> users and have them create and share lists. Have both <code class="calibre9">jane</code> and <code class="calibre9">john</code> modify the same list and call <code class="calibre9">print</code> from both users. Are all the changes reflected?
</p></li>

<li class="calibre4">
<p class="calibre1">What happens when you implement the same with structs? What problems do you run into?
</p></li>
</ul>

<h3 class="segment-title2">Challenge 2: T-shirt store</h3>

<p class="calibre1">Your challenge here is to build a set of objects to support a T-shirt store. Decide if each object should be a class or a struct and why.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">TShirt</code>: Represents a shirt style you can buy. Each <code class="calibre9">TShirt</code> has a size, color, price, and an optional image on the front.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">User</code>: A registered user of the t-shirt store app. A user has a name, email, and a <code class="calibre9">ShoppingCart</code> (see below).
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">Address</code>: Represents a shipping address and contains the name, street, city, and zip code.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">ShoppingCart</code>: Holds a current order, which is composed of an array of <code class="calibre9">TShirt</code> that the <code class="calibre9">User</code> wants to buy, as well as a method to calculate the total cost. Additionally, there is an <code class="calibre9">Address</code> that represents where the order will be shipped.
</p></li>
</ul>

<div class="note">
<p class="calibre10"><em class="calibre5">Bonus:</em> After you’ve decided on whether to use a class or struct for each object, go ahead and implement them all!
</p></div>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Like structures, <em class="calibre5">classes</em> are a named type that can have properties and methods.
</p></li>

<li class="calibre4">
<p class="calibre1">Classes use <em class="calibre5">references</em> that are shared on assignment.
</p></li>

<li class="calibre4">
<p class="calibre1">Class instances are called <em class="calibre5">objects</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">Objects are <em class="calibre5">mutable</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">Mutability introduces <em class="calibre5">state</em>, which adds complexity when managing your objects.
</p></li>

<li class="calibre4">
<p class="calibre1">Use classes when you want <em class="calibre5">reference semantics</em>; structures for <em class="calibre5">value semantics</em>.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-6">


<h1 class="segment-chapter">Chapter 14: Advanced Classes</h1>

<p class="calibre1">Chapter 13, “Classes”, introduced you to the basics of defining and using classes in Swift. Classes are reference types and can be used to support traditional object-oriented programming.
</p>
<p class="calibre1">Classes introduce inheritance, overriding, polymorphism which makes them suited for this purpose. These extra features require special consideration for initialization, class hierarchies, and understanding the class lifecycle in memory.
</p>
<p class="calibre1">This chapter will introduce you to the finer points of classes in Swift and help you understand how you can create full-featured classes and class hierarchies.
</p>
<h2 class="segment-chapter1">Introducing inheritance</h2>

<p class="calibre1">In Chapter 13, “Classes”, you saw a <code class="calibre9">Grade</code> struct and a pair of class examples: <code class="calibre9">Person</code> and <code class="calibre9">Student</code>.
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Grade</span> {
  <span class="hljs-keyword">var</span> letter: <span class="hljs-built_in">Character</span>
  <span class="hljs-keyword">var</span> points: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">var</span> credits: <span class="hljs-built_in">Double</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> lastName: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> lastName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
    grades.append(grade)
  }
}</pre>
<p class="calibre1">It’s not difficult to see that there’s redundancy between <code class="calibre9">Person</code> and <code class="calibre9">Student</code>. Maybe you’ve also noticed that a <code class="calibre9">Student</code> <i class="calibre2">is</i> a <code class="calibre9">Person</code>! This simple case demonstrates the idea behind class inheritance. Much like in the real world, where you can think of a student as a person, you can represent the same relationship in code by replacing the original <code class="calibre9">Student</code> class implementation with the following:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
    grades.append(grade)
  }
}</pre>
<p class="calibre1">In this modified example, the <code class="calibre9">Student</code> class now <em class="calibre5">inherits</em> from <code class="calibre9">Person</code>, indicated by a colon after the naming of <code class="calibre9">Student</code>, followed by the class from which <code class="calibre9">Student</code> inherits, which in this case is <code class="calibre9">Person</code>. Through inheritance, <code class="calibre9">Student</code> automatically gets the properties and methods declared in the <code class="calibre9">Person</code> class. In code, it would be accurate to say that a <code class="calibre9">Student</code> <i class="calibre2">is</i><i class="calibre2">-</i><i class="calibre2">a</i> <code class="calibre9">Person</code>.
</p>
<p class="calibre1">With much less duplication of code, you can now create <code class="calibre9">Student</code> objects that have all the properties and methods of a <code class="calibre9">Person</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-keyword">let</span> jane <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Jane"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)

john.firstName <span class="hljs-comment">// "John"</span>
jane.firstName <span class="hljs-comment">// "Jane"</span></pre>
<p class="calibre1">Additionally, only the <code class="calibre9">Student</code> object will have all of the properties and methods defined in <code class="calibre9">Student</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> history <span class="hljs-operator">=</span> <span class="hljs-built_in">Grade</span>(letter: <span class="hljs-string">"B"</span>, points: <span class="hljs-number">9.0</span>, credits: <span class="hljs-number">3.0</span>)
jane.recordGrade(history)
<span class="hljs-comment">// john.recordGrade(history) // john is not a student!</span></pre>
<p class="calibre1">A class inheriting from another class is known as a <em class="calibre5">subclass</em> or a <em class="calibre5">derived class</em>. The class it inherits is known as a <em class="calibre5">superclass</em> or a <em class="calibre5">base class</em>.
</p>
<p class="calibre1">The rules for subclassing are relatively simple:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A Swift class can inherit from only one class, a concept known as <em class="calibre5">single inheritance</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">There’s no limit to the depth of subclassing, meaning you can subclass from a class that is <i class="calibre2">also</i> a subclass, like below:
</p></li>
</ul>
<pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">BandMember</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> minimumPracticeTime <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-number">OboePlayer</span>: <span class="hljs-number">BandMember</span> {
  <span class="hljs-comment">// This is an example of an override, which we’ll cover soon.</span>
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> minimumPracticeTime: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">get</span> {
      <span class="hljs-keyword">super</span>.minimumPracticeTime <span class="hljs-operator">*</span> <span class="hljs-number">2</span>
    }
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">super</span>.minimumPracticeTime <span class="hljs-operator">=</span> newValue <span class="hljs-operator">/</span> <span class="hljs-number">2</span>
    }
  }
}</pre>
<p class="calibre1">A chain of subclasses is called a <em class="calibre5">class hierarchy</em>. In this example, the hierarchy would be <code class="calibre9">OboePlayer</code> -&gt; <code class="calibre9">BandMember</code> -&gt; <code class="calibre9">Student</code> -&gt; <code class="calibre9">Person</code>. A class hierarchy is analogous to a family tree. Because of this analogy, a superclass is also called the <em class="calibre5">parent class</em> of its <em class="calibre5">child class</em>.
</p>
<h3 class="segment-title2">Polymorphism</h3>

<p class="calibre1">The <code class="calibre9">Student</code>/<code class="calibre9">Person</code> relationship demonstrates a computer science concept known as <em class="calibre5">polymorphism</em>. In brief, polymorphism is a programming language’s ability to treat an object differently based on context.
</p>
<p class="calibre1">An <code class="calibre9">OboePlayer</code> is, of course, an <code class="calibre9">OboePlayer</code>, but it’s also a <code class="calibre9">Person</code>. Because it derives from <code class="calibre9">Person</code>, you could use an <code class="calibre9">OboePlayer</code> object anywhere you’d use a <code class="calibre9">Person</code> object.
</p>
<p class="calibre1">This example demonstrates how you can treat an <code class="calibre9">OboePlayer</code> as a <code class="calibre9">Person</code>:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">phonebookName</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">person</span>: <span class="hljs-built_in">Person</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-string">"<span class="hljs-subst">\(person.lastName)</span>, <span class="hljs-subst">\(person.firstName)</span>"</span>
}

<span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-keyword">let</span> oboePlayer <span class="hljs-operator">=</span> <span class="hljs-built_in">OboePlayer</span>(firstName: <span class="hljs-string">"Jane"</span>,
                            lastName: <span class="hljs-string">"Appleseed"</span>)

phonebookName(person) <span class="hljs-comment">// Appleseed, Johnny</span>
phonebookName(oboePlayer) <span class="hljs-comment">// Appleseed, Jane</span></pre>
<p class="calibre1">Because <code class="calibre9">OboePlayer</code> derives from <code class="calibre9">Person</code>, it’s a valid input into the function <code class="calibre9">phonebookName(_:)</code>. More importantly, the function has no idea that the object passed in is anything <i class="calibre2">other</i> than a regular <code class="calibre9">Person</code>. It can only observe the elements of <code class="calibre9">OboePlayer</code> that are defined in the <code class="calibre9">Person</code> base class.
</p>
<p class="calibre1">With the polymorphism characteristics provided by class inheritance, Swift treats the object referred to by <code class="calibre9">oboePlayer</code> differently based on the context. This distilled behavior can be advantageous when you have many specialized derived types but want to code that operates on a common base class.
</p>
<h3 class="segment-title2">Runtime hierarchy checks</h3>

<p class="calibre1">Now that you are coding with polymorphism, you’ll likely find situations where the specific type backing a variable can differ. For instance, you could define a variable <code class="calibre9">hallMonitor</code> as a <code class="calibre9">Student</code>:
</p><pre class="code-block"><span class="hljs-keyword">var</span> hallMonitor <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Jill"</span>, 
                          lastName: <span class="hljs-string">"Bananapeel"</span>)</pre>
<p class="calibre1">But what if <code class="calibre9">hallMonitor</code> were a more derived type, such as an <code class="calibre9">OboePlayer</code>?
</p><pre class="code-block">hallMonitor <span class="hljs-operator">=</span> oboePlayer</pre>
<p class="calibre1">Because <code class="calibre9">hallMonitor</code> is defined as a <code class="calibre9">Student</code>, the compiler won’t allow you to attempt calling properties or methods for a more derived type.
</p>
<p class="calibre1">Fortunately, Swift provides the <code class="calibre9">as</code> casting-operator to treat a property or a variable as another type:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">as</code>: Cast to a specific type that is known at compile-time to succeed, such as casting to a supertype.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">as?</code>: An optional downcast (to a subtype). If the downcast fails, the result of the expression will be <code class="calibre9">nil</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">as!</code>: A forced downcast. If the downcast fails, the program will crash. Use this rarely, and only when you are certain the cast will never fail.
</p></li>
</ul>

<p class="calibre1">Casts can be used in various contexts to treat the <code class="calibre9">hallMonitor</code> as a <code class="calibre9">BandMember</code> or the <code class="calibre9">oboePlayer</code> as a less-derived <code class="calibre9">Student</code>.
</p><pre class="code-block">oboePlayer <span class="hljs-keyword">as</span> <span class="hljs-built_in">Student</span>
(oboePlayer <span class="hljs-keyword">as</span> <span class="hljs-built_in">Student</span>).minimumPracticeTime <span class="hljs-comment">// ERROR: No longer a band member!</span>

hallMonitor <span class="hljs-keyword">as?</span> <span class="hljs-built_in">BandMember</span>
(hallMonitor <span class="hljs-keyword">as?</span> <span class="hljs-built_in">BandMember</span>)<span class="hljs-operator">?</span>.minimumPracticeTime <span class="hljs-comment">// 4 (optional)</span>

hallMonitor <span class="hljs-keyword">as!</span> <span class="hljs-built_in">BandMember</span> <span class="hljs-comment">// Careful! Failure would lead to a runtime crash.</span>
(hallMonitor <span class="hljs-keyword">as!</span> <span class="hljs-built_in">BandMember</span>).minimumPracticeTime <span class="hljs-comment">// 4 (force unwrapped)</span></pre>
<p class="calibre1">The optional downcast <code class="calibre9">as?</code> is particularly useful in <code class="calibre9">if let</code> or <code class="calibre9">guard</code> statements:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> hallMonitor <span class="hljs-operator">=</span> hallMonitor <span class="hljs-keyword">as?</span> <span class="hljs-built_in">BandMember</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"This hall monitor is a band member and practices 
         at least <span class="hljs-subst">\(hallMonitor.minimumPracticeTime)</span> 
         hours per week."</span>)
}</pre>
<p class="calibre1">You may be wondering under what contexts you would use the <code class="calibre9">as</code> operator by itself. Any object contains all the properties and methods of its parent class, so what use is casting it to something it already is?
</p>
<p class="calibre1">Swift has a strong type system, and the interpretation of a specific type can affect <em class="calibre5">static dispatch</em>, aka the process of deciding which operation to use at compile-time.
</p>
<p class="calibre1">Sound confusing? Let’s see an example.
</p>
<p class="calibre1">Assume you have two functions with identical names and parameter names for two different parameter types:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">afterClassActivity</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">student</span>: <span class="hljs-built_in">Student</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-string">"Goes home!"</span>
}

<span class="hljs-keyword">func</span> <span class="hljs-number">afterClassActivity</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">student</span>: <span class="hljs-built_in">BandMember</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-string">"Goes to practice!"</span>
}</pre>
<p class="calibre1">If you were to pass <code class="calibre9">oboePlayer</code> into <code class="calibre9">afterClassActivity(for:)</code>, which one of these implementations would get called? The answer lies in Swift’s dispatch rules, which in this case will select the more specific version that takes in an <code class="calibre9">OboePlayer</code>.
</p>
<p class="calibre1">If instead you were to cast <code class="calibre9">oboePlayer</code> to a <code class="calibre9">Student</code>, the <code class="calibre9">Student</code> version would be called:
</p><pre class="code-block">afterClassActivity(for: oboePlayer) <span class="hljs-comment">// Goes to practice!</span>
afterClassActivity(for: oboePlayer <span class="hljs-keyword">as</span> <span class="hljs-built_in">Student</span>) <span class="hljs-comment">// Goes home!</span></pre>
<h3 class="segment-title2">Inheritance, methods and overrides</h3>

<p class="calibre1">Subclasses receive all properties and methods defined in their superclass, plus any additional properties and methods the subclass defines for itself. In that sense, subclasses are additive.
</p>
<p class="calibre1">For example, you saw that the <code class="calibre9">Student</code> class can add additional properties and methods to handle a student’s grades. These properties and methods are available to any <code class="calibre9">Person</code> class instances but fully available to <code class="calibre9">Student</code> subclasses.
</p>
<p class="calibre1">Besides creating their own methods, subclasses can <i class="calibre2">override</i> methods defined in their superclass. For another example, assume that student-athletes become ineligible for the athletics program if they fail three or more classes. That means you need to keep track of failing grades somehow, like so:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> failedClasses: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
    <span class="hljs-keyword">super</span>.recordGrade(grade)

    <span class="hljs-keyword">if</span> grade.letter <span class="hljs-operator">==</span> <span class="hljs-string">"F"</span> {
      failedClasses.append(grade)
    }
  }

  <span class="hljs-keyword">var</span> isEligible: <span class="hljs-built_in">Bool</span> {
    failedClasses.count <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span>
  }
}</pre>
<p class="calibre1">In this example, the <code class="calibre9">StudentAthlete</code> class overrides <code class="calibre9">recordGrade(_:)</code> to keep track of any courses the student has failed. <code class="calibre9">StudentAthlete</code> has <code class="calibre9">isEligible</code>, its own computed property, that uses this information to determine the athlete’s eligibility.
</p>
<p class="calibre1">When overriding a method, use the <code class="calibre9">override</code> keyword before the method declaration.
</p>
<p class="calibre1">If your subclass were to have an identical method declaration as its superclass, but you omitted the <code class="calibre9">override</code> keyword, Swift would emit a compiler error:
</p><div class="image1"><img src="images/000035.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">This requirement makes it very clear whether a method is an override of an existing one or not.
</p>
<h3 class="segment-title2">Introducing super</h3>

<p class="calibre1">You may have also noticed the line <code class="calibre9">super.recordGrade(grade)</code> in the overridden method. The <code class="calibre9">super</code> keyword is similar to <code class="calibre9">self</code>, except it will invoke the method in the nearest implementing superclass. In the example of <code class="calibre9">recordGrade(_:)</code> in <code class="calibre9">StudentAthlete</code>, calling <code class="calibre9">super.recordGrade(grade)</code> will execute the method as defined in the <code class="calibre9">Student</code> class.
</p>
<p class="calibre1">Remember how inheritance lets you define <code class="calibre9">Person</code> with first name and last name properties and avoid repeating those properties in subclasses? Similarly, calling the superclass methods means you can write the code to record the grade once in <code class="calibre9">Student</code> and then call “up” to it as needed in subclasses.
</p>
<p class="calibre1">Although it isn’t always required, it’s often important to call <code class="calibre9">super</code> when overriding a method in Swift. The <code class="calibre9">super</code> call will record the grade in the <code class="calibre9">grades</code> array because that behavior isn’t duplicated in <code class="calibre9">StudentAthlete</code>. Calling <code class="calibre9">super</code> is also a way of avoiding the need for duplicate code in <code class="calibre9">StudentAthlete</code> and <code class="calibre9">Student</code>.
</p>
<h3 class="segment-title2">When to call super</h3>

<p class="calibre1">As you may notice, exactly <i class="calibre2">when</i> you call super can significantly affect your overridden method.
</p>
<p class="calibre1">Suppose you replace the overriden <code class="calibre9">recordGrade(_:)</code> method in the <code class="calibre9">StudentAthlete</code> class with the following version that recalculates the <code class="calibre9">failedClasses</code> each time a grade is recorded:
</p><pre class="code-block"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
  <span class="hljs-keyword">var</span> newFailedClasses: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []
  <span class="hljs-keyword">for</span> grade <span class="hljs-keyword">in</span> grades {
    <span class="hljs-keyword">if</span> grade.letter <span class="hljs-operator">==</span> <span class="hljs-string">"F"</span> {
      newFailedClasses.append(grade)
    }
  }
  failedClasses <span class="hljs-operator">=</span> newFailedClasses

  <span class="hljs-keyword">super</span>.recordGrade(grade)
}</pre>
<p class="calibre1">This version of <code class="calibre9">recordGrade(_:)</code> uses the <code class="calibre9">grades</code> array to find the current list of failed classes. If you’ve spotted a bug in the code above, good job! Since you call <code class="calibre9">super</code> last, if the new <code class="calibre9">grade.letter</code> is an <code class="calibre9">F</code>, the code won’t update <code class="calibre9">failedClasses</code> properly.
</p>
<p class="calibre1">It’s best practice to call the <code class="calibre9">super</code> version of a method first when overriding. That way, the superclass won’t experience any side effects introduced by its subclass, and the subclass won’t need to know the superclass’s implementation details.
</p>
<h3 class="segment-title2">Preventing inheritance</h3>

<p class="calibre1">Sometimes you’ll want to disallow subclasses of a particular class. Swift provides the <code class="calibre9">final</code> keyword for you to guarantee a class will never get a subclass:
</p><pre class="code-block"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-number">FinalStudent</span>: <span class="hljs-number">Person</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-number">FinalStudentAthlete</span>: <span class="hljs-number">FinalStudent</span> {} <span class="hljs-comment">// Build error!</span></pre>
<p class="calibre1">By marking the <code class="calibre9">FinalStudent</code> class <code class="calibre9">final</code>, you tell the compiler to prevent any classes from inheriting from <code class="calibre9">FinalStudent</code>. This requirement can remind you &mdash; or others on your team! &mdash; that a class wasn’t designed to have subclasses.
</p>
<p class="calibre1">Additionally, you can mark individual <i class="calibre2">methods</i> as <code class="calibre9">final</code> if you want to allow a class to have subclasses, but protect individual methods from being overridden:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">AnotherStudent</span>: <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-number">AnotherStudentAthlete</span>: <span class="hljs-number">AnotherStudent</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {} <span class="hljs-comment">// Build error!</span>
}</pre>
<p class="calibre1">There are benefits to initially marking any new class you write as <code class="calibre9">final</code>. This keyword tells the compiler it doesn’t need to look for any more subclasses, which can shorten compile-time, and it also requires you to be very explicit when deciding to subclass a class previously marked <code class="calibre9">final</code>.  You’ll learn more about controlling who can override a class in Chapter 18, “Access Control, Code Organization &amp; Testing”.
</p>
<h2 class="segment-chapter1">Inheritance and class initialization</h2>

<p class="calibre1">Chapter 13, “Classes”, briefly introduced you to class initializers, which are similar to their struct counterparts. With subclasses, there are a few more considerations about how you set up instances.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In the chapter’s playground I have renamed <code class="calibre9">Student</code> and <code class="calibre9">StudentAthlete</code> to <code class="calibre9">NewStudent</code> and <code class="calibre9">NewStudentAthlete</code> in order to keep both versions working side-by-side.
</p></div>

<p class="calibre1">Modify the <code class="calibre9">StudentAthlete</code> class to add a list of sports an athlete plays:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> sports: [<span class="hljs-built_in">String</span>]
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">Because <code class="calibre9">sports</code> doesn’t have an initial value, <code class="calibre9">StudentAthlete</code> must provide one in its own initializer:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> sports: [<span class="hljs-built_in">String</span>]

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">sports</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.sports <span class="hljs-operator">=</span> sports
    <span class="hljs-comment">// Build error - super.init isn’t called before</span>
    <span class="hljs-comment">// returning from initializer</span>
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">Uh-oh! The compiler complains that you didn’t call <code class="calibre9">super.init</code> by the end of the initializer:
</p><div class="image3"><img src="images/000049.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Initializers in subclasses are <i class="calibre2">required</i> to call <code class="calibre9">super.init</code> because, without it, the superclass won’t be able to provide initial states for all its stored properties &mdash; in this case, <code class="calibre9">firstName</code> and <code class="calibre9">lastName</code>.
</p>
<p class="calibre1">Let’s make the compiler happy:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> sports: [<span class="hljs-built_in">String</span>]

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">sports</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.sports <span class="hljs-operator">=</span> sports
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(firstName: firstName, lastName: lastName)
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">The initializer now calls the initializer of its superclass, and the build error is gone.
</p>
<p class="calibre1">Notice that the initializer now takes in a <code class="calibre9">firstName</code> and a <code class="calibre9">lastName</code> to call the <code class="calibre9">Person</code> initializer.
</p>
<p class="calibre1">You also call <code class="calibre9">super.init</code> <i class="calibre2">after</i> you initialize the <code class="calibre9">sports</code> property, an enforced rule.
</p>
<h3 class="segment-title2">Two-phase initialization</h3>

<p class="calibre1">Because Swift’s requirement that all stored properties have initial values, initializers in subclasses must adhere to Swift’s convention of <em class="calibre5">two</em><em class="calibre5">-</em><em class="calibre5">phase initialization</em>.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Phase one:</em> Initialize all of the stored properties in the class instance, from the bottom to the top of the class hierarchy. You can’t use properties and methods until phase one is complete.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Phase two:</em> You can now use properties, methods and initializations that require the use of <code class="calibre9">self</code>.
</p></li>
</ul>

<p class="calibre1">Without two-phase initialization, methods and operations on the class might interact with properties before they’ve been initialized.
</p>
<p class="calibre1">The transition from phase one to phase two happens after you’ve initialized all stored properties in the base class of a class hierarchy.
</p>
<p class="calibre1">In the scope of a subclass initializer, you can think of this as coming after the call to <code class="calibre9">super.init</code>.
</p><div class="image3"><img src="images/000060.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Here’s the <code class="calibre9">StudentAthlete</code> class again, with athletes automatically getting a starter grade:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">var</span> sports: [<span class="hljs-built_in">String</span>]

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">sports</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">self</span>.sports <span class="hljs-operator">=</span> sports
    <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">let</span> passGrade <span class="hljs-operator">=</span> <span class="hljs-built_in">Grade</span>(letter: <span class="hljs-string">"P"</span>, points: <span class="hljs-number">0.0</span>, 
                          credits: <span class="hljs-number">0.0</span>)
    <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(firstName: firstName, lastName: lastName)
    <span class="hljs-comment">// 4</span>
    recordGrade(passGrade)
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">The above initializer shows two-phase initialization in action.
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">First, you initialize the <code class="calibre9">sports</code> property of <code class="calibre9">StudentAthlete</code>. This is part of the first phase of initialization and has to be done before you call the superclass initializer.
</p></li>

<li class="calibre4">
<p class="calibre1">Although you can create local variables for things like grades, you can’t call <code class="calibre9">recordGrade(_:)</code> yet because the object is still in the first phase.
</p></li>
</ol>

<ol start="3" class="calibre11">
<li class="calibre4">
<p class="calibre1">Call <code class="calibre9">super.init</code>. When this returns, you know that you’ve also initialized every class in the hierarchy because the same rules apply at every level.
</p></li>

<li class="calibre4">
<p class="calibre1">After <code class="calibre9">super.init</code> returns, the initializer is in phase 2, so you call <code class="calibre9">recordGrade(_:)</code>.
</p></li>
</ol>

<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">What’s different in the two-phase initialization in the base class <code class="calibre9">Person</code> compared to the others?
</p>
<h3 class="segment-title2">Required and convenience initializers</h3>

<p class="calibre1">You already know it’s possible to have multiple initializers in a class, which means you could potentially call <i class="calibre2">any</i> of those initializers from a subclass.
</p>
<p class="calibre1">Often, you’ll find that your classes have various initializers that simply provide a “convenient” way to initialize an object:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">let</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> lastName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">transfer</span>: <span class="hljs-built_in">Student</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> transfer.firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> transfer.lastName
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">recordGrade</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">grade</span>: <span class="hljs-built_in">Grade</span>) {
    grades.append(grade)
  }
}</pre>
<p class="calibre1">In this example, the <code class="calibre9">Student</code> class can be built with another <code class="calibre9">Student</code> object. Perhaps the student switched majors? Both initializers fully set the first and last names.
</p>
<p class="calibre1">Subclasses of <code class="calibre9">Student</code> could potentially rely on the <code class="calibre9">Student</code>-based initializer when they call <code class="calibre9">super.init</code>. Additionally, the subclasses might not even provide a method to initialize with first and last names.
</p>
<p class="calibre1">You might decide the first and last name-based initializer is important enough that you want it to be available to <i class="calibre2">all</i> subclasses.
</p>
<p class="calibre1">Swift supports this through the language feature known as <em class="calibre5">required initializers</em>.
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">let</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> lastName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">In the modified version of <code class="calibre9">Student</code> above, the first and last name-based initializer has been marked with the keyword <code class="calibre9">required</code>. This keyword will force all subclasses of <code class="calibre9">Student</code> to implement this initializer.
</p>
<p class="calibre1">Now that there’s a required initializer on <code class="calibre9">Student</code>, <code class="calibre9">StudentAthlete</code> <i class="calibre2">must</i> override and implement it.
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StudentAthlete</span>: <span class="hljs-number">Student</span> {
  <span class="hljs-comment">// Now required by the compiler!</span>
  <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.sports <span class="hljs-operator">=</span> []
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(firstName: firstName, lastName: lastName)
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">Notice how the <code class="calibre9">override</code> keyword isn’t needed with required initializers. In its place, the <code class="calibre9">required</code> keyword must be used to make sure that any subclass of <code class="calibre9">StudentAthlete</code> still implements this required initializer.
</p>
<p class="calibre1">You can also mark an initializer as a <em class="calibre5">convenience</em> initializer:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">transfer</span>: <span class="hljs-built_in">Student</span>) {
    <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(firstName: transfer.firstName, 
              lastName: transfer.lastName)
  }
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">The compiler forces a <code class="calibre9">convenience</code> initializer to call a non-convenience initializer (directly or indirectly) instead of handling the initialization of stored properties itself. A non-convenience initializer is called a <em class="calibre5">designated</em> initializer and is subject to the rules of two-phase initialization. All initializers you’ve written in previous examples were, in fact, designated initializers.
</p>
<p class="calibre1">You might want to mark an initializer as <code class="calibre9">convenience</code> if you only use that initializer as an easy way to initialize an object. However, you still want it to leverage one of your designated initializers.
</p>
<p class="calibre1">Here’s a summary of the compiler rules for using designated and convenience initializers:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">A designated initializer must call a designated initializer from its immediate superclass.
</p></li>

<li class="calibre4">
<p class="calibre1">A convenience initializer must call another initializer from the same class.
</p></li>

<li class="calibre4">
<p class="calibre1">A convenience initializer must ultimately call a designated initializer.
</p></li>
</ol>

<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Create two more convenience initializers on <code class="calibre9">Student</code>. Which other initializers are you able to call?
</p>
<h2 class="segment-chapter1">When and why to subclass</h2>

<p class="calibre1">This chapter has introduced you to class inheritance, along with the numerous programming techniques that subclassing enables.
</p>
<p class="calibre1">But you might be asking, “When should I subclass?”
</p>
<p class="calibre1">Rarely is there a right or wrong answer, so you need an understanding of the trade-offs so you can make an informed decision for a particular case.
</p>
<p class="calibre1">Using the <code class="calibre9">Student</code> and <code class="calibre9">StudentAthlete</code> classes as an example, you might decide you can simply put all of the characteristics of <code class="calibre9">StudentAthlete</code> into <code class="calibre9">Student</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> grades: [<span class="hljs-built_in">Grade</span>]
  <span class="hljs-keyword">var</span> sports: [<span class="hljs-built_in">Sport</span>]
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">In reality, this <i class="calibre2">could</i> solve all of the use cases for your needs. A <code class="calibre9">Student</code> that doesn’t play sports would simply have an empty <code class="calibre9">sports</code> array, and you would avoid some of the added complexities of subclassing.
</p>
<h3 class="segment-title2">Adhering to the single responsibility principle</h3>

<p class="calibre1">The guideline known as the <em class="calibre5">single responsibility principle</em> in software development states that any entity should have a single concern. Having more components with a single responsibility makes it easier to mix and match (compose) your components to build up functionality.  When it comes time to change and add features, it is easier to augment your system when everything has a single, well-understood job.
</p>
<p class="calibre1">This principle is true for object-oriented design.  For example, in <code class="calibre9">Student</code>/<code class="calibre9">StudentAthlete</code>, you might argue that it shouldn’t be the <code class="calibre9">Student</code> class’s job to encapsulate responsibilities that only make sense to student-athletes. That way, if you later need to support students in student government, you can do so without worrying about their athletic standing.
</p>
<h3 class="segment-title2">Leveraging strong types</h3>

<p class="calibre1">Subclassing creates an additional type. With Swift’s type system, you can declare properties or behavior based on objects that are student-athletes, not regular students:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Team</span> {
  <span class="hljs-keyword">var</span> players: [<span class="hljs-built_in">StudentAthlete</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">var</span> isEligible: <span class="hljs-built_in">Bool</span> {
    <span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players {
      <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>player.isEligible {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
  }
}</pre>
<p class="calibre1">A team has players who are student-athletes. If you tried to add a regular <code class="calibre9">Student</code> object to the array of players, the type system wouldn’t allow it. This new type is helpful as the compiler can help you enforce the logic and requirement of your system.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: This is also where single-inheritance classes in Swift fall a bit short. This design might not work if you later added a <code class="calibre9">StudentPresident</code> type, but the student president was on the track team one year. To overcome this limitation, Swift also comes with protocol inheritance which effectively allows multiple inheritances.  You will learn about this in Chapter 16, “Protocols” and Chapter 27, “Protocol-Oriented Programming.”
</p></div>

<h3 class="segment-title2">Shared base classes</h3>

<p class="calibre1">You can subclass a shared base class multiple times by classes that have mutually exclusive behavior:
</p><pre class="code-block"><span class="hljs-comment">// A button that can be pressed.</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Button</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">press</span>() {}
}

<span class="hljs-comment">// An image that can be rendered on a button</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Image</span> {}

<span class="hljs-comment">// A button that is composed entirely of an image.</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">ImageButton</span>: <span class="hljs-number">Button</span> {
  <span class="hljs-keyword">var</span> image: <span class="hljs-built_in">Image</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">image</span>: <span class="hljs-built_in">Image</span>) {
    <span class="hljs-keyword">self</span>.image <span class="hljs-operator">=</span> image
  }
}

<span class="hljs-comment">// A button that renders as text.</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">TextButton</span>: <span class="hljs-number">Button</span> {
  <span class="hljs-keyword">var</span> text: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">text</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text
  }
}</pre>
<p class="calibre1">In this example, you can imagine numerous <code class="calibre9">Button</code> subclasses sharing only that they can be pressed. The <code class="calibre9">ImageButton</code> and <code class="calibre9">TextButton</code> classes likely use different mechanisms to render a given button, so they might have to implement their own behavior to handle presses. You can see here how storing <code class="calibre9">image</code> and <code class="calibre9">text</code> in the <code class="calibre9">Button</code> class &mdash; not to mention any other kind of button there might be &mdash;  would quickly become impractical. It makes sense for <code class="calibre9">Button</code> to be concerned with the press behavior and the subclasses to handle the actual look and feel of the button.
</p>
<h3 class="segment-title2">Extensibility</h3>

<p class="calibre1">Sometimes you need to extend the behavior of code you don’t own. In the example above, it’s possible <code class="calibre9">Button</code> is part of a framework you’re using, so there’s no way you can modify or extend the source code to fit your specific case.
</p>
<p class="calibre1">But you can subclass <code class="calibre9">Button</code> and add your custom subclass to use with code that’s expecting an object of type <code class="calibre9">Button</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In addition to flagging a class as <code class="calibre9">final</code>, you can use access control, which you’ll learn in Chapter 18, “Access Control, Code Organization &amp; Testing”, to designate if any of the members of a class can be subclassed &mdash; aka overridden &mdash; or not.
</p></div>

<h3 class="segment-title2">Identity</h3>

<p class="calibre1">Finally, it’s important to understand that classes and class hierarchies model what objects <i class="calibre2">are</i>. If your goal is to share behavior (what objects <i class="calibre2">can do</i>) between types, more often than not, you should prefer protocols over subclassing. Again, you’ll learn about protocols in Chapter 16, “Protocols”.
</p>
<h2 class="segment-chapter1">Understanding the class lifecycle</h2>

<p class="calibre1">In Chapter 13, “Classes”, you learned that objects are created in memory and stored on the heap. Objects on the heap are <i class="calibre2">not</i> automatically destroyed because the heap is simply a giant pool of memory. Without the utility of the call stack, there’s no automatic way for a process to know that a piece of memory will no longer be in use.
</p>
<p class="calibre1">In Swift, the mechanism for deciding when to clean up unused objects on the heap is known as <em class="calibre5">reference counting</em>. Each object has a reference count that’s incremented for each constant or variable with a reference to that object and decremented each time a reference is removed.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You might see the reference count called a “retain count” in other books and online resources. They refer to the same thing!
</p></div>

<p class="calibre1">When a reference count reaches zero, that means the object is now abandoned since nothing in the system holds a reference to it. When that happens, Swift will clean up the object.
</p>
<p class="calibre1">Here’s a demonstration of how the reference count changes for an object. Note that there’s only one actual object created in this example; the one object just has many references to it.
</p><pre class="code-block"><span class="hljs-keyword">var</span> someone <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-comment">// Person object has a reference count of 1 (someone variable)</span>

<span class="hljs-keyword">var</span> anotherSomeone: <span class="hljs-built_in">Person</span>? <span class="hljs-operator">=</span> someone
<span class="hljs-comment">// Reference count 2 (someone, anotherSomeone)</span>

<span class="hljs-keyword">var</span> lotsOfPeople <span class="hljs-operator">=</span> [someone, someone, anotherSomeone, someone]
<span class="hljs-comment">// Reference count 6 (someone, anotherSomeone, 4 references in lotsOfPeople)</span>

anotherSomeone <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
<span class="hljs-comment">// Reference count 5 (someone, 4 references in lotsOfPeople)</span>

lotsOfPeople <span class="hljs-operator">=</span> []
<span class="hljs-comment">// Reference count 1 (someone)</span></pre>
<p class="calibre1">Now we create another object and replace someone with that reference.
</p><pre class="code-block">someone <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(firstName: <span class="hljs-string">"Johnny"</span>, lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-comment">// Reference count 0 for the original Person object!</span>
<span class="hljs-comment">// Variable someone now references a new object</span></pre>
<p class="calibre1">In this example, you don’t have to do any work yourself to increase or decrease the object’s reference count. That’s because Swift has a feature known as <em class="calibre5">automatic reference counting</em> or <em class="calibre5">ARC</em>. While some older languages require you to increment and decrement reference counts in <i class="calibre2">your</i> code, the Swift compiler adds these calls automatically at compile-time.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: If you use a low-level language like C, you’re required to manually free memory you’re no longer using yourself. Higher-level languages like Java and C# use something called <em class="calibre5">garbage collection</em>. In that case, the language’s runtime will search your process for references to objects before cleaning up those that are no longer in use. While more automatic and behind the scenes than ARC, Garbage collection comes with a memory utilization and performance cost that Apple decided wasn’t acceptable for mobile devices or a general systems language.
</p></div>

<h3 class="segment-title2">Deinitialization</h3>

<p class="calibre1">Swift removes the object from memory and marks that memory as free when an object’s reference count reaches zero.
</p>
<p class="calibre1">A <em class="calibre5">deinitializer</em> is a special method on classes that runs when an object’s reference count reaches zero but before Swift removes the object from memory.
</p>
<p class="calibre1">Modify <code class="calibre9">Person</code> as follows:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-comment">// original code</span>
  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(firstName)</span> <span class="hljs-subst">\(lastName)</span> is being removed
          from memory!"</span>)
  }
}</pre>
<p class="calibre1">Much like <code class="calibre9">init</code> is a special method in class initialization, <code class="calibre9">deinit</code> is a special method that handles deinitialization. Unlike <code class="calibre9">init</code>, <code class="calibre9">deinit</code> isn’t required and is automatically invoked by Swift. You also aren’t required to override it or call <code class="calibre9">super</code> within it. Swift will make sure to call each class deinitializer.
</p>
<p class="calibre1">If you add this deinitializer, you’ll see the message <code class="calibre9">Johnny Appleseed is being removed from memory!</code> in the debug area after running the previous example.
</p>
<p class="calibre1">What you do in a deinitializer is up to you. Often you’ll use it to clean up other resources, save state to a disk or execute any other logic you might want when an object goes out of scope.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<p class="calibre1">Modify the <code class="calibre9">Student</code> class to have the ability to record the student’s name to a list of graduates. Add the name of the student to the list when the object is deallocated.
</p>
<h3 class="segment-title2">Retain cycles and weak references</h3>

<p class="calibre1">Because classes in Swift rely on reference counting to remove them from memory, it’s essential to understand the concept of a <em class="calibre5">retain cycle</em>.
</p>
<p class="calibre1">Add a field representing a classmate &mdash; for example, a lab partner &mdash; and a deinitializer to class <code class="calibre9">Student</code> like this:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> partner: <span class="hljs-built_in">Student</span>?
  <span class="hljs-comment">// original code</span>
  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(firstName)</span> is being deallocated!"</span>)
  }
}

<span class="hljs-keyword">var</span> alice: <span class="hljs-built_in">Student</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Alice"</span>,
                              lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-keyword">var</span> bob: <span class="hljs-built_in">Student</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(firstName: <span class="hljs-string">"Bob"</span>,
                            lastName: <span class="hljs-string">"Appleseed"</span>)

alice<span class="hljs-operator">?</span>.partner <span class="hljs-operator">=</span> bob
bob<span class="hljs-operator">?</span>.partner <span class="hljs-operator">=</span> alice</pre>
<p class="calibre1">Now suppose both <code class="calibre9">alice</code> and <code class="calibre9">bob</code> drop out of school:
</p><pre class="code-block">alice <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
bob <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<p class="calibre1">If you run this in your playground, you’ll notice that you don’t see the message <code class="calibre9">Alice/Bob is being deallocated!</code>, and Swift doesn’t call <code class="calibre9">deinit</code>. Why is that?
</p>
<p class="calibre1">Alice and Bob each have a reference to <i class="calibre2">each other</i>, so the reference count never reaches zero! To make things worse, by assigning <code class="calibre9">nil</code> to <code class="calibre9">alice</code> and <code class="calibre9">bob</code>, there are no more references to the initial objects. This situation is a classic case of a retain cycle, which leads to a software bug known as a <em class="calibre5">memory leak</em>.
</p>
<p class="calibre1">With a memory leak, memory isn’t freed up even though its practical lifecycle has ended. Retain cycles are the most common cause of memory leaks. Fortunately, there’s a way that the <code class="calibre9">Student</code> object can reference another <code class="calibre9">Student</code> without being prone to retain cycles, and that’s by making the reference <em class="calibre5">weak</em>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> partner: <span class="hljs-built_in">Student</span>?
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">This simple modification marks the <code class="calibre9">partner</code> variable as <code class="calibre9">weak</code>, which means the reference in this variable will not take part in reference counting. When a reference isn’t weak, it’s called a <em class="calibre5">strong reference</em>, which is the default in Swift. Weak references must be declared as optional types so that when the object they are referencing is released, it automatically becomes <code class="calibre9">nil</code>.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your advanced classes knowledge. It’s best to try and solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Initialization order</h3>

<p class="calibre1">Create three simple classes called <code class="calibre9">A</code>, <code class="calibre9">B</code>, and <code class="calibre9">C</code> where <code class="calibre9">C</code> inherits from <code class="calibre9">B</code> and <code class="calibre9">B</code> inherits from <code class="calibre9">A</code>. In each class initializer, call <code class="calibre9">print("I’m &lt;X&gt;!")</code> both before and after <code class="calibre9">super.init()</code>. Create an instance of <code class="calibre9">C</code> called <code class="calibre9">c</code>.  What order do you see each <code class="calibre9">print()</code> called in?
</p>
<h3 class="segment-title2">Challenge 2: Deinitialization order</h3>

<p class="calibre1">Implement <code class="calibre9">deinit</code> for each class. Create your instance <code class="calibre9">c</code> inside of a <code class="calibre9">do { }</code> scope, causing the reference count to go to zero when it exits the scope. Which order do the classes deinitialize?
</p>
<h3 class="segment-title2">Challenge 3: Type casting</h3>

<p class="calibre1">Cast the instance of type <code class="calibre9">C</code> to an instance of type <code class="calibre9">A</code>. Which casting operation do you use and why?
</p>
<h3 class="segment-title2">Challenge 4: To subclass or not</h3>

<p class="calibre1">Create a subclass of <code class="calibre9">StudentAthlete</code> called <code class="calibre9">StudentBaseballPlayer</code> and include properties for <code class="calibre9">position</code>, <code class="calibre9">number</code>, and <code class="calibre9">battingAverage</code>.  What are the benefits and drawbacks of subclassing <code class="calibre9">StudentAthlete</code> in this scenario?
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Class inheritance</em> is one of the most important features of classes and enables <em class="calibre5">polymorphism</em>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Subclassing</em> is a powerful tool, but it’s good to know when to subclass. Subclass when you want to extend an object and could benefit from an “is-a” relationship between subclass and superclass, but be mindful of the inherited state and deep class hierarchies.
</p></li>

<li class="calibre4">
<p class="calibre1">The keyword <i class="calibre2">override</i> makes it clear when you are overriding a method in a subclass.
</p></li>

<li class="calibre4">
<p class="calibre1">The keyword <i class="calibre2">final</i> can be used to prevent a class from being subclassed.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift classes use <em class="calibre5">two</em><em class="calibre5">-</em><em class="calibre5">phase initialization</em> as a safety measure to ensure all stored properties are initialized before they are used.
</p></li>

<li class="calibre4">
<p class="calibre1">Class instances have lifecycles which their <em class="calibre5">reference counts</em> control.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Automatic reference counting</em>, or <em class="calibre5">ARC</em>, handles reference counting for you automatically, but it’s essential to watch out for <em class="calibre5">retain cycles</em>.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-22">


<h1 class="segment-chapter">Chapter 15: Enumerations</h1>

<p class="calibre1">One day in your life as a developer, you’ll realize you’re being held captive by your laptop. Determined to break from convention, you’ll decide to set off on a long trek by foot. Of course, you’ll need a map of the terrain you’ll encounter. Since it’s the 21st century, and you’re fluent in Swift, you’ll complete one final project: a custom map app.
</p>
<p class="calibre1">As you code away, you think it would be swell to represent the cardinal directions as variables: north, south, east, west. But what’s the best way to do this in code?
</p>
<p class="calibre1">You could represent each value as an integer, like so:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">North: <code class="calibre9">1</code>
</p></li>

<li class="calibre4">
<p class="calibre1">South: <code class="calibre9">2</code>
</p></li>

<li class="calibre4">
<p class="calibre1">East: <code class="calibre9">3</code>
</p></li>

<li class="calibre4">
<p class="calibre1">West: <code class="calibre9">4</code>
</p></li>
</ul>

<p class="calibre1">You can see how this could quickly get confusing if you or your users happen to think of the directions in a different order. “What does 3 mean again?” To alleviate that, you might represent the values as strings, like so:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">North: <code class="calibre9">"north"</code>
</p></li>

<li class="calibre4">
<p class="calibre1">South: <code class="calibre9">"south"</code>
</p></li>

<li class="calibre4">
<p class="calibre1">East: <code class="calibre9">"east"</code>
</p></li>

<li class="calibre4">
<p class="calibre1">West: <code class="calibre9">"west"</code>
</p></li>
</ul>

<p class="calibre1">The trouble with strings, though, is that the value can be any string. What would your app do if it received <code class="calibre9">"up"</code> instead of <code class="calibre9">"north"</code>? Furthermore, it’s all too easy to make a typo like <code class="calibre9">"nrth"</code>.
</p>
<p class="calibre1">Wouldn’t it be great if there were a way to create a group of related, compiler-checked values? If you find yourself headed in this… <i class="calibre2">direction</i>, you’ll want to use an <em class="calibre5">enumeration</em>.
</p>
<p class="calibre1">An enumeration is a list of related values that define a common type and let you work with values in a type-safe way. The compiler will catch your mistake if your code expects a <code class="calibre9">Direction</code> and you try to pass in a float like <code class="calibre9">10.7</code> or a misspelled direction like <code class="calibre9">"Souuth"</code>.
</p>
<p class="calibre1">Besides cardinal directions, other good examples of related values are colors (black, red, blue), card suits (hearts, spades, clubs, diamonds) and roles (administrator, editor, reader).
</p><div class="image5"><img src="images/000082.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Enumerations in Swift are more powerful than they are in other languages such as C or Objective-C. They share features with the structure and class types you learned about in Chapter 10, “Structures”, and Chapter 13, “Classes”. An enumeration can have methods and computed properties, all while acting as a convenient state machine.
</p>
<p class="calibre1">In this chapter, you’ll learn how enumerations work and when they’re useful. As a bonus, you’ll finally discover what an optional is under the hood. Hint: They are implemented with enumerations!
</p>
<h2 class="segment-chapter1">Your first enumeration</h2>

<p class="calibre1">Your challenge: construct a function that will determine the school semester based on the month. One way to solve this would be to use an array of strings and match the semesters with a <code class="calibre9">switch</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">let</span> months <span class="hljs-operator">=</span> [<span class="hljs-string">"January"</span>, <span class="hljs-string">"February"</span>, <span class="hljs-string">"March"</span>, <span class="hljs-string">"April"</span>, <span class="hljs-string">"May"</span>,
              <span class="hljs-string">"June"</span>, <span class="hljs-string">"July"</span>, <span class="hljs-string">"August"</span>, <span class="hljs-string">"September"</span>, <span class="hljs-string">"October"</span>,
              <span class="hljs-string">"November"</span>, <span class="hljs-string">"December"</span>]

<span class="hljs-keyword">func</span> <span class="hljs-number">semester</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">month</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">switch</span> month {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"August"</span>, <span class="hljs-string">"September"</span>, <span class="hljs-string">"October"</span>, <span class="hljs-string">"November"</span>, <span class="hljs-string">"December"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Autumn"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">"January"</span>, <span class="hljs-string">"February"</span>, <span class="hljs-string">"March"</span>, <span class="hljs-string">"April"</span>, <span class="hljs-string">"May"</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Spring"</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not in the school year"</span>
  }
}

semester(for: <span class="hljs-string">"April"</span>) <span class="hljs-comment">// Spring</span></pre>
<p class="calibre1">Running this code in a playground, you can see that the function correctly returns <code class="calibre9">"Spring"</code>. But as I mentioned in the introduction, you could easily mistype a string. A better way to tackle this would be with an enumeration.
</p>
<h3 class="segment-title2">Declaring an enumeration</h3>

<p class="calibre1">To declare an enumeration, you list out all the possible member values as <code class="calibre9">case</code> clauses:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span> {
  <span class="hljs-keyword">case</span> january
  <span class="hljs-keyword">case</span> february
  <span class="hljs-keyword">case</span> march
  <span class="hljs-keyword">case</span> april
  <span class="hljs-keyword">case</span> may
  <span class="hljs-keyword">case</span> june
  <span class="hljs-keyword">case</span> july
  <span class="hljs-keyword">case</span> august
  <span class="hljs-keyword">case</span> september
  <span class="hljs-keyword">case</span> october
  <span class="hljs-keyword">case</span> november
  <span class="hljs-keyword">case</span> december
}</pre>
<p class="calibre1">This code creates a new enumeration called <code class="calibre9">Month</code> with 12 possible member values. The commonly accepted best practice is to start each member value with a lower case first letter, just like a property.
</p>
<p class="calibre1">You can simplify the code a bit by collapsing the <code class="calibre9">case</code> clauses down to one line, with each value separated by a comma:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span> {
  <span class="hljs-keyword">case</span> january, february, march, april, may, june, july, august,
  september, october, november, december
}</pre>
<p class="calibre1">That looks snazzy and simple. So far, so good.
</p>
<h3 class="segment-title2">Deciphering an enumeration in a function</h3>

<p class="calibre1">You can rewrite the function that determines the semester so that it uses enumeration values instead of string-matching.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">semester</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">month</span>: <span class="hljs-built_in">Month</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">switch</span> month {
  <span class="hljs-keyword">case</span> <span class="hljs-built_in">Month</span>.august, <span class="hljs-built_in">Month</span>.september, <span class="hljs-built_in">Month</span>.october,
       <span class="hljs-built_in">Month</span>.november, <span class="hljs-built_in">Month</span>.december:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Autumn"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-built_in">Month</span>.january, <span class="hljs-built_in">Month</span>.february, <span class="hljs-built_in">Month</span>.march, <span class="hljs-built_in">Month</span>.april,
       <span class="hljs-built_in">Month</span>.may:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Spring"</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not in the school year"</span>
  }
}</pre>
<p class="calibre1">Since Swift is strongly typed and uses type inference, you can simplify <code class="calibre9">semester(for:)</code> by removing the enumeration name in places where the compiler already knows the type. Keep the dot prefix, but lose the enumeration name, as shown below for the cases inside the <code class="calibre9">switch</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">semester</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">month</span>: <span class="hljs-built_in">Month</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">switch</span> month {
  <span class="hljs-keyword">case</span> .august, .september, .october, .november, .december:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Autumn"</span>
  <span class="hljs-keyword">case</span> .january, .february, .march, .april, .may:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Spring"</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not in the school year"</span>
  }
}</pre>
<p class="calibre1">Also, recall that <code class="calibre9">switch</code> statements must be exhaustive with their cases. The compiler will warn you if they aren’t. When case patterns are <code class="calibre9">String</code> elements, you need a <code class="calibre9">default</code> case because it’s impossible to create cases to match every possible <code class="calibre9">String</code> value. However, enumerations have a limited set of values you can match against. So if you have cases for each member value of the enumeration, you can safely remove the <code class="calibre9">default</code> case of the <code class="calibre9">switch</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">semester</span>(<span class="hljs-built_in">for</span> <span class="hljs-built_in">month</span>: <span class="hljs-built_in">Month</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">switch</span> month {
  <span class="hljs-keyword">case</span> .august, .september, .october, .november, .december:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Autumn"</span>
  <span class="hljs-keyword">case</span> .january, .february, .march, .april, .may:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Spring"</span>
  <span class="hljs-keyword">case</span> .june, .july:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Summer"</span>
  }
}</pre>
<p class="calibre1">That’s much more readable. There is another huge benefit to getting rid of the <code class="calibre9">default</code>. If, in a future update, someone added <code class="calibre9">.undecember</code> or <code class="calibre9">.duodecember</code> to the Month enumeration, the compiler would automatically flag this and any other <code class="calibre9">switch</code> statement as being non-exhaustive, allowing you to handle this specific case.
</p>
<p class="calibre1">You can test this function in a playground like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> month <span class="hljs-operator">=</span> <span class="hljs-built_in">Month</span>.april
semester(for: month) <span class="hljs-comment">// "Spring"</span>

month <span class="hljs-operator">=</span> .september
semester(for: month) <span class="hljs-comment">// "Autumn"</span></pre>
<p class="calibre1">The variable declaration for <code class="calibre9">month</code> uses the full enumeration type and value. You can use the shorthand <code class="calibre9">.september</code> in the second assignment since the compiler already knows the type. Finally, you pass both months to <code class="calibre9">semester(for:)</code>, where a <code class="calibre9">switch</code> statement returns the strings <code class="calibre9">"Spring"</code> and <code class="calibre9">"Autumn"</code> respectively.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Wouldn’t it be nice to request the semester from an instance like <code class="calibre9">month.semester</code> instead of using the function? Add a <code class="calibre9">semester</code> computed property to the <code class="calibre9">month</code> enumeration so that you can run this code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> semester <span class="hljs-operator">=</span> month.semester <span class="hljs-comment">// "Autumn"</span></pre>
<h3 class="segment-title2">Code completion prevents typos</h3>

<p class="calibre1">Another advantage of using enumerations instead of strings is that you’ll never have a typo in your member values. Xcode provides code completion:
</p><div class="image10"><img src="images/000094.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">And if you do misspell an enumeration value, the compiler will complain with an error, so you won’t get too far down the line without recognizing your mistake:
</p><div class="image3"><img src="images/000106.png" alt="" title="" class="calibre7" /></div>
<h2 class="segment-chapter1">Raw values</h2>

<p class="calibre1">Unlike enumeration values in C, Swift <code class="calibre9">enum</code> values are <i class="calibre2">not</i> backed by integers as a default. That means <code class="calibre9">january</code> is <i class="calibre2">itself</i> the value.
</p>
<p class="calibre1">You can specify that an integer backs the enumeration by declaring it with <code class="calibre9">: Int</code> like this:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span>: <span class="hljs-number">Int</span> {</pre>
<p class="calibre1">Swift enumerations are flexible: you can specify other raw value types like <code class="calibre9">String</code>, <code class="calibre9">Float</code> or <code class="calibre9">Character</code>. As in C, if you use integers and don’t specify values as you’ve done here, Swift will automatically assign the values 0, 1, 2 and up.
</p>
<p class="calibre1">In this case, it would be better if January had the raw value of <code class="calibre9">1</code> rather than <code class="calibre9">0</code>. To specify your own raw values, use the <code class="calibre9">=</code> assignment operator:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span>: <span class="hljs-number">Int</span> {
  <span class="hljs-keyword">case</span> january <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, february <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, march <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, april <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, may <span class="hljs-operator">=</span> <span class="hljs-number">5</span>,
  june <span class="hljs-operator">=</span> <span class="hljs-number">6</span>, july <span class="hljs-operator">=</span> <span class="hljs-number">7</span>, august <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, september <span class="hljs-operator">=</span> <span class="hljs-number">9</span>,
  october <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, november <span class="hljs-operator">=</span> <span class="hljs-number">11</span>, december <span class="hljs-operator">=</span> <span class="hljs-number">12</span>
}</pre>
<p class="calibre1">This code assigns an integer value to each enumeration case.
</p>
<p class="calibre1">There’s another handy shortcut here: the compiler will automatically increment the values if you provide the first one and leave out the rest:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span>: <span class="hljs-number">Int</span> {
  <span class="hljs-keyword">case</span> january <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, february, march, april, may, june, july,
  august, september, october, november, december
}</pre>
<p class="calibre1">You can use the enumeration values alone and never refer to the raw values if you don’t want to. But the raw values will be there behind the scenes if you ever do need them!
</p>
<h3 class="segment-title2">Accessing the raw value</h3>

<p class="calibre1">Enumeration instances with raw values have a handy <code class="calibre9">rawValue</code> property. With the raw values in place, your enumeration has a sense of order, and you can calculate the number of months left until winter break:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">monthsUntilWinterBreak</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">month</span>: <span class="hljs-built_in">Month</span>) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-built_in">Month</span>.december.rawValue <span class="hljs-operator">-</span> month.rawValue
}
monthsUntilWinterBreak(from: .april) <span class="hljs-comment">// 8</span></pre>
<h3 class="segment-title2">Initializing with the raw value</h3>

<p class="calibre1">You can use the raw value to instantiate an enumeration value with an initializer. You can use <code class="calibre9">init(rawValue:)</code> to do this, but if you try to use the value afterward, you’ll get an error:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fifthMonth <span class="hljs-operator">=</span> <span class="hljs-built_in">Month</span>(rawValue: <span class="hljs-number">5</span>)
monthsUntilWinterBreak(from: fifthMonth) <span class="hljs-comment">// Error: not unwrapped</span></pre>
<p class="calibre1">There’s no guarantee that the raw value you submitted exists in the enumeration, so the initializer returns an optional. You could have used <code class="calibre9">13</code> as the input for a month that does not exist. Enumeration initializers with the <code class="calibre9">rawValue:</code> parameter are <em class="calibre5">failable initializers</em>, meaning if things go wrong, the initializer will return <code class="calibre9">nil</code>.
</p>
<p class="calibre1">If you’re using these raw value initializers in your own projects, remember that they return optionals. If you’re unsure if the raw value is correct, you’ll need to either check for <code class="calibre9">nil</code> or use optional binding. In this case, the value <code class="calibre9">5</code> must be correct, so it’s appropriate to force unwrap the optional:
</p><pre class="code-block"><span class="hljs-keyword">let</span> fifthMonth <span class="hljs-operator">=</span> <span class="hljs-built_in">Month</span>(rawValue: <span class="hljs-number">5</span>)<span class="hljs-operator">!</span> <span class="hljs-comment">// may</span>
monthsUntilWinterBreak(from: fifthMonth) <span class="hljs-comment">// 7</span></pre>
<p class="calibre1">That’s better! You used the exclamation mark, <code class="calibre9">!</code>, to force unwrap the optional. Now there’s no error, and <code class="calibre9">monthsUntilWinterBreak(from:)</code> returns <code class="calibre9">7</code> as expected.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Make <code class="calibre9">monthsUntilWinterBreak</code> a computed property of the <code class="calibre9">Month</code> enumeration, so that you can execute the following code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> monthsLeft <span class="hljs-operator">=</span> fifthMonth.monthsUntilWinterBreak <span class="hljs-comment">// 7</span></pre>
<h3 class="segment-title2">String raw values</h3>

<p class="calibre1">Similar to the handy trick of incrementing an <code class="calibre9">Int</code> raw value, if you specify a raw value type of <code class="calibre9">String</code>, you’ll get another automatic conversion. Let’s pretend you’re building a news app that has tabs for each section. Each section has an icon. Icons are a good opportunity to deploy enumerations because, by their nature, they are a limited set:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">enum</span> <span class="hljs-number">Icon</span>: <span class="hljs-number">String</span> {
  <span class="hljs-keyword">case</span> music
  <span class="hljs-keyword">case</span> sports
  <span class="hljs-keyword">case</span> weather

  <span class="hljs-keyword">var</span> filename: <span class="hljs-built_in">String</span> {
    <span class="hljs-comment">// 2</span>
    <span class="hljs-string">"<span class="hljs-subst">\(rawValue)</span>.png"</span>
  }
}
<span class="hljs-keyword">let</span> icon <span class="hljs-operator">=</span> <span class="hljs-built_in">Icon</span>.weather
icon.filename <span class="hljs-comment">// weather.png</span></pre>
<p class="calibre1">Here’s what’s happening in this code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The enumeration sports a <code class="calibre9">String</code> raw value type.
</p></li>

<li class="calibre4">
<p class="calibre1">Calling <code class="calibre9">rawValue</code> inside the enumeration definition is equivalent to calling <code class="calibre9">self.rawValue</code>. Since the raw value is a string, you can use it to build a file name.
</p></li>
</ol>

<p class="calibre1">Note you didn’t have to specify a <code class="calibre9">String</code> for each member value. If you set the raw value type of the enumeration to <code class="calibre9">String</code> and don’t specify any raw values yourself, the compiler will use the enumeration case names as raw values. The <code class="calibre9">filename</code> computed property will generate an image asset name for you. You can now fetch and display images for the tab icons in your app.
</p>
<p class="calibre1">Next, let’s jump back to working with raw numerical values and learn how to use enumerations for banking.
</p>
<h3 class="segment-title2">Unordered raw values</h3>

<p class="calibre1">Integer raw values don’t have to be in an incremental order. Coins are a good use case:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Coin</span>: <span class="hljs-number">Int</span> {
  <span class="hljs-keyword">case</span> penny <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">case</span> nickel <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
  <span class="hljs-keyword">case</span> dime <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
  <span class="hljs-keyword">case</span> quarter <span class="hljs-operator">=</span> <span class="hljs-number">25</span>
}</pre><div class="image11"><img src="images/000115.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can instantiate values of this type and access their raw values as usual:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coin <span class="hljs-operator">=</span> <span class="hljs-built_in">Coin</span>.quarter
coin.rawValue <span class="hljs-comment">// 25</span></pre>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Create an array called <code class="calibre9">coinPurse</code> that contains coins. Add an assortment of pennies, nickels, dimes and quarters to it.
</p>
<h2 class="segment-chapter1">Associated values</h2>

<p class="calibre1">Associated values take Swift enumerations to the next level in expressive power. They let you associate a custom value (or values) with each enumeration case.
</p>
<p class="calibre1">Here are some unique qualities of associated values:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Each enumeration case has zero or more associated values.
</p></li>

<li class="calibre4">
<p class="calibre1">The associated values for each enumeration case have their own data type.
</p></li>

<li class="calibre4">
<p class="calibre1">You can define associated values with label names as you would for named function parameters.
</p></li>
</ol>

<p class="calibre1">An enumeration can have raw values or associated values, but not both.
</p>
<p class="calibre1">In the last mini-exercise, you defined a coin purse. Let’s say you took your money to the bank and deposited it. You could then go to an ATM and withdraw your money:
</p><pre class="code-block"><span class="hljs-keyword">var</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">100</span>

<span class="hljs-keyword">func</span> <span class="hljs-number">withdraw</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Int</span>) {
  balance <span class="hljs-operator">-=</span> amount
}</pre>
<p class="calibre1">The ATM will never let you withdraw more than you put in, so it needs a way to let you know whether the transaction was successful. You can implement this as an enumeration with associated values:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">WithdrawalResult</span> {
  <span class="hljs-keyword">case</span> success(newBalance: <span class="hljs-built_in">Int</span>)
  <span class="hljs-keyword">case</span> error(message: <span class="hljs-built_in">String</span>)
}</pre>
<p class="calibre1">Each case has a required value to go along with it. For the success case, the associated <code class="calibre9">Int</code> will hold the new balance; for the error case, the associated <code class="calibre9">String</code> will have some kind of error message.
</p>
<p class="calibre1">Then you can rewrite the <code class="calibre9">withdraw</code> function to use the enumeration cases:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">withdraw</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">WithdrawalResult</span> {
  <span class="hljs-keyword">if</span> amount <span class="hljs-operator">&lt;=</span> balance {
    balance <span class="hljs-operator">-=</span> amount
    <span class="hljs-keyword">return</span> .success(newBalance: balance)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> .error(message: <span class="hljs-string">"Not enough money!"</span>)
  }
}</pre>
<p class="calibre1">Now you can perform a withdrawal and handle the result:
</p><pre class="code-block"><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> withdraw(amount: <span class="hljs-number">99</span>)

<span class="hljs-keyword">switch</span> result {
<span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> newBalance):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Your new balance is: <span class="hljs-subst">\(newBalance)</span>"</span>)
<span class="hljs-keyword">case</span> .error(<span class="hljs-keyword">let</span> message):
  <span class="hljs-built_in">print</span>(message)
}</pre>
<p class="calibre1">Notice how you used <code class="calibre9">let</code> bindings to read the associated values. Associated values aren’t properties you can access freely, so you’ll need bindings like these to read them.
</p>
<p class="calibre1">Remember that the newly bound constants <code class="calibre9">newBalance</code> and <code class="calibre9">message</code> are local to the <code class="calibre9">switch</code> cases. They aren’t required to have the same name as the associated values, although it’s common to do so.
</p>
<p class="calibre1">You’ll see <code class="calibre9">"Your new balance is: 1"</code> printed out in the debug console.
</p>
<p class="calibre1">Many real-world contexts function by accessing associated values in an enumeration. For example, internet servers often use enumerations to differentiate between types of requests:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">HTTPMethod</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">get</span>
  <span class="hljs-keyword">case</span> post(body: <span class="hljs-built_in">String</span>)
}</pre>
<p class="calibre1">In the bank account example, you had multiple values you wanted to check for in the enumeration. In places where you only have one, you could instead use pattern matching in an <code class="calibre9">if case</code> or <code class="calibre9">guard case</code> statement. Here’s how that works:
</p><pre class="code-block"><span class="hljs-keyword">let</span> request <span class="hljs-operator">=</span> <span class="hljs-built_in">HTTPMethod</span>.post(body: <span class="hljs-string">"Hi there"</span>)
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">case</span> .post(<span class="hljs-keyword">let</span> body) <span class="hljs-operator">=</span> request <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"No message was posted"</span>)
}
<span class="hljs-built_in">print</span>(body)</pre>
<p class="calibre1">In this code, <code class="calibre9">guard case</code> checks to see if <code class="calibre9">request</code> contains the <code class="calibre9">post</code> enumeration case and, if so, reads and binds the associated value.
</p>
<p class="calibre1">You’ll also see enumerations used in error handling. The bank account example had multiple cases but just one generic error case with an associated string. In Chapter 22, “Error Handling,” you’ll see how to set up an enumeration with multiple cases to cover individual error conditions.
</p>
<h2 class="segment-chapter1">Enumeration as a state machine</h2>

<p class="calibre1">An enumeration is an example of a state machine, meaning it can only ever be a single enumeration value at a time, never more. The friendly traffic light illustrates this concept well:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">TrafficLight</span> {
  <span class="hljs-keyword">case</span> red, yellow, green
}
<span class="hljs-keyword">let</span> trafficLight <span class="hljs-operator">=</span> <span class="hljs-built_in">TrafficLight</span>.red</pre>
<p class="calibre1">A working traffic light will never be red and green simultaneously. You can observe this state machine behavior in other modern devices that follow a predetermined sequence of actions in response to events. Examples of state machines include:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Vending machines that dispense soda when the customer deposits the proper amount of money.
</p></li>

<li class="calibre4">
<p class="calibre1">Elevators that drop riders off at upper floors before going down.
</p></li>

<li class="calibre4">
<p class="calibre1">Combination locks that require combination numbers in the proper order.
</p></li>
</ul>

<p class="calibre1">To operate as expected, these devices depend on an enumeration’s guarantee that it will only ever be in one state at a time.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">A household light switch is another example of a state machine. Create an enumeration for a light that can switch <code class="calibre9">.on</code> and <code class="calibre9">.off</code>.
</p>
<h2 class="segment-chapter1">Iterating through all cases</h2>

<p class="calibre1">Sometimes you want to loop through all of the cases in an enumeration. This is easy to do:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Pet</span>: <span class="hljs-number">CaseIterable</span> {
  <span class="hljs-keyword">case</span> cat, dog, bird, turtle, fish, hamster
}

<span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> <span class="hljs-built_in">Pet</span>.allCases {
  <span class="hljs-built_in">print</span>(pet)
}</pre>
<p class="calibre1">When you conform to the <code class="calibre9">CaseIterable</code> protocol, your enumeration gains a class method called <code class="calibre9">allCases</code> that lets you loop through each case in the order that it was declared. This prints:
</p><pre class="code-block">cat
dog
bird
turtle
fish
hamster</pre>
<h2 class="segment-chapter1">Enumerations without any cases</h2>

<p class="calibre1">In Chapter 12, “Methods,” you learned how to create a namespace for a group of related type methods. The example in that chapter looked like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Math</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">factorial</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
    (<span class="hljs-number">1</span><span class="hljs-operator">...</span>number).reduce(<span class="hljs-number">1</span>, <span class="hljs-operator">*</span>)
  }
}
<span class="hljs-keyword">let</span> factorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Math</span>.factorial(of: <span class="hljs-number">6</span>) <span class="hljs-comment">// 720</span></pre>
<p class="calibre1">One thing you may not have realized at the time is that you could create an instance of <code class="calibre9">Math</code>, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> math <span class="hljs-operator">=</span> <span class="hljs-built_in">Math</span>()</pre>
<p class="calibre1">The <code class="calibre9">math</code> instance doesn’t serve any purpose since it is empty; it has no stored properties. In situations like this, the better design is actually to transform <code class="calibre9">Math</code> from a structure to an enumeration:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Math</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">factorial</span>(<span class="hljs-built_in">of</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
    (<span class="hljs-number">1</span><span class="hljs-operator">...</span>number).reduce(<span class="hljs-number">1</span>, <span class="hljs-operator">*</span>)
  }
}
<span class="hljs-keyword">let</span> factorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Math</span>.factorial(of: <span class="hljs-number">6</span>) <span class="hljs-comment">// 720</span></pre>
<p class="calibre1">Now, if you try to make an instance, the compiler will give you an error:
</p><pre class="code-block"><span class="hljs-keyword">let</span> math <span class="hljs-operator">=</span> <span class="hljs-built_in">Math</span>() <span class="hljs-comment">// ERROR: No accessible initializers</span></pre>
<p class="calibre1">Enumerations with no cases are sometimes referred to as <em class="calibre5">uninhabited types</em> or <em class="calibre5">bottom types</em>.
</p>
<p class="calibre1">As you learned at the beginning of this chapter, enumerations are quite powerful. They can do almost everything a structure can, including having custom initializers, computed properties and methods. To create an enumeration instance, though, you have to assign a member value as the state. If there are no member values, then you won’t be able to create an instance.
</p>
<p class="calibre1">That works perfectly for you in this case (pun intended). There’s no reason to have an instance of <code class="calibre9">Math</code>. You should make the design decision that there will <i class="calibre2">never</i> be an instance of the type.
</p>
<p class="calibre1">That will prevent future developers from accidentally creating an instance and help enforce its use as you intended. So, in summary, choose a case-less enumeration if it would be confusing if a valueless instance existed.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Euler’s number is useful in calculations for statistical bell curves and compound growth rates. Add the constant <i class="calibre2">e</i>, 2.7183, to your <code class="calibre9">Math</code> namespace. Then you can figure out how much money you’ll have if you invest $25,000 at 7% continuous interest for 20 years:
</p><pre class="code-block"><span class="hljs-keyword">let</span> nestEgg <span class="hljs-operator">=</span> <span class="hljs-number">25000</span> <span class="hljs-operator">*</span> pow(<span class="hljs-built_in">Math</span>.e, <span class="hljs-number">0.07</span> <span class="hljs-operator">*</span> <span class="hljs-number">20</span>) <span class="hljs-comment">// $101,380.95</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: In everyday life, you should use <code class="calibre9">M_E</code> from the Foundation library for the value of <i class="calibre2">e</i>. The <code class="calibre9">Math</code> namespace here is just for practice.
</p></div>

<h2 class="segment-chapter1">Optionals</h2>

<p class="calibre1">Since you’ve made it through the lesson on enumerations, the time has come to let you in on a little secret. There’s a Swift language feature using enumerations right under your nose all along: optionals! In this section, you’ll explore their underlying mechanism.
</p>
<p class="calibre1">Optionals act like containers that have either something or nothing inside:
</p><pre class="code-block"><span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>?
age <span class="hljs-operator">=</span> <span class="hljs-number">17</span>
age <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<p class="calibre1">Optionals are enumerations with two cases:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">.none</code> means there’s no value.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">.some</code> means a value attached to the enumeration case as an associated value.
</p></li>
</ol>

<p class="calibre1">You can extract the associated value from an optional with a <code class="calibre9">switch</code> statement, as you’ve already seen:
</p><pre class="code-block"><span class="hljs-keyword">switch</span> age {
<span class="hljs-keyword">case</span> .none:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No value"</span>)
<span class="hljs-keyword">case</span> .some(<span class="hljs-keyword">let</span> value):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Got a value: <span class="hljs-subst">\(value)</span>"</span>)
}</pre>
<p class="calibre1">You’ll see the <code class="calibre9">"No value"</code> message printed out in the debug console.
</p>
<p class="calibre1">Although optionals are enumerations under the hood, Swift hides the implementation details with things like optional binding, the <code class="calibre9">?</code> and <code class="calibre9">!</code> operators, and keywords such as <code class="calibre9">nil</code>.
</p><pre class="code-block"><span class="hljs-keyword">let</span> optionalNil: <span class="hljs-built_in">Int</span>? <span class="hljs-operator">=</span> .none
optionalNil <span class="hljs-operator">==</span> <span class="hljs-keyword">nil</span>    <span class="hljs-comment">// true</span>
optionalNil <span class="hljs-operator">==</span> .none  <span class="hljs-comment">// true</span></pre>
<p class="calibre1">If you try this in a playground, you’ll see that <code class="calibre9">nil</code> and <code class="calibre9">.none</code> are equivalent.
</p>
<p class="calibre1">In Chapter 17, “Generics,” you’ll learn a bit more about the underlying mechanism for optionals, including how to write your code to function in the same manner as optionals.
</p>
<p class="calibre1">Now that you know how optionals work, you’ll have the right tool for the job the next time you need a value container.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of enumerations. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Adding raw values</h3>

<p class="calibre1">Take the coin example from earlier in the chapter then begin with the following array of coins:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Coin</span>: <span class="hljs-number">Int</span> {
  <span class="hljs-keyword">case</span> penny <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">case</span> nickel <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
  <span class="hljs-keyword">case</span> dime <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
  <span class="hljs-keyword">case</span> quarter <span class="hljs-operator">=</span> <span class="hljs-number">25</span>
}

<span class="hljs-keyword">let</span> coinPurse: [<span class="hljs-built_in">Coin</span>] <span class="hljs-operator">=</span> [.penny, .quarter, .nickel, .dime, .penny, .dime, .quarter]</pre>
<p class="calibre1">Write a function where you can pass in the array of coins, add up the value and then return the number of cents.
</p>
<h3 class="segment-title2">Challenge 2: Computing with raw values</h3>

<p class="calibre1">Take the example from earlier in the chapter and begin with the <code class="calibre9">Month</code> enumeration:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Month</span>: <span class="hljs-number">Int</span> {
  <span class="hljs-keyword">case</span> january <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, february, march, april, may, june, july,
       august, september, october, november, december
}</pre>
<p class="calibre1">Write a computed property to calculate the number of months until summer.
</p>
<p class="calibre1"><em class="calibre5">Hint:</em> You’ll need to account for a negative value if summer has already passed in the current year. To do that, imagine looping back around for the next full year.
</p>
<h3 class="segment-title2">Challenge 3: Pattern matching enumeration values</h3>

<p class="calibre1">Take the map example from earlier in the chapter and begin with the <code class="calibre9">Direction</code> enumeration:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Direction</span> {
  <span class="hljs-keyword">case</span> north
  <span class="hljs-keyword">case</span> south
  <span class="hljs-keyword">case</span> east
  <span class="hljs-keyword">case</span> west
}</pre>
<p class="calibre1">Imagine starting a new level in a video game. The character makes a series of movements in the game. Calculate the position of the character on a top-down level map after making a set of movements:
</p><pre class="code-block"><span class="hljs-keyword">let</span> movements: [<span class="hljs-built_in">Direction</span>] <span class="hljs-operator">=</span> [.north, .north, .west, .south,
  .west, .south, .south, .east, .east, .south, .east]</pre>
<p class="calibre1"><em class="calibre5">Hint:</em> Use a tuple for the location:
</p><pre class="code-block"><span class="hljs-keyword">var</span> location <span class="hljs-operator">=</span> (x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>)</pre>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">An <em class="calibre5">enumeration</em> is a list of mutually exclusive cases that define a common type.
</p></li>

<li class="calibre4">
<p class="calibre1">Enumerations provide a type-safe alternative to old-fashioned integer values or strings.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use enumerations to handle responses, store state and encapsulate values.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">CaseIterable</code> lets you loop through an enumeration with <code class="calibre9">allCases</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Uninhabited enumerations</em> can be used as namespaces and prevent the creation of instances.
</p></li>

<li class="calibre4">
<p class="calibre1">The Swift <code class="calibre9">Optional</code> type is a generic enumeration with cases <code class="calibre9">.none</code> and <code class="calibre9">.some</code>.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-1">


<h1 class="segment-chapter">Chapter 16: Protocols</h1>

<p class="calibre1">In this book, you’ve learned about the three named types: structs, classes and enums. There’s one more named type to learn about: the <em class="calibre5">protocol</em>.
</p>
<p class="calibre1">Unlike the other named types, protocols don’t define anything you instantiate directly. Instead, they define an interface or blueprint that actual concrete types <em class="calibre5">conform</em> to. With a protocol, you define a common set of properties and behaviors that concrete types go and implement.
</p>
<p class="calibre1">You’ve been using protocol behind the scenes from the beginning of this book. In this chapter, you’ll learn the details about protocols and see why they’re central to Swift.
</p>
<h2 class="segment-chapter1">Introducing protocols</h2>

<p class="calibre1">You define a protocol much as you do any other named type. Enter the following into a playground:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Vehicle</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>()
  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>()
}</pre>
<p class="calibre1">The keyword <code class="calibre9">protocol</code> is followed by the name of the protocol, followed by the curly braces with the members of the protocol inside. The big difference you’ll notice is that the protocol <i class="calibre2">doesn’t contain any implementation</i>.
</p>
<p class="calibre1">That means you can’t instantiate a <code class="calibre9">Vehicle</code> directly:
</p><div class="image3"><img src="images/000012.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Instead, you use protocols to enforce methods and properties on <i class="calibre2">other</i> types. What you’ve defined here is something like the <i class="calibre2">idea</i> of a vehicle &mdash; it’s something that can accelerate and stop.
</p>
<h3 class="segment-title2">Protocol syntax</h3>

<p class="calibre1">A protocol can be <em class="calibre5">adopted</em> by a class, struct or enum &mdash; and when another type adopts a protocol, it’s required to implement the methods and properties defined in the protocol. Once a type implements all members of a protocol, the type is said to <em class="calibre5">conform</em> to the protocol.
</p>
<p class="calibre1">Here’s how you declare protocol conformance for your type. In the playground, define a new class that will conform to <code class="calibre9">Vehicle</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Unicycle</span>: <span class="hljs-number">Vehicle</span> {
  <span class="hljs-keyword">var</span> peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>

  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  }
}</pre>
<p class="calibre1">You follow the name of the named type with a colon and the name of the protocol you want to conform to. This syntax might look familiar since it’s the same syntax you use to make a class inherit from another class. In this example, <code class="calibre9">Unicycle</code> conforms to the <code class="calibre9">Vehicle</code> protocol.
</p>
<p class="calibre1">Note that it <i class="calibre2">looks</i> like class inheritance, but it isn’t; structs and enumerations can also conform to protocols with this syntax.
</p>
<p class="calibre1">If you were to remove the definition of <code class="calibre9">stop()</code> from the class <code class="calibre9">Unicycle</code> above, Swift would display an error since <code class="calibre9">Unicycle</code> wouldn’t have fully conformed to the <code class="calibre9">Vehicle</code> protocol.
</p><div class="image4"><img src="images/000025.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You’ll come back to the details of implementing protocols in a bit, but first, you’ll see what’s possible when defining protocols.
</p>
<h3 class="segment-title2">Methods in protocols</h3>

<p class="calibre1">In the <code class="calibre9">Vehicle</code> protocol above, you define a pair of methods, <code class="calibre9">accelerate()</code> and <code class="calibre9">stop()</code>, that all types conforming to <code class="calibre9">Vehicle</code> must implement.
</p>
<p class="calibre1">You define methods on protocols much like you would on any class, struct or enum with parameters and return values:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Direction</span> {
  <span class="hljs-keyword">case</span> left
  <span class="hljs-keyword">case</span> right
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">DirectionalVehicle</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>()
  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>()
  <span class="hljs-keyword">func</span> <span class="hljs-number">turn</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">direction</span>: <span class="hljs-built_in">Direction</span>)
  <span class="hljs-keyword">func</span> <span class="hljs-number">description</span>() -&gt; <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">There are a few differences to note. You don’t, and in fact, can’t define any <i class="calibre2">implementation</i> for the methods. This lack of implementation is to help you enforce a strict separation of interface and code, as the protocol by itself makes no assumptions about the implementation details of any type that conforms to the protocol.
</p>
<p class="calibre1">Also, methods defined in protocols can’t contain default parameters:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">OptionalDirectionVehicle</span> {
  <span class="hljs-comment">// Build error!</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">turn</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">direction</span>: <span class="hljs-built_in">Direction</span> <span class="hljs-operator">=</span> .left)
}</pre>
<p class="calibre1">To provide <code class="calibre9">direction</code> as an optional argument, you’d define both versions of the method explicitly:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">OptionalDirectionVehicle</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">turn</span>()
  <span class="hljs-keyword">func</span> <span class="hljs-number">turn</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">direction</span>: <span class="hljs-built_in">Direction</span>)
}</pre>
<p class="calibre1">Keep in mind when you conform to <code class="calibre9">OptionalDirectionVehicle</code>, you will need to implement both <code class="calibre9">turn()</code> and <code class="calibre9">turn(_:)</code>. If you implement only one function with a default parameter, Xcode won’t be happy, and it will ask you to add the other method.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: This isn’t creating a method with an optional parameter. Protocol extensions allow this, and you’ll learn more about them in Chapter 27, “Protocol-Oriented Programming”.
</p></div>

<h3 class="segment-title2">Properties in protocols</h3>

<p class="calibre1">You can also define properties in a protocol:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">VehicleProperties</span> {
  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}</pre>
<p class="calibre1">When defining properties in a protocol, you must explicitly mark them as <code class="calibre9">get</code> or <code class="calibre9">get set</code>, somewhat similar to how you declare computed properties. However, much like methods, you don’t include any implementation for properties.
</p>
<p class="calibre1">The fact that you must mark <code class="calibre9">get</code> and <code class="calibre9">set</code> on properties shows that a protocol doesn’t know about a property’s implementation, which makes no assumption about the property’s <i class="calibre2">storage</i>. You can implement these property requirements as computed properties <i class="calibre2">or</i> as regular variables. All the protocol requires is that the property is readable if it has only a <code class="calibre9">get</code> requirement or readable and writable if it has both a <code class="calibre9">get</code> and a <code class="calibre9">set</code> requirement.
</p>
<p class="calibre1">Even if the property has only a <code class="calibre9">get</code> requirement, you’re still allowed to implement it as a stored property or a read-write computed property. The requirements in the protocol are only minimum requirements.
</p>
<h3 class="segment-title2">Initializers in protocols</h3>

<p class="calibre1">While protocols themselves can’t be initialized, they can declare initializers that conforming types should have:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Account</span> {
  <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">initialAmount</span>: <span class="hljs-built_in">Double</span>)
  <span class="hljs-keyword">init?</span>(<span class="hljs-built_in">transferAccount</span>: <span class="hljs-built_in">Account</span>)
}</pre>
<p class="calibre1">In the <code class="calibre9">Account</code> protocol above, you define two initializers as part of the protocol. Any type that conforms to <code class="calibre9">Account</code> is required to have these initializers. If you conform to a protocol with required initializers using a class type, those initializers must use the <code class="calibre9">required</code> keyword:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">BitcoinAccount</span>: <span class="hljs-number">Account</span> {
  <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">initialAmount</span>: <span class="hljs-built_in">Double</span>) {
    value <span class="hljs-operator">=</span> initialAmount
  }
  <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-built_in">transferAccount</span>: <span class="hljs-built_in">Account</span>) {
    <span class="hljs-keyword">guard</span> transferAccount.value <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
    }
    value <span class="hljs-operator">=</span> transferAccount.value
  }
}

<span class="hljs-keyword">var</span> accountType: <span class="hljs-built_in">Account</span>.<span class="hljs-keyword">Type</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">BitcoinAccount</span>.<span class="hljs-keyword">self</span>
<span class="hljs-keyword">let</span> account <span class="hljs-operator">=</span> accountType.<span class="hljs-keyword">init</span>(initialAmount: <span class="hljs-number">30.00</span>)
<span class="hljs-keyword">let</span> transferAccount <span class="hljs-operator">=</span> accountType.<span class="hljs-keyword">init</span>(transferAccount: account)<span class="hljs-operator">!</span></pre>
<h3 class="segment-title2">Protocol inheritance</h3>

<p class="calibre1">The <code class="calibre9">Vehicle</code> protocol contains a set of methods that could apply to any vehicle, such as a bike, car, snowmobile, or airplane!
</p><div class="image1"><img src="images/000040.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You may wish to define a protocol that contains all the qualities of a <code class="calibre9">Vehicle</code> but is also specific to vehicles with wheels. For this, you can have protocols that inherit from other protocols, much like you can have classes that inherit from other classes:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">WheeledVehicle</span>: <span class="hljs-number">Vehicle</span> {
  <span class="hljs-keyword">var</span> numberOfWheels: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> wheelSize: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}</pre>
<p class="calibre1">Any type you mark as conforming to the <code class="calibre9">WheeledVehicle</code> protocol will have all the members defined within the braces and the members of <code class="calibre9">Vehicle</code>. As with subclassing, any type you mark as a <code class="calibre9">WheeledVehicle</code> will have an <code class="calibre9">is-a</code> relationship with the protocol <code class="calibre9">Vehicle</code>.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create an <code class="calibre9">Area</code> protocol that defines a read-only property <code class="calibre9">area</code> of type <code class="calibre9">Double</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Implement <code class="calibre9">Area</code> with structs representing <code class="calibre9">Square</code>, <code class="calibre9">Triangle</code> and <code class="calibre9">Circle</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Add a circle, a square and a triangle to an array. Convert the array of shapes to an array of areas using <code class="calibre9">map</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Implementing protocols</h2>

<p class="calibre1">As you’ve already seen, when you declare your type as conforming to a protocol, you must implement <i class="calibre2">all</i> the requirements declared in the protocol:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Bike</span>: <span class="hljs-number">Vehicle</span> {
  <span class="hljs-keyword">var</span> peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">var</span> brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>

  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
    brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
    brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
  }
}</pre>
<p class="calibre1">The class <code class="calibre9">Bike</code> implements all the methods defined in <code class="calibre9">Vehicle</code>. If <code class="calibre9">accelerate()</code> or <code class="calibre9">stop()</code> weren’t defined, you’d receive a build error.
</p>
<p class="calibre1">Defining a protocol guarantees any type that conforms to the protocol will have <i class="calibre2">all</i> the members you’ve defined in the protocol.
</p>
<h3 class="segment-title2">Implementing properties</h3>

<p class="calibre1">Recall that properties in protocols come with a <code class="calibre9">get</code> and possibly a <code class="calibre9">set</code> requirement and that a conforming type must conform to <i class="calibre2">at least</i> these requirements.
</p>
<p class="calibre1">Upgrade <code class="calibre9">Bike</code> to a <code class="calibre9">WheeledVehicle</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Bike</span>: <span class="hljs-number">WheeledVehicle</span> {

  <span class="hljs-keyword">let</span> numberOfWheels <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">var</span> wheelSize <span class="hljs-operator">=</span> <span class="hljs-number">16.0</span>

  <span class="hljs-keyword">var</span> peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">var</span> brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>

  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
    brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
    brakesApplied <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
  }
}</pre>
<p class="calibre1">The <code class="calibre9">numberOfWheels</code> constant fulfills the <code class="calibre9">get</code> requirement. The <code class="calibre9">wheelSize</code> variable fulfills both <code class="calibre9">get</code> and <code class="calibre9">set</code> requirements.
</p>
<p class="calibre1">Protocols don’t care how you implement their requirements as long as you implement them. Your choices for implementing a <code class="calibre9">get</code> requirement are:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A constant stored property.
</p></li>

<li class="calibre4">
<p class="calibre1">A variable stored property.
</p></li>

<li class="calibre4">
<p class="calibre1">A read-only computed property.
</p></li>

<li class="calibre4">
<p class="calibre1">A read-write computed property.
</p></li>
</ul>

<p class="calibre1">Your choices for implementing both a <code class="calibre9">get</code> and a <code class="calibre9">set</code> property are limited to a variable stored property or a read-write computed property.
</p>
<h3 class="segment-title2">Associated types in protocols</h3>

<p class="calibre1">You can also add an <em class="calibre5">associated type</em> as a protocol member. When using <code class="calibre9">associatedtype</code> in a protocol, you’re simply stating there <i class="calibre2">is</i> a type used in this protocol, without specifying what type this should be. It’s up to the protocol adopter to decide what the exact type should be.
</p>
<p class="calibre1">The associated type declaration lets you give arbitrary names to types without specifying which type it will eventually be:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">WeightType</span>
  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">WeightType</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">By defining the stand-in <code class="calibre9">WeightType</code> associated type, you delegate the decision of the type of <code class="calibre9">weight</code> to the type adopting the protocol.
</p>
<p class="calibre1">You can see how this works in the two examples below:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">HeavyThing</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-comment">// This heavy thing only needs integer accuracy</span>
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Int</span> { <span class="hljs-number">100</span> }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">LightThing</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-comment">// This light thing needs decimal places</span>
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Double</span> { <span class="hljs-number">0.0025</span> }
}</pre>
<p class="calibre1">In these examples, you use <code class="calibre9">typealias</code> to be explicit about the associated type. This explicitness usually isn’t required, as the compiler can often infer the type. In the previous examples, the type of <code class="calibre9">weight</code> clarifies what the associated type should be so that you can remove <code class="calibre9">typealias</code>.
</p>
<p class="calibre1">You may have noticed that the contract of <code class="calibre9">WeightCalculatable</code> now changes depending on the choice of associated type in the adopting type. Note that this prevents you from using the protocol as a simple variable type because the compiler doesn’t know what <code class="calibre9">WeightType</code> will be ahead of time.
</p><pre class="code-block"><span class="hljs-comment">// Build error!</span>
<span class="hljs-comment">// protocol 'WeightCalculatable' can only be used as a generic</span>
<span class="hljs-comment">// constraint because it has Self or associated type requirements.</span>
<span class="hljs-keyword">let</span> weightedThing: <span class="hljs-built_in">WeightCalculatable</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">LightThing</span>()</pre>
<p class="calibre1">You’ll learn all about <em class="calibre5">generic constraints</em> in Chapter 17, “Generics”.
</p>
<h3 class="segment-title2">Implementing multiple protocols</h3>

<p class="calibre1">A class can only inherit from a single class &mdash; this is the property of “single inheritance”. By contrast, a class, structure or enumeration can conform to as many protocols as you’d like! Suppose instead of creating a <code class="calibre9">WheeledVehicle</code> protocol that inherits from <code class="calibre9">Vehicle</code> that you made <code class="calibre9">Wheeled</code> a protocol.
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Wheeled</span> {
  <span class="hljs-keyword">var</span> numberOfWheels: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> wheelSize: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Bike</span>: <span class="hljs-number">Vehicle</span>, <span class="hljs-number">Wheeled</span> {
  <span class="hljs-comment">// Implement both Vehicle and Wheeled</span>
}</pre>
<p class="calibre1">Protocols support multiple conformances. You can add any number of protocol conformances to classes, structures and enumerations. In the example above, the <code class="calibre9">Bike</code> class has to implement all members defined in the <code class="calibre9">Vehicle</code> and <code class="calibre9">Wheeled</code> protocols.
</p>
<h3 class="segment-title2">Protocol composition</h3>

<p class="calibre1">In the previous section, you learned how to implement multiple protocols. Sometimes you need a function to take a data type that must conform to multiple protocols. That is where <em class="calibre5">protocol composition</em> comes in. Imagine you need a function that needs access to the <code class="calibre9">Vehicle</code> protocol’s <code class="calibre9">stop()</code> function and the <code class="calibre9">Wheeled</code>  protocol’s <code class="calibre9">numberOfWheels</code> property. You can do this using the <code class="calibre9">&amp;</code> composition operator.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">roundAndRound</span>(<span class="hljs-built_in">transportation</span>: <span class="hljs-built_in">Vehicle</span> &amp; <span class="hljs-built_in">Wheeled</span>) {
    transportation.stop()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"The brakes are being applied to
          <span class="hljs-subst">\(transportation.numberOfWheels)</span> wheels."</span>)
}

roundAndRound(transportation: <span class="hljs-built_in">Bike</span>())
<span class="hljs-comment">// The brakes are being applied to 2 wheels.</span></pre>
<h3 class="segment-title2">Extensions &amp; protocol conformance</h3>

<p class="calibre1">You can also adopt protocols using extensions. This language feature lets you add protocol conformance to types you don’t necessarily own. Consider the simple example below, which adds a custom protocol to <code class="calibre9">String</code>:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Reflective</span> {
  <span class="hljs-keyword">var</span> typeName: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">String</span>: <span class="hljs-number">Reflective</span> {
  <span class="hljs-keyword">var</span> typeName: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"I’m a String"</span>
  }
}

<span class="hljs-keyword">let</span> title <span class="hljs-operator">=</span> <span class="hljs-string">"Swift Apprentice!"</span>
title.typeName <span class="hljs-comment">// I’m a String</span></pre>
<p class="calibre1">Even though <code class="calibre9">String</code> is part of the standard library, you’re still able to make <code class="calibre9">String</code> conform to the <code class="calibre9">Reflective</code> protocol.
</p>
<p class="calibre1">Another advantage of using extensions is that you can nicely group the protocol adoption with the requisite methods and properties instead of having a pile of protocols cluttering up your type definition.
</p>
<p class="calibre1">The following code breaks out the adoption of <code class="calibre9">Vehicle</code> into an extension on <code class="calibre9">AnotherBike</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">AnotherBike</span>: <span class="hljs-number">Wheeled</span> {
  <span class="hljs-keyword">var</span> peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">let</span> numberOfWheels <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">var</span> wheelSize <span class="hljs-operator">=</span> <span class="hljs-number">16.0</span>
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">AnotherBike</span>: <span class="hljs-number">Vehicle</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">accelerate</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">stop</span>() {
    peddling <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  }
}</pre>
<p class="calibre1">This extension pairs <code class="calibre9">accelerate</code> and <code class="calibre9">stop</code> with <code class="calibre9">Vehicle</code>. If you were to remove the <code class="calibre9">Vehicle</code> protocol from <code class="calibre9">AnotherBike</code>, you could simply delete the extension that adopts this protocol entirely.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can’t declare <i class="calibre2">stored</i> properties in extensions. You can only declare stored properties in the original type declaration or derived classes in the case of a class type. This limitation can present a challenge to implementing an arbitrary protocol for some types.
</p></div>

<h3 class="segment-title2">Requiring reference semantics</h3>

<p class="calibre1">Protocols can be adopted by both value types (structs and enums) and reference types (classes), so you might wonder if protocols have reference or value semantics.
</p>
<p class="calibre1">The truth is that it depends! If you have an instance of a class or struct assigned to a variable of a protocol type, it will express value or reference semantics that matches the type it was defined as.
</p>
<p class="calibre1">To illustrate, take the simple example of a <code class="calibre9">Named</code> protocol below, implemented as a struct and a class:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Named</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">ClassyName</span>: <span class="hljs-number">Named</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">StructyName</span>: <span class="hljs-number">Named</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">If you were to assign a <code class="calibre9">Named</code> variable an instance of a reference type, you would see the behavior of reference semantics:
</p><pre class="code-block"><span class="hljs-keyword">var</span> named: <span class="hljs-built_in">Named</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">ClassyName</span>(name: <span class="hljs-string">"Classy"</span>)
<span class="hljs-keyword">var</span> copy <span class="hljs-operator">=</span> named

named.name <span class="hljs-operator">=</span> <span class="hljs-string">"Still Classy"</span>
named.name <span class="hljs-comment">// Still Classy</span>
copy.name <span class="hljs-comment">// Still Classy</span></pre>
<p class="calibre1">Likewise, if you assign an instance of a value type, you would see the behavior of value semantics:
</p><pre class="code-block">named <span class="hljs-operator">=</span> <span class="hljs-built_in">StructyName</span>(name: <span class="hljs-string">"Structy"</span>)
copy <span class="hljs-operator">=</span> named

named.name <span class="hljs-operator">=</span> <span class="hljs-string">"Still Structy?"</span>
named.name <span class="hljs-comment">// Still Structy?</span>
copy.name <span class="hljs-comment">// Structy</span></pre>
<p class="calibre1">The situation isn’t always this clear. You’ll notice that most of the time, Swift will favor value semantics over reference semantics. If you’re designing a protocol adopted exclusively by classes, it’s best to request that Swift uses reference semantics when using this protocol as a type.
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Named</span>: <span class="hljs-number">AnyObject</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}</pre>
<p class="calibre1">Using the <code class="calibre9">AnyObject</code> protocol constraint above indicates that only classes may adopt this protocol. This declaration makes it clear that Swift should use reference semantics.
</p>
<p class="calibre1">The <code class="calibre9">class</code> keyword provides the same constraint. However, it is preferable to use the protocol <code class="calibre9">AnyObject</code> instead.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can learn more about the difference between value type and reference type semantics in Chapter 25, ”Value Types &amp; Reference Types”.
</p></div>

<h3 class="segment-title2">Protocols: More than bags of syntax</h3>

<p class="calibre1">As you have seen, protocols let you specify many syntax requirements for conforming types. However, they can’t (and never will) let you specify every conceivable requirement for the compiler to check. For example, a protocol may need to specify complexity requirements (O(1) vs. O(n)) for an operation, and it can do this only by stating it in comments. You need to understand all of these requirements that a protocol makes to conform correctly. This reality has lead to the refrain that protocols are more than just bags of syntax that the compiler can check.
</p>
<h2 class="segment-chapter1">Protocols in the Standard Library</h2>

<p class="calibre1">The Swift standard library uses protocols extensively in ways that may surprise you. Understanding the roles protocols play in Swift can help you write clean, decoupled “Swifty” code.
</p>
<h3 class="segment-title2">Equatable</h3>

<p class="calibre1">Some of the simplest code compares two integers with the <code class="calibre9">==</code> operator:
</p><pre class="code-block"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">5</span>

a <span class="hljs-operator">==</span> b <span class="hljs-comment">// true</span></pre>
<p class="calibre1">You can do the same thing with strings:
</p><pre class="code-block"><span class="hljs-keyword">let</span> swiftA <span class="hljs-operator">=</span> <span class="hljs-string">"Swift"</span>
<span class="hljs-keyword">let</span> swiftB <span class="hljs-operator">=</span> <span class="hljs-string">"Swift"</span>

swiftA <span class="hljs-operator">==</span> swiftB <span class="hljs-comment">// true</span></pre>
<p class="calibre1">But you can’t use <code class="calibre9">==</code> on <i class="calibre2">any</i> type. Suppose you wrote a class to represents a team’s record and wanted to determine if two records were equal:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Record</span> {
  
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
    
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wins</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">losses</span>: <span class="hljs-built_in">Int</span>) {
      <span class="hljs-keyword">self</span>.wins <span class="hljs-operator">=</span> wins
      <span class="hljs-keyword">self</span>.losses <span class="hljs-operator">=</span> losses
  }
}

<span class="hljs-keyword">let</span> recordA <span class="hljs-operator">=</span> <span class="hljs-built_in">Record</span>(wins: <span class="hljs-number">10</span>, losses: <span class="hljs-number">5</span>)
<span class="hljs-keyword">let</span> recordB <span class="hljs-operator">=</span> <span class="hljs-built_in">Record</span>(wins: <span class="hljs-number">10</span>, losses: <span class="hljs-number">5</span>)

recordA <span class="hljs-operator">==</span> recordB <span class="hljs-comment">// Build error!</span></pre>
<p class="calibre1">You can’t apply the <code class="calibre9">==</code> operator to the class you just defined. But the use of the equality operator isn’t simply “magic” reserved for standard Swift types like <code class="calibre9">Int</code> and <code class="calibre9">String</code>; they’re structs, just like <code class="calibre9">Record</code>. You can extend the use of this operator to your own types!
</p>
<p class="calibre1">Both <code class="calibre9">Int</code> and <code class="calibre9">String</code> conform to the <code class="calibre9">Equatable</code> protocol from the the standard library that defines a single static method:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Equatable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">==</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Bool</span>
}</pre>
<p class="calibre1">You can apply this protocol to <code class="calibre9">Record</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Record</span>: <span class="hljs-number">Equatable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">==</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-built_in">Record</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-built_in">Record</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    lhs.wins <span class="hljs-operator">==</span> rhs.wins <span class="hljs-operator">&amp;&amp;</span>
    lhs.losses <span class="hljs-operator">==</span> rhs.losses
  }
}</pre>
<p class="calibre1">Here, you’re defining (or <i class="calibre2">overloading</i>) the <code class="calibre9">==</code> operator for comparing two <code class="calibre9">Record</code> instances. In this case, two records are equal if they have the same number of wins and losses.
</p>
<p class="calibre1">Now, you’re able to use the <code class="calibre9">==</code> operator to compare two <code class="calibre9">Record</code> types, just like you can with <code class="calibre9">String</code> or <code class="calibre9">Int</code>:
</p><pre class="code-block">recordA <span class="hljs-operator">==</span> recordB <span class="hljs-comment">// true</span></pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The compiler will often automatically write (or <em class="calibre5">codegen</em>) the function<code class="calibre9">==</code> for you.   This automatic code generation happens for structures and enumerations that conform to <code class="calibre9">Equatable</code> when all stored properties and associated values are also <code class="calibre9">Equatable</code>.
</p></div>

<h3 class="segment-title2">Comparable</h3>

<p class="calibre1">A subprotocol of <code class="calibre9">Equatable</code> is <code class="calibre9">Comparable</code>:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Comparable</span>: <span class="hljs-number">Equatable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">&lt;</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Bool</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">&lt;=</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Bool</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">&gt;=</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Bool</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">&gt;</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Bool</span>
}</pre>
<p class="calibre1">In addition to the equality operator <code class="calibre9">==</code>, <code class="calibre9">Comparable</code> requires you to overload the comparison operators <code class="calibre9">&lt;</code>, <code class="calibre9">&lt;=</code>, <code class="calibre9">&gt;</code> and <code class="calibre9">&gt;=</code> for your type. In practice, you’ll usually only provide <code class="calibre9">&lt;</code>, as the standard library can implement <code class="calibre9">&lt;=</code>, <code class="calibre9">&gt;</code> and <code class="calibre9">&gt;=</code> for you, using your implementations of <code class="calibre9">==</code> and <code class="calibre9">&lt;</code>.
</p>
<p class="calibre1">Make <code class="calibre9">Record</code> adopt <code class="calibre9">Comparable</code> as shown below:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Record</span>: <span class="hljs-number">Comparable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">&lt;</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-built_in">Record</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-built_in">Record</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    <span class="hljs-keyword">if</span> lhs.wins <span class="hljs-operator">==</span> rhs.wins {
      <span class="hljs-keyword">return</span> lhs.losses <span class="hljs-operator">&gt;</span> rhs.losses
    }
    <span class="hljs-keyword">return</span> lhs.wins <span class="hljs-operator">&lt;</span> rhs.wins
  }
}</pre>
<p class="calibre1">This implementation of <code class="calibre9">&lt;</code> considers one record lesser than another record if the first record either has fewer wins than the second record or an equal number of wins but a greater number of losses.
</p>
<h3 class="segment-title2">“Free” functions</h3>

<p class="calibre1">While <code class="calibre9">==</code> and <code class="calibre9">&lt;</code> are useful in their own right, the Swift library provides you with many “free” functions and methods for types that conform to <code class="calibre9">Equatable</code> and <code class="calibre9">Comparable</code>.
</p>
<p class="calibre1">For any collection you define that contains a <code class="calibre9">Comparable</code> type, such as an <code class="calibre9">Array</code>, you have access to methods such as <code class="calibre9">sort()</code> that are part of the standard library:
</p><pre class="code-block"><span class="hljs-keyword">let</span> teamA <span class="hljs-operator">=</span> <span class="hljs-built_in">Record</span>(wins: <span class="hljs-number">14</span>, losses: <span class="hljs-number">11</span>)
<span class="hljs-keyword">let</span> teamB <span class="hljs-operator">=</span> <span class="hljs-built_in">Record</span>(wins: <span class="hljs-number">23</span>, losses: <span class="hljs-number">8</span>)
<span class="hljs-keyword">let</span> teamC <span class="hljs-operator">=</span> <span class="hljs-built_in">Record</span>(wins: <span class="hljs-number">23</span>, losses: <span class="hljs-number">9</span>)
<span class="hljs-keyword">var</span> leagueRecords <span class="hljs-operator">=</span> [teamA, teamB, teamC]

leagueRecords.sort()
<span class="hljs-comment">// {wins 14, losses 11}</span>
<span class="hljs-comment">// {wins 23, losses 9}</span>
<span class="hljs-comment">// {wins 23, losses 8}</span></pre>
<p class="calibre1">Since you’ve given <code class="calibre9">Record</code> the ability to compare two values, the standard library has all the information it needs to sort an array of <code class="calibre9">Record</code>s! As you can see, implementing <code class="calibre9">Comparable</code> and <code class="calibre9">Equatable</code> gives you quite an arsenal of tools:
</p><pre class="code-block">leagueRecords.max() <span class="hljs-comment">// {wins 23, losses 8}</span>
leagueRecords.min() <span class="hljs-comment">// {wins 14, losses 11}</span>
leagueRecords.starts(with: [teamA, teamC]) <span class="hljs-comment">// true</span>
leagueRecords.contains(teamA) <span class="hljs-comment">// true</span></pre>
<h3 class="segment-title2">Other useful protocols</h3>

<p class="calibre1">While learning the <i class="calibre2">entire</i> Swift standard library isn’t vital to your success as a Swift developer, there are a few other essential protocols you’ll find helpful in almost any project.
</p>
<h4 class="segment-title2">Hashable</h4>

<p class="calibre1">The <code class="calibre9">Hashable</code> protocol, a subprotocol of <code class="calibre9">Equatable</code>, is required for any type you want to use as a key to a <code class="calibre9">Dictionary</code>. As with <code class="calibre9">Equatable</code>, the compiler will code generate <code class="calibre9">Hashable</code> conformance for you automatically, but you will need to do it yourself for reference types such as classes.
</p>
<p class="calibre1">Hash values help you quickly find elements in a collection. For this to work, values considered equal by <code class="calibre9">==</code> must also have the same hash value. Because the number of hash values is limited, there’s a finite probability that non-equal values can have the same hash. The mathematics behind hash values is quite complex, but you can let Swift handle the details for you. Just make sure that everything you include in the <code class="calibre9">==</code> comparison is also combined using the <code class="calibre9">hasher</code>.
</p>
<p class="calibre1">For example:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Student</span> {
  <span class="hljs-keyword">let</span> email: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> firstName: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> lastName: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">email</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">firstName</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">lastName</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.email <span class="hljs-operator">=</span> email
    <span class="hljs-keyword">self</span>.firstName <span class="hljs-operator">=</span> firstName
    <span class="hljs-keyword">self</span>.lastName <span class="hljs-operator">=</span> lastName
  }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Hashable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">==</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-built_in">Student</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-built_in">Student</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    lhs.email <span class="hljs-operator">==</span> rhs.email <span class="hljs-operator">&amp;&amp;</span>
    lhs.firstName <span class="hljs-operator">==</span> rhs.firstName <span class="hljs-operator">&amp;&amp;</span>
    lhs.lastName <span class="hljs-operator">==</span> rhs.lastName
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">hash</span>(<span class="hljs-built_in">into</span> <span class="hljs-built_in">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-built_in">Hasher</span>) {
    hasher.combine(email)
    hasher.combine(firstName)
    hasher.combine(lastName)
  }
}</pre>
<p class="calibre1">You use <code class="calibre9">email</code>, <code class="calibre9">firstName</code> and <code class="calibre9">lastName</code> as the basis for equality. An exemplary implementation of <code class="calibre9">hash</code> would be to use all of these properties by combining them using the <code class="calibre9">Hasher</code> type passed in. The <code class="calibre9">hasher</code> does the heavy lifting of properly composing the values.
</p>
<p class="calibre1">You can now use the <code class="calibre9">Student</code> type as the key in a <code class="calibre9">Dictionary</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-built_in">Student</span>(email: <span class="hljs-string">"johnny.appleseed@apple.com"</span>,
                   firstName: <span class="hljs-string">"Johnny"</span>,
                   lastName: <span class="hljs-string">"Appleseed"</span>)
<span class="hljs-keyword">let</span> lockerMap <span class="hljs-operator">=</span> [john: <span class="hljs-string">"14B"</span>]</pre>
<h4 class="segment-title2">Identifiable</h4>

<p class="calibre1">The <code class="calibre9">Identifiable</code> protocol vends a unique <code class="calibre9">id</code> property. Specifically, <code class="calibre9">Identifiable</code> requires only a <code class="calibre9">get</code> property named <code class="calibre9">id</code> whose type must be <code class="calibre9">Hashable</code>.
</p>
<p class="calibre1">For example, you could make <code class="calibre9">Student</code> identifiable like this:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Student</span>: <span class="hljs-number">Identifiable</span> {
  <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">String</span> {
    email
  }
}</pre>
<p class="calibre1">This implementation works because <code class="calibre9">email</code> is unique for each student. (If two students shared the same email address, it would not work.)  Also, the <code class="calibre9">id</code> is of type <code class="calibre9">String</code> which is <code class="calibre9">Hashable</code>.
</p>
<p class="calibre1">You would not want to use <code class="calibre9">firstName</code> to fulfill the <code class="calibre9">id</code> requirement because two or more students might have the same first name.
</p>
<h4 class="segment-title2">CustomStringConvertible</h4>

<p class="calibre1">The convenient <code class="calibre9">CustomStringConvertible</code> protocol helps you log and debug instances.
</p>
<p class="calibre1">When you call <code class="calibre9">print()</code> on an instance such as a <code class="calibre9">Student</code>, Swift prints a vague description:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(john)
<span class="hljs-comment">// Student</span></pre>
<p class="calibre1">As if you didn’t already know that! The <code class="calibre9">CustomStringConvertible</code> protocol has only a <code class="calibre9">description</code> property requirement. This property customizes how the instance appears in <code class="calibre9">print()</code> statements and in the debugger:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">You can provide a more readable representation by adopting <code class="calibre9">CustomStringConvertible</code> on the <code class="calibre9">Student</code> type.
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Student</span>: <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"<span class="hljs-subst">\(firstName)</span> <span class="hljs-subst">\(lastName)</span>"</span>
  }
}
<span class="hljs-built_in">print</span>(john)
<span class="hljs-comment">// Johnny Appleseed</span></pre>
<p class="calibre1"><code class="calibre9">CustomDebugStringConvertible</code> is similar to <code class="calibre9">CustomStringConvertible</code>: It behaves exactly like <code class="calibre9">CustomStringConvertible</code> except it also defines a <code class="calibre9">debugDescription</code>. Use <code class="calibre9">CustomDebugStringConvertible</code> along with <code class="calibre9">debugPrint()</code> to print to the output only in debug configurations.
</p>
<h2 class="segment-chapter1">Challenge</h2>

<p class="calibre1">Before moving on, here is a challenge to test your knowledge of protocols. It is best to try to solve it yourself, but, as always, a solution is available if you get stuck.
</p>
<h3 class="segment-title2">Challenge 1: Pet shop tasks</h3>

<p class="calibre1">Create a collection of protocols for tasks at a pet shop with dogs, cats, fish and birds.
</p>
<p class="calibre1">The pet shop duties include these tasks:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">All pets need to be fed.
</p></li>

<li class="calibre4">
<p class="calibre1">Pets that can fly need to be caged.
</p></li>

<li class="calibre4">
<p class="calibre1">Pets that can swim need to be put in a tank.
</p></li>

<li class="calibre4">
<p class="calibre1">Pets that walk need exercise.
</p></li>

<li class="calibre4">
<p class="calibre1">Tanks and cages need to be cleaned occasionally.
</p></li>
</ul>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create classes or structs for each animal and adopt the appropriate protocols. Feel free to simply use a <code class="calibre9">print()</code> statement for the method implementations.
</p></li>

<li class="calibre4">
<p class="calibre1">Create homogeneous arrays for animals that need to be fed, caged, cleaned, walked, and tanked. Add the appropriate animals to these arrays. The arrays should be declared using the protocol as the element type, for example, <code class="calibre9">var caged: [Cageable]</code>
</p></li>

<li class="calibre4">
<p class="calibre1">Write a loop that will perform the proper tasks (such as feed, cage, walk) on each element of each array.
</p></li>
</ol>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Protocols define a contract that classes, structs and enums can <em class="calibre5">adopt</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">Adopting a protocol requires a type to <em class="calibre5">conform</em> to the protocol by implementing all methods and properties of the protocol.
</p></li>

<li class="calibre4">
<p class="calibre1">A type can adopt any number of protocols, which allows for a quasi-multiple inheritance not permitted through subclassing.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use extensions for protocol adoption and conformance.
</p></li>

<li class="calibre4">
<p class="calibre1">The Swift standard library uses protocols extensively. You can use many of them, such as <code class="calibre9">Equatable</code> and <code class="calibre9">Hashable</code>, with your own types.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-16">


<h1 class="segment-chapter">Chapter 17: Generics</h1>

<p class="calibre1">The truth is, you already know about generics. Every time you use a Swift array, you’re using generics. This might give the impression that generics are <i class="calibre2">about</i> collections, but that impression is not correct. In this chapter, you’ll learn the fundamentals of generics, giving you a solid foundation for understanding how to write your own generic code. Finally, you’ll loop back to look at generic types in the Swift standard library &mdash; arrays, dictionaries and optionals &mdash; using this new perspective.
</p>
<h2 class="segment-chapter1">Introducing generics</h2>

<p class="calibre1">To get started, you’ll consider how you might model pets and their keepers. You could do this using different values for each or by using different types for each. You’ll see that using types, instead of values, the Swift <em class="calibre5">type checker</em> can reason about your code at compile time. Not only do you need to do less at runtime, but you can catch problems that would have slipped under the radar had you just used values. Your code also runs faster.
</p>
<h3 class="segment-title2">Values defined by other values</h3>

<p class="calibre1">Suppose you’re running a pet shop that sells only dogs and cats, and you want to use a Swift playground to model that business. To start, you define a type, <code class="calibre9">PetKind</code>, that can hold two possible values corresponding to the two kinds of pets that you sell:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">PetKind</span> {
  <span class="hljs-keyword">case</span> cat
  <span class="hljs-keyword">case</span> dog
}</pre>
<p class="calibre1">So far, so good. Now suppose you want to model the animals and the employees, the pet keepers who look after them. Your employees are highly specialized. Some keepers only look after cats, and others only dogs.
</p>
<p class="calibre1">So you define a <code class="calibre9">KeeperKind</code> type as follows:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">KeeperKind</span> {
  <span class="hljs-keyword">var</span> keeperOf: <span class="hljs-built_in">PetKind</span>
}</pre>
<p class="calibre1">Then you can initialize a <code class="calibre9">catKeeper</code> and <code class="calibre9">dogKeeper</code> in the following way:
</p><pre class="code-block"><span class="hljs-keyword">let</span> catKeeper <span class="hljs-operator">=</span> <span class="hljs-built_in">KeeperKind</span>(keeperOf: .cat)
<span class="hljs-keyword">let</span> dogKeeper <span class="hljs-operator">=</span> <span class="hljs-built_in">KeeperKind</span>(keeperOf: .dog)</pre>
<p class="calibre1">There are two points to note about how you’re modeling your shop.
</p>
<p class="calibre1">First, you’re representing the different kinds of pets and keepers by <i class="calibre2">varying the values of types</i>. There’s only one type for pet kinds &mdash; <code class="calibre9">PetKind</code> &mdash; and one type for keeper kinds &mdash; <code class="calibre9">KeeperKind</code>. Different kinds of pets are represented only by distinct values of the <code class="calibre9">PetKind</code> type, just as different kinds of keepers are represented by distinct values of the <code class="calibre9">KeeperKind</code> type.
</p>
<p class="calibre1">Second, <i class="calibre2">one range of possible values determines another range of possible values</i>. Specifically, the range of possible <code class="calibre9">KeeperKind</code> values mirrors the range of possible <code class="calibre9">PetKind</code> values.
</p>
<p class="calibre1">If your store started selling birds, you’d simply add a <code class="calibre9">.bird</code> member to the <code class="calibre9">PetKind</code> enumeration, and you’d immediately be able to initialize a value describing a bird keeper, <code class="calibre9">KeeperKind(keeperOf: .bird)</code>. And if you started selling a hundred different kinds of pets, you’d immediately be able to represent a hundred different kinds of keepers.
</p>
<p class="calibre1">In contrast, you could have defined a second unrelated enumeration instead of <code class="calibre9">KeeperKind</code>:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">EnumKeeperKind</span> {
  <span class="hljs-keyword">case</span> catKeeper
  <span class="hljs-keyword">case</span> dogKeeper
}</pre>
<p class="calibre1">In this case, nothing would enforce this relationship except your diligence in always updating one type to mirror the other. If you added <code class="calibre9">PetKind.snake</code> but forgot to add <code class="calibre9">EnumKeeperKind.snakeKeeper</code>, then things would get out of whack.
</p>
<p class="calibre1">But with <code class="calibre9">KeeperKind</code>, you explicitly established the relationship via a property of type <code class="calibre9">PetKind</code>. Every possible <code class="calibre9">PetKind</code> value implies a corresponding <code class="calibre9">KeeperKind</code> value. Or you could say, the set of potential <code class="calibre9">PetKind</code> values defines the set of possible <code class="calibre9">KeeperKind</code> values.
</p>
<p class="calibre1">To summarize, you can depict the relationship like so:
</p><div class="image3"><img src="images/000065.png" alt="" title="" class="calibre7" /></div>
<h3 class="segment-title2">Types defined by other types</h3>

<p class="calibre1">The model above fundamentally works by varying the <i class="calibre2">values of types</i>. Now consider another way to model the pet-to-keeper system &mdash; by varying <i class="calibre2">the types themselves</i>.
</p>
<p class="calibre1">Suppose that instead of defining a single type <code class="calibre9">PetKind</code> representing all kinds of pets, you chose to define a distinct type for every kind of pet you sell.
</p>
<p class="calibre1">Distinct types are a plausible choice if you’re working in an object-oriented style, where you model the pets’ behaviors with different methods for each pet. Then you’d have the following:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Cat</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-number">Dog</span> {}</pre>
<p class="calibre1">Now how do you represent the corresponding kinds of keepers? You could simply write the following:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">KeeperForCats</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-number">KeeperForDogs</span> {}</pre>
<p class="calibre1">But that’s no good. This approach has <i class="calibre2">exactly</i> the same problem as manually defining a parallel enum of <code class="calibre9">KeeperKind</code> values &mdash; it relies on you to enforce the required domain relationship of one kind of keeper for every kind of pet.
</p>
<p class="calibre1">What you’d like is a way to <i class="calibre2">declare</i> a relationship just like the one you established for values.
</p>
<p class="calibre1">You’d like to declare that every possible pet type implies the existence of a corresponding keeper type, a correspondence that you’d depict like so:
</p><div class="image3"><img src="images/000075.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You’d like to establish that for every possible pet type that there’s a corresponding Keeper type. But you don’t want to do this manually. You want a way to <i class="calibre2">automatically</i> define a set of new types for all the keepers.
</p>
<p class="calibre1">Automatic type generation, it turns out, is the problem generics solve!
</p>
<h2 class="segment-chapter1">Anatomy of generic types</h2>

<p class="calibre1">Generics provide a mechanism for using one set of types to define a new set of types.
</p>
<p class="calibre1">In your example, you can define a <em class="calibre5">generic type</em> for keepers, like so:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Keeper</span>&lt;<span class="hljs-number">Animal</span>&gt; {}</pre>
<p class="calibre1">This definition immediately defines all the corresponding keeper types, as desired:
</p><div class="image3"><img src="images/000087.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can verify these types are real by creating values of them, specifying the entire type in the initializer:
</p><pre class="code-block"><span class="hljs-keyword">var</span> aCatKeeper <span class="hljs-operator">=</span> <span class="hljs-built_in">Keeper</span>&lt;<span class="hljs-built_in">Cat</span>&gt;()</pre>
<p class="calibre1">What’s going on here? First, <code class="calibre9">Keeper</code> is the name of a generic type.
</p>
<p class="calibre1">But you might say that a generic type isn’t a type at all. It’s more like a recipe for making real types or <em class="calibre5">concrete types</em>. One sign of this is the error you get if you try to instantiate it in isolation:
</p><pre class="code-block"><span class="hljs-keyword">var</span> aKeeper <span class="hljs-operator">=</span> <span class="hljs-built_in">Keeper</span>()  <span class="hljs-comment">// compile-time error!</span></pre>
<p class="calibre1">The compiler complains here that “generic parameter ‘Animal’ could not be inferred” because it doesn’t know what kind of keeper you want. That <code class="calibre9">Animal</code> in angle brackets is the <em class="calibre5">type parameter</em> that specifies the type for the kind of animal you’re keeping.
</p>
<p class="calibre1">Once you provide the required type parameter, as in <code class="calibre9">Keeper&lt;Cat&gt;</code>, the generic <code class="calibre9">Keeper</code> becomes a new concrete type. <code class="calibre9">Keeper&lt;Cat&gt;</code> is different from <code class="calibre9">Keeper&lt;Dog&gt;</code>, even though they started from the same generic type. These resulting concrete types are called <em class="calibre5">specializations</em> of the generic type.
</p>
<p class="calibre1">To summarize the mechanics, to define a generic type like <code class="calibre9">Keeper&lt;Animal&gt;</code>, you only need to choose the name of the generic type and the type parameter. The name of the type parameter, also called a <em class="calibre5">placeholder</em>, should clarify the relationship between the type parameter and the generic type. You’ll encounter names like <code class="calibre9">T</code> (short for Type) from time to time but avoid these names when the placeholder has a well-defined role such as <code class="calibre9">Animal</code>.
</p>
<p class="calibre1">In one stroke, the generic type <code class="calibre9">Keeper&lt;Animal&gt;</code> defines a <i class="calibre2">family</i> of new types. Those are all the specializations of <code class="calibre9">Keeper&lt;Animal&gt;</code> implied by all possible concrete types that could substitute for the type parameter <code class="calibre9">Animal</code>.
</p>
<p class="calibre1">Notice that the type <code class="calibre9">Keeper</code> doesn’t currently store anything or even use the type parameter <code class="calibre9">Animal</code> in any way. Essentially, generics are a way to systematically define sets of types.
</p>
<h3 class="segment-title2">Using type parameters</h3>

<p class="calibre1">Usually, though, you’ll want to <i class="calibre2">do</i> something with type parameters.
</p>
<p class="calibre1">Suppose you want to keep better track of individuals. First, you enrich your type definitions to include identifiers, such as names. Adding it lets every value represent the identity of an individual animal or keeper:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Cat</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Dog</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Keeper</span>&lt;<span class="hljs-number">Animal</span>&gt; {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}</pre>
<p class="calibre1">You also want to track which keeper looks after which animals. Suppose every keeper is responsible for one animal in the morning and another in the afternoon. You can express this by adding properties for the morning and afternoon animals. But what type should those properties have?
</p>
<p class="calibre1">If a particular keeper only manages dogs, then the properties must only hold dogs. And if cats, then cats. In general, if it’s a keeper of <code class="calibre9">Animal</code>, then the morning and afternoon animal properties should be of type <code class="calibre9">Animal</code>.
</p>
<p class="calibre1">To express this, you merely need to <i class="calibre2">use</i> the type parameter that previously only distinguished the nature of your keeper types:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Keeper</span>&lt;<span class="hljs-number">Animal</span>&gt; {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> morningCare: <span class="hljs-built_in">Animal</span>
  <span class="hljs-keyword">var</span> afternoonCare: <span class="hljs-built_in">Animal</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">morningCare</span>: <span class="hljs-built_in">Animal</span>, <span class="hljs-built_in">afternoonCare</span>: <span class="hljs-built_in">Animal</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.morningCare <span class="hljs-operator">=</span> morningCare
    <span class="hljs-keyword">self</span>.afternoonCare <span class="hljs-operator">=</span> afternoonCare
  }
}</pre>
<p class="calibre1">Using <code class="calibre9">Animal</code> in the body of the generic type definition above, you can express that the morning and afternoon animals must be the kind of animal the keeper knows best. Just as function parameters become constants to use within the body of your function definition, you can use type parameters such as <code class="calibre9">Animal</code> throughout your type definitions. You can use the type parameter anywhere in the definition of <code class="calibre9">Keeper&lt;Animal&gt;</code> for stored properties, computed properties, method signatures and nested types.
</p>
<p class="calibre1">Now when you instantiate a <code class="calibre9">Keeper</code>, Swift will make sure, at compile-time, that the morning and afternoon types are the same:
</p><pre class="code-block"><span class="hljs-keyword">let</span> jason <span class="hljs-operator">=</span> <span class="hljs-built_in">Keeper</span>(name: <span class="hljs-string">"Jason"</span>,
                   morningCare: <span class="hljs-built_in">Cat</span>(name: <span class="hljs-string">"Whiskers"</span>),
                   afternoonCare: <span class="hljs-built_in">Cat</span>(name: <span class="hljs-string">"Sleepy"</span>))</pre>
<p class="calibre1">Here, the keeper Jason manages the cat Whiskers in the morning and the cat Sleepy in the afternoon. The type of <code class="calibre9">jason</code> is <code class="calibre9">Keeper&lt;Cat&gt;</code>. Note that you did not have to specify a value for the type parameter.
</p>
<p class="calibre1">Because you used instances of <code class="calibre9">Cat</code> as the values for <code class="calibre9">morningCare</code> and <code class="calibre9">afternoonCare</code>, Swift knows the type of <code class="calibre9">jason</code> should be <code class="calibre9">Keeper&lt;Cat&gt;</code>.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Try instantiating another <code class="calibre9">Keeper</code> but this time for dogs.
</p></li>

<li class="calibre4">
<p class="calibre1">What would happen if you tried to instantiate a <code class="calibre9">Keeper</code> with a dog in the morning and a cat in the afternoon?
</p></li>

<li class="calibre4">
<p class="calibre1">What happens if you try to instantiate a <code class="calibre9">Keeper</code> but for strings?
</p></li>
</ul>

<h3 class="segment-title2">Type constraints</h3>

<p class="calibre1">In your definition of <code class="calibre9">Keeper</code>, the identifier <code class="calibre9">Animal</code> serves as a type parameter named placeholder for some concrete type you supply later.
</p>
<p class="calibre1">This is much like the parameter name <code class="calibre9">cat</code> in an ordinary function like <code class="calibre9">func feed(cat: Cat) { /* open can, etc... */ }</code>. But when calling this function, you can’t simply pass any argument to the function. You can only pass values of type <code class="calibre9">Cat</code>.
</p>
<p class="calibre1">However, at present, you could offer any type for <code class="calibre9">Animal</code>, even something nonsensically unlike an animal, like a <code class="calibre9">String</code> or <code class="calibre9">Int</code>.
</p>
<p class="calibre1">Being able to use anything is no good. What you’d like is a mechanism more closely analogous to a function parameter. You want a feature that lets you restrict what kinds of types are allowed in the type parameter. In Swift, you do this with various kinds of <em class="calibre5">type constraints</em>.
</p>
<p class="calibre1">A simple kind of type constraint applies directly to a type parameter, and it looks like this:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Keeper</span>&lt;<span class="hljs-number">Animal</span>: <span class="hljs-number">Pet</span>&gt; {
   <span class="hljs-comment">/* definition body as before */</span>
}</pre>
<p class="calibre1">Here, the constraint <code class="calibre9">: Pet</code> requires that the type assigned to <code class="calibre9">Animal</code> must be a subclass of <code class="calibre9">Pet</code>, if <code class="calibre9">Pet</code> is a class, or must implement the <code class="calibre9">Pet</code> protocol if <code class="calibre9">Pet</code> is a protocol.
</p>
<p class="calibre1">For instance, to comply with the constraint established by the revised <code class="calibre9">Keeper</code> definition, you could redefine <code class="calibre9">Cat</code> and other animals to implement <code class="calibre9">Pet</code>, or you could <em class="calibre5">retro</em><em class="calibre5">-</em><em class="calibre5">actively model</em> conformance to the protocol by using an <code class="calibre9">extension</code>:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Pet</span> { 
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }  <span class="hljs-comment">// all pets respond to a name</span>
}
<span class="hljs-keyword">extension</span> <span class="hljs-number">Cat</span>: <span class="hljs-number">Pet</span> {}
<span class="hljs-keyword">extension</span> <span class="hljs-number">Dog</span>: <span class="hljs-number">Pet</span> {}</pre>
<p class="calibre1">This code works because <code class="calibre9">Cat</code> and <code class="calibre9">Dog</code> already implement a <code class="calibre9">name</code> stored property.
</p>
<p class="calibre1">In addition to such simple type constraints, you can define more complex type constraints using a <i class="calibre2">generic where clause</i>. You can use a <code class="calibre9">where</code> clause in definitions of free functions, types, member functions, protocols, and even extensions. It can constrain type parameters and associated types, letting you define rich relationships on top of generic types.
</p>
<p class="calibre1">Type constraints on extensions are especially useful. For example, suppose you want all <code class="calibre9">Cat</code> arrays to support the method <code class="calibre9">meow()</code>. You can use an extension to specify that when the array’s <code class="calibre9">Element</code> is a <code class="calibre9">Cat</code> then the array provides <code class="calibre9">meow()</code>:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Array</span> <span class="hljs-number">where</span> <span class="hljs-number">Element</span>: <span class="hljs-number">Cat</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">meow</span>() {
    forEach { <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-variable">$0</span>.name)</span> says meow!"</span>) }
  }
}</pre>
<p class="calibre1">You can even specify that a type should conform to some protocol only if it meets certain constraints. Suppose that anything that can meow is a <code class="calibre9">Meowable</code>. You could write that every <code class="calibre9">Array</code> is <code class="calibre9">Meowable</code> if its elements are as follows:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Meowable</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">meow</span>()
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">Cat</span>: <span class="hljs-number">Meowable</span> { 
  <span class="hljs-keyword">func</span> <span class="hljs-number">meow</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span> says meow!"</span>)
  }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">Array</span>: <span class="hljs-number">Meowable</span> <span class="hljs-number">where</span> <span class="hljs-number">Element</span>: <span class="hljs-number">Meowable</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">meow</span>() {
    forEach { <span class="hljs-variable">$0</span>.meow() }
  }
}</pre>
<p class="calibre1">This code demonstrates <em class="calibre5">conditional conformance</em>, a subtle but powerful mechanism of composition.
</p>
<h2 class="segment-chapter1">Arrays</h2>

<p class="calibre1">While the original <code class="calibre9">Keeper</code> type illustrates that a generic type doesn’t need to store anything or use its type parameter, <code class="calibre9">Array</code>, one of the most common generic types, does both.
</p>
<p class="calibre1">The need for generic arrays was part of the original motivation to invent generic types. Since so many programs need homogeneous arrays, generic arrays make all that code safer. Once the compiler infers (or is told) the type of an array’s elements at one point in the code, it can spot any deviations at other points in the code before the program ever runs.
</p>
<p class="calibre1">You’ve been using <code class="calibre9">Array</code> all along, but only with a <em class="calibre5">syntactic sugar</em>: <code class="calibre9">[Element]</code> instead of <code class="calibre9">Array&lt;Element&gt;</code>. Consider an array declared like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> animalAges: [<span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]</pre>
<p class="calibre1">This is equivalent to the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> animalAges: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]</pre>
<p class="calibre1"><code class="calibre9">Array&lt;Element&gt;</code> and <code class="calibre9">[Element]</code> are exactly interchangeable. So you could even call an array’s default initializer by writing <code class="calibre9">[Int]()</code> instead of <code class="calibre9">Array&lt;Int&gt;()</code>.
</p>
<p class="calibre1">Since Swift arrays simply allow indexed access to a sequence of elements, they impose no requirements on their <code class="calibre9">Element</code> type. But this isn’t always the case.
</p>
<h2 class="segment-chapter1">Dictionaries</h2>

<p class="calibre1">Swift generics allow multiple type parameters, each with unique constraints.  A <code class="calibre9">Dictionary</code> is a straightforward example of this.
</p>
<p class="calibre1"><code class="calibre9">Dictionary</code> has two type parameters in the comma-separated generic parameter list that falls between the angle brackets, as you can see in its declaration:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Dictionary</span>&lt;<span class="hljs-number">Key</span>: <span class="hljs-number">Hashable</span>, <span class="hljs-number">Value</span>&gt; // <span class="hljs-number">etc</span>..</pre>
<p class="calibre1"><code class="calibre9">Key</code> and <code class="calibre9">Value</code> represent the types of the dictionary’s keys and values. The type constraint <code class="calibre9">Key: Hashable</code> requires that any type serving as the dictionary’s key be hashable because the dictionary is a hash map and must hash its keys to enable fast lookup.
</p>
<p class="calibre1">To instantiate types such as <code class="calibre9">Dictionary</code> with multiple type parameters, simply provide a comma-separated type argument list:
</p><pre class="code-block"><span class="hljs-keyword">let</span> intNames: <span class="hljs-built_in">Dictionary</span>&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-number">42</span>: <span class="hljs-string">"forty-two"</span>]</pre>
<p class="calibre1">As with arrays, dictionaries get some special treatment in Swift since they’re built-in and rather common. You’ve already seen the shorthand notation <code class="calibre9">[Key: Value]</code>, and you can also use type inference:
</p><pre class="code-block"><span class="hljs-keyword">let</span> intNames2: [<span class="hljs-built_in">Int</span>: <span class="hljs-built_in">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">42</span>: <span class="hljs-string">"forty-two"</span>, <span class="hljs-number">7</span>: <span class="hljs-string">"seven"</span>]
<span class="hljs-keyword">let</span> intNames3 <span class="hljs-operator">=</span> [<span class="hljs-number">42</span>: <span class="hljs-string">"forty-two"</span>, <span class="hljs-number">7</span>: <span class="hljs-string">"seven"</span>]</pre>
<h2 class="segment-chapter1">Optionals</h2>

<p class="calibre1">Finally, no discussion of generics would be complete without mentioning optionals. Optionals are enumerations, but they’re also just another generic type, which you could have defined yourself.
</p>
<p class="calibre1">Suppose you were writing an app that lets a user enter her birthdate in a form but didn’t require it. You might find it handy to define an enum type as follows:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">OptionalDate</span> {
  <span class="hljs-keyword">case</span> none
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-built_in">Date</span>)
}</pre>
<p class="calibre1">Similarly, if another form allowed but didn’t require the user to enter her last name, you might define the following type:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">OptionalString</span> {
  <span class="hljs-keyword">case</span> none
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-built_in">String</span>)
}</pre>
<p class="calibre1">Then you could capture all the information a user did or did not enter into a struct with properties of those types:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">FormResults</span> {
  <span class="hljs-comment">// other properties here</span>
  <span class="hljs-keyword">var</span> birthday: <span class="hljs-built_in">OptionalDate</span>
  <span class="hljs-keyword">var</span> lastName: <span class="hljs-built_in">OptionalString</span>
}</pre>
<p class="calibre1">And if you found yourself doing this repeatedly for new types, at some point, you’d want to generalize this into a generic type that could support any type in the future. Therefore, you’d write the following:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Optional</span>&lt;<span class="hljs-number">Wrapped</span>&gt; {
  <span class="hljs-keyword">case</span> none
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-built_in">Wrapped</span>)
}</pre>
<p class="calibre1">At this point, you would have reproduced Swift’s own <code class="calibre9">Optional&lt;Wrapped&gt;</code> type since this is quite close to the definition in the Swift standard library! It turns out, <code class="calibre9">Optional&lt;Wrapped&gt;</code> is close to being a plain old generic type, like one you could write yourself.
</p>
<p class="calibre1">Why “close”? It would <i class="calibre2">only</i> be a plain old generic type if you interacted with optionals only by writing out their full types, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> birthdate: <span class="hljs-built_in">Optional</span>&lt;<span class="hljs-built_in">Date</span>&gt; <span class="hljs-operator">=</span> .none
<span class="hljs-keyword">if</span> birthdate <span class="hljs-operator">==</span> .none {
  <span class="hljs-comment">// no birthdate</span>
}</pre>
<p class="calibre1">But, of course, it’s more common and conventional to write something like this:
</p><pre class="code-block"><span class="hljs-keyword">var</span> birthdate: <span class="hljs-built_in">Date</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
<span class="hljs-keyword">if</span> birthdate <span class="hljs-operator">==</span> <span class="hljs-keyword">nil</span> {
  <span class="hljs-comment">// no birthdate</span>
}</pre>
<p class="calibre1">Those two code blocks say the same thing. The second relies on special language support for optionals: the <code class="calibre9">Wrapped?</code> shorthand syntax for specifying the optional type <code class="calibre9">Optional&lt;Wrapped&gt;</code>, and <code class="calibre9">nil</code>, which can stand for the <code class="calibre9">.none</code> value of an <code class="calibre9">Optional&lt;Wrapped&gt;</code> specialized on any type.
</p>
<p class="calibre1">As with arrays and dictionaries, optionals get a privileged place in the language with this syntax to be more concise. But all of these features provide more convenient ways to access the underlying type, which is simply a generic enumeration type.
</p>
<h2 class="segment-chapter1">Generic function parameters</h2>

<p class="calibre1">Functions can be generic as well. A function’s <em class="calibre5">type parameter list</em> comes after the function name. You can then use the generic parameters in the rest of the definition.
</p>
<p class="calibre1">This function takes two arguments and swaps their order:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">swapped</span>&lt;<span class="hljs-built_in">T</span>, <span class="hljs-built_in">U</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-built_in">x</span>: <span class="hljs-built_in">T</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">y</span>: <span class="hljs-built_in">U</span>) -&gt; (<span class="hljs-built_in">U</span>, <span class="hljs-built_in">T</span>) {
  (y, x)
}

swapped(<span class="hljs-number">33</span>, <span class="hljs-string">"Jay"</span>)  <span class="hljs-comment">// returns ("Jay", 33)</span></pre>
<p class="calibre1">A generic function definition demonstrates a confusing aspect of the syntax: having both type parameters and function parameters. You have both the generic parameter list of type parameters <code class="calibre9">&lt;T, U&gt;</code> and the list of function parameters <code class="calibre9">(_ x: T, _ y: U)</code>.
</p>
<p class="calibre1">Think of the type parameters as arguments <i class="calibre2">for the compiler</i>, which it uses to define one possible function. Just as your generic <code class="calibre9">Keeper</code> type meant the compiler could make dog keepers and cat keepers and any other kind of keeper, the compiler can now make a non-generic specialized <code class="calibre9">swapped</code> function for any two types for you to use.
</p>
<h2 class="segment-chapter1">Challenge</h2>

<p class="calibre1">Before moving on, here is a challenge to test your knowledge of generics. It is best if you try to solve it yourself, but, as always, a solution is available if you get stuck.
</p>
<h3 class="segment-title2">Challenge 1: Build a collection</h3>

<p class="calibre1">Consider the pet and keeper example from earlier in the chapter:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Cat</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Dog</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Keeper</span>&lt;<span class="hljs-number">Animal</span>&gt; {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> morningCare: <span class="hljs-built_in">Animal</span>
  <span class="hljs-keyword">var</span> afternoonCare: <span class="hljs-built_in">Animal</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">morningCare</span>: <span class="hljs-built_in">Animal</span>, <span class="hljs-built_in">afternoonCare</span>: <span class="hljs-built_in">Animal</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.morningCare <span class="hljs-operator">=</span> morningCare
    <span class="hljs-keyword">self</span>.afternoonCare <span class="hljs-operator">=</span> afternoonCare
  }
}</pre>
<p class="calibre1">Imagine that instead of looking after only two animals, every keeper looks after a changing number of animals throughout the day. It could be one, two, or ten animals per keeper instead of just morning and afternoon ones. You’d have to do things like the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> christine <span class="hljs-operator">=</span> <span class="hljs-built_in">Keeper</span>&lt;<span class="hljs-built_in">Cat</span>&gt;(name: <span class="hljs-string">"Christine"</span>)

christine.lookAfter(someCat)
christine.lookAfter(anotherCat)</pre>
<p class="calibre1">You’d want access to the count of animals for a keeper like <code class="calibre9">christine.countAnimals</code> and to access the 51st animal via a zero-based index like <code class="calibre9">christine.animalAtIndex(50)</code>.
</p>
<p class="calibre1">Of course, you’re describing your old friend, the array type, <code class="calibre9">Array&lt;Element&gt;</code>!
</p>
<p class="calibre1">Your challenge is to update the <code class="calibre9">Keeper</code> type to have this kind of interface. You’ll probably want to include a private array inside <code class="calibre9">Keeper</code> and then provide methods and properties on <code class="calibre9">Keeper</code> to allow outside access to the array.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Generics are everywhere in Swift: optionals, arrays, dictionaries, other collection structures, and most basic operators like <code class="calibre9">+</code> and <code class="calibre9">==</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Generics express systematic variation at the level of types via <em class="calibre5">type parameters</em> that range over possible concrete types.
</p></li>

<li class="calibre4">
<p class="calibre1">Generics are like functions <i class="calibre2">for the compiler</i>. They are evaluated at compile-time and result in new types, which are specializations of the generic type.
</p></li>

<li class="calibre4">
<p class="calibre1">A generic type is not a real type on its own, but more like a recipe, program, or template for defining new types.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift provides a rich system of <em class="calibre5">type constraints</em>, which lets you specify what types are allowed for various type parameters.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-31">


<h1 class="segment-chapter">Section IV: Advanced Topics</h1>

<p class="calibre1">You’ve made it to the final section of this book! In this section, you’ll delve into some essential but more advanced topics to round out your Swift apprenticeship.
</p>
<p class="calibre1">After reading this section, you’ll be on your way to being a knowledgable Swift developer by digging into topics even those most advanced programmers use.
</p>
<p class="calibre1">You’ll learn to hide complexity in your apps and organize your code through access control and testing tools. You’ll also work on pattern matching, error handling, and memory management, as well as encoding and decoding types. You will also get exposure to the newest language features, including result builders and property wrappers which drive cutting-edge frameworks like SwiftUI.
</p>
<p class="calibre1">And level up how you approach your code by customizing operators and subscripts and leveraging protocol-oriented programming while using constraints to make generic code more functional.
</p>
<p class="calibre1">Finally, you will get in-depth exposure to Swift’s native concurrency features, which improve the correctness, safety and efficiency of writing concurrent code.
</p></div>

<div class="segment-title" id="calibre_link-36">


<h1 class="segment-chapter">Chapter 18: Access Control, Code Organization &amp; Testing</h1>

<p class="calibre1">You declare Swift types with properties, methods, initializers and even other nested types. These elements make up the <em class="calibre5">interface</em> to your code or the <em class="calibre5">API</em> (<em class="calibre5">Application Programming Interface</em>).
</p>
<p class="calibre1">As code grows in complexity, controlling this interface becomes an essential part of software design. You may wish to create methods that serve as “helpers” to your code or properties that keep track of internal states that you don’t want as part of your code’s interface.
</p>
<p class="calibre1">Swift solves these problems with a feature area known as <em class="calibre5">access control</em>, which lets you control your code’s viewable interface. Access control enables you, the library author, to hide implementation complexity from users.
</p>
<p class="calibre1">This hidden internal state is sometimes referred to as <em class="calibre5">the invariant</em>, which your public interface should always maintain. Preventing direct access to the internal state and keeping the invariant valid is a fundamental software design concept known as <em class="calibre5">encapsulation</em>. In this chapter, you will learn what access control is, the problems it solves, and how to apply it.
</p>
<h3 class="segment-title2">Problems introduced by lack of access control</h3>

<p class="calibre1">Imagine for a moment you are writing a banking library. This library would help serve as the foundation for your customers (other banks) to write their banking software.
</p>
<p class="calibre1">In a playground, start with the following protocol:
</p><pre class="code-block"><span class="hljs-comment">/// A protocol describing core functionality for an account</span>
<span class="hljs-keyword">protocol</span> <span class="hljs-number">Account</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">Currency</span>

  <span class="hljs-keyword">var</span> balance: <span class="hljs-built_in">Currency</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">func</span> <span class="hljs-number">deposit</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Currency</span>)
  <span class="hljs-keyword">func</span> <span class="hljs-number">withdraw</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Currency</span>)
}</pre>
<p class="calibre1">This code contains <code class="calibre9">Account</code>, a protocol that describes what any account should have &mdash; the ability to deposit, withdraw, and check the balance of funds.
</p>
<p class="calibre1">Now add a conforming type with the code below:
</p><pre class="code-block"><span class="hljs-keyword">typealias</span> <span class="hljs-built_in">Dollars</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>

<span class="hljs-comment">/// A U.S. Dollar based "basic" account.</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">BasicAccount</span>: <span class="hljs-number">Account</span> {

  <span class="hljs-keyword">var</span> balance: <span class="hljs-built_in">Dollars</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>

  <span class="hljs-keyword">func</span> <span class="hljs-number">deposit</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>) {
    balance <span class="hljs-operator">+=</span> amount
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">withdraw</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>) {
    <span class="hljs-keyword">if</span> amount <span class="hljs-operator">&lt;=</span> balance {
      balance <span class="hljs-operator">-=</span> amount
    } <span class="hljs-keyword">else</span> {
      balance <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    }
  }
}</pre>
<p class="calibre1">This conforming class, <code class="calibre9">BasicAccount</code>, implements <code class="calibre9">deposit(amount:)</code> and <code class="calibre9">withdraw(amount:)</code> by simply adding or subtracting from the balance (typed in <code class="calibre9">Dollars</code>, an alias for <code class="calibre9">Double</code>). Although this code is very straightforward, you may notice a slight issue. The <code class="calibre9">balance</code> property in the <code class="calibre9">Account</code> protocol is read-only &mdash; in other words, it only has a <code class="calibre9">get</code> requirement.
</p>
<p class="calibre1">However, <code class="calibre9">BasicAccount</code> implements <code class="calibre9">balance</code> as a variable that is both readable and writeable.
</p>
<p class="calibre1">Nothing can prevent other code from directly assigning new values for <code class="calibre9">balance</code>:
</p><pre class="code-block"><span class="hljs-comment">// Create a new account</span>
<span class="hljs-keyword">let</span> account <span class="hljs-operator">=</span> <span class="hljs-built_in">BasicAccount</span>()

<span class="hljs-comment">// Deposit and withdraw some money</span>
account.deposit(amount: <span class="hljs-number">10.00</span>)
account.withdraw(amount: <span class="hljs-number">5.00</span>)

<span class="hljs-comment">// ... or do evil things!</span>
account.balance <span class="hljs-operator">=</span> <span class="hljs-number">1000000.00</span></pre>
<p class="calibre1">Oh no! Even though you carefully designed the <code class="calibre9">Account</code> protocol to only be able to <code class="calibre9">deposit</code> or <code class="calibre9">withdraw</code> funds, the implementation details of <code class="calibre9">BasicAccount</code> make it possible for outside to change the internal state arbitrarily.
</p>
<p class="calibre1">Fortunately, you can use access control to limit the scope at which your code is visible to other types, files or even software modules!
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Access control is not a security feature protecting your code from malicious hackers. Instead, it lets you express intent by generating helpful compiler errors if a user attempts directly access implementation details that may compromise the invariant, and therefore, correctness.
</p></div>

<h2 class="segment-chapter1">Introducing access control</h2>

<p class="calibre1">You can add access modifiers by placing a modifier keyword in front of a property, method or type declaration.
</p>
<p class="calibre1">Add the access control modifier <code class="calibre9">private(set)</code> to the definition of <code class="calibre9">balance</code> in <code class="calibre9">BasicAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> balance: <span class="hljs-built_in">Dollars</span></pre>
<p class="calibre1">The access modifier above is placed before the property declaration and includes an optional <code class="calibre9">get</code>/<code class="calibre9">set</code> modifier in parentheses. In this example, the setter of <code class="calibre9">balance</code> is made <code class="calibre9">private</code>.
</p>
<p class="calibre1">You’ll cover the details of <code class="calibre9">private</code> shortly, but you can see it in action already: your code no longer compiles!
</p><div class="image9"><img src="images/000118.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">By adding <code class="calibre9">private</code> to the property setter, the property becomes inaccessible to the consuming code.
</p>
<p class="calibre1">This example demonstrates the fundamental benefit of access modifiers: they restrict access to code that <i class="calibre2">needs</i> or <i class="calibre2">should</i> have access to and prevent access to code that doesn’t need it. Effectively, access control allows you to control the code’s accessible interface while defining whatever properties, methods or types you need to implement the behavior you want.
</p>
<p class="calibre1">The <code class="calibre9">private</code> modifier used in the brief example above is one of several access modifiers available to you in Swift:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9"><em class="calibre13">private</em></code>: Accessible only to the defining type, all nested types and extensions on that type within the same source file.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9"><em class="calibre13">fileprivate</em></code>: Accessible from anywhere within the source file in which it’s defined.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9"><em class="calibre13">internal</em></code>: Accessible from anywhere within the <i class="calibre2">module</i> in which it’s defined. This level is the <em class="calibre5">default</em> access level. If you don’t write anything, this is what you get.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9"><em class="calibre13">public</em></code>: Accessible from anywhere that imports the module.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9"><em class="calibre13">open</em></code>: The same as <code class="calibre9">public</code>, with the additional ability granted to <i class="calibre2">override</i> the code in another module.
</p></li>
</ul>

<p class="calibre1">Next, you will learn more about these modifiers, when to use them, and how to apply them to your code.
</p>
<h3 class="segment-title2">Private</h3>

<p class="calibre1">The <code class="calibre9">private</code> access modifier restricts access to the entity it is defined in and any nested type within it &mdash; also known as the “lexical scope”. Extensions on the type within the same source file can also access the entity.
</p>
<p class="calibre1">To demonstrate, continue with your banking library by extending the behavior of <code class="calibre9">BasicAccount</code> to make a <code class="calibre9">CheckingAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">CheckingAccount</span>: <span class="hljs-number">BasicAccount</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> accountNumber <span class="hljs-operator">=</span> <span class="hljs-built_in">UUID</span>().uuidString

  <span class="hljs-keyword">class</span> <span class="hljs-number">Check</span> {
    <span class="hljs-keyword">let</span> account: <span class="hljs-built_in">String</span>
    <span class="hljs-keyword">var</span> amount: <span class="hljs-built_in">Dollars</span>
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> cashed <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>

    <span class="hljs-keyword">func</span> <span class="hljs-number">cash</span>() {
      cashed <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
    }

    <span class="hljs-keyword">init</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">account</span>: <span class="hljs-built_in">CheckingAccount</span>) {
      <span class="hljs-keyword">self</span>.amount <span class="hljs-operator">=</span> amount
      <span class="hljs-keyword">self</span>.account <span class="hljs-operator">=</span> account.accountNumber
    }
  }
}</pre>
<p class="calibre1"><code class="calibre9">CheckingAccount</code> has an <code class="calibre9">accountNumber</code> declared as <code class="calibre9">private</code>. <code class="calibre9">CheckingAccount</code> also has a nested type <code class="calibre9">Check</code> that can read the <code class="calibre9">private</code> value of <code class="calibre9">accountNumber</code> in its initializer.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> In this example, the <code class="calibre9">UUID</code> type provides a unique account number. This class is part of the Foundation module, so don’t forget to import it!
</p></div>

<p class="calibre1">Checking accounts should be able to write and cash checks as well. Add the following methods to <code class="calibre9">CheckingAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">writeCheck</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>) -&gt; <span class="hljs-built_in">Check</span>? {
  <span class="hljs-keyword">guard</span> balance <span class="hljs-operator">&gt;</span> amount <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
  }

  <span class="hljs-keyword">let</span> check <span class="hljs-operator">=</span> <span class="hljs-built_in">Check</span>(amount: amount, from: <span class="hljs-keyword">self</span>)
  withdraw(amount: check.amount)
  <span class="hljs-keyword">return</span> check
}

<span class="hljs-keyword">func</span> <span class="hljs-number">deposit</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">check</span>: <span class="hljs-built_in">Check</span>) {
  <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>check.cashed <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
  }

  deposit(amount: check.amount)
  check.cash()
}</pre>
<p class="calibre1">While <code class="calibre9">CheckingAccount</code> can still make necessary deposits and withdrawals, it can now also write and deposit checks! The method <code class="calibre9">writeCheck(amount:)</code> verifies a sufficient balance before withdrawing the amount and creating a check. <code class="calibre9">deposit(_:)</code> will not deposit an already cashed check.
</p>
<p class="calibre1">Give this code a try in your playground by having John write a check to Jane:
</p><pre class="code-block"><span class="hljs-comment">// Create a checking account for John. Deposit $300.00</span>
<span class="hljs-keyword">let</span> johnChecking <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
johnChecking.deposit(amount: <span class="hljs-number">300.00</span>)

<span class="hljs-comment">// Write a check for $200.00</span>
<span class="hljs-keyword">let</span> check <span class="hljs-operator">=</span> johnChecking.writeCheck(amount: <span class="hljs-number">200.0</span>)<span class="hljs-operator">!</span>

<span class="hljs-comment">// Create a checking account for Jane, and deposit the check.</span>
<span class="hljs-keyword">let</span> janeChecking <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
janeChecking.deposit(check)
janeChecking.balance <span class="hljs-comment">// 200.00</span>

<span class="hljs-comment">// Try to cash the check again. Of course, it had no effect on</span>
<span class="hljs-comment">// Jane’s balance this time :]</span>
janeChecking.deposit(check)
janeChecking.balance <span class="hljs-comment">// 200.00</span></pre>
<p class="calibre1">Of course, this code works great; the <i class="calibre2">real</i> story is what this code <i class="calibre2">can’t</i> do. Remember that access control lets you control the interface to your code. Look at what the autocomplete window shows as the interface for <code class="calibre9">CheckingAccount</code>:
</p><div class="image"><img src="images/000005.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The <code class="calibre9">accountNumber</code> is treated as an implementation detail of <code class="calibre9">CheckingAccount</code> and isn’t visible to consuming code.Likewise, <code class="calibre9">Check</code> makes the setter for <code class="calibre9">cashed</code> private and requires consumers to use <code class="calibre9">cash()</code> instead:
</p><div class="image"><img src="images/000018.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">This interface gives <code class="calibre9">Check</code> a way for consumers to mark a check as deposited, but not the other way around! In other words, it is not possible to un-cash a check.
</p>
<p class="calibre1">Finally, even though <code class="calibre9">accountNumber</code> was not visible on <code class="calibre9">CheckingAccount</code>, the number is made accessible by anyone holding a <code class="calibre9">Check</code>:
</p><div class="image1"><img src="images/000031.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">While the <code class="calibre9">account</code> property got its value from the <code class="calibre9">CheckingAccount</code>, that’s another implementation detail. The important thing is that access modifiers let the code shape its interface regardless of the code used to implement it.
</p>
<h3 class="segment-title2">Playground sources</h3>

<p class="calibre1">Before jumping into the rest of this chapter, you’ll need to learn a new Swift playground feature: source files.
</p>
<p class="calibre1">In Xcode, make sure the Project Navigator is visible by going to <em class="calibre5">View</em><em class="calibre5">\</em><em class="calibre5">Navigators</em><em class="calibre5">\</em><em class="calibre5">Show Project Navigator</em>. Under the playground tree, look for a slightly dimmed folder named <em class="calibre5">Sources</em>:
</p><div class="image5"><img src="images/000044.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Right-click on the folder, select <em class="calibre5">New File</em> and name the file <em class="calibre5">Account</em><em class="calibre5">.</em><em class="calibre5">swift</em>. Move the <code class="calibre9">Account</code> protocol, the <code class="calibre9">BasicAccount</code> class, and the <code class="calibre9">Dollars</code> typealias to this file.
</p>
<p class="calibre1">Create one more source file and name it <em class="calibre5">Checking</em><em class="calibre5">.</em><em class="calibre5">swift</em>. Move <code class="calibre9">CheckingAccount</code> into this file.
</p>
<p class="calibre1">That’s it! The critical thing to note about the Sources folder is that Xcode treats the code in it as a separate module.
</p>
<p class="calibre1">You can comment out the rest of the code in your playground for now. It won’t be able to “see” the code you just moved until later in this chapter.
</p>
<h3 class="segment-title2">Fileprivate</h3>

<p class="calibre1">Closely related to <code class="calibre9">private</code> is <code class="calibre9">fileprivate</code>, which permits access to any code written in the same <em class="calibre5">file</em> as the entity, instead of the same lexical scope and extensions within the same file that <code class="calibre9">private</code> provides. You’ll use the two new files you just created to try this out!
</p>
<p class="calibre1">Right now, nothing is preventing a haphazard coder who doesn’t read the documentation from creating a <code class="calibre9">Check</code> on their own. In your safe code, you want a <code class="calibre9">Check</code> to only originate from <code class="calibre9">CheckingAccount</code> so that it can keep track of balances.
</p>
<p class="calibre1">In the <code class="calibre9">Check</code> class, try adding the <code class="calibre9">private</code> modifier to the initializer:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">account</span>: <span class="hljs-built_in">CheckingAccount</span>) { <span class="hljs-comment">//...</span></pre>
<p class="calibre1">While this prevents incorrect code from creating a <code class="calibre9">Check,</code> you’ll notice it also prevents <code class="calibre9">CheckingAccount</code> from creating one as well. <code class="calibre9">private</code> entities can be accessed from anything <i class="calibre2">within</i> lexical scope. Still, in this case, <code class="calibre9">CheckingAccount</code> is one step <i class="calibre2">outside</i> the scope of <code class="calibre9">Check</code>. Fortunately, this is where <code class="calibre9">fileprivate</code> is very useful.
</p>
<p class="calibre1">Replace the initializer instead with <code class="calibre9">fileprivate</code>:
</p><pre class="code-block"><span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">account</span>: <span class="hljs-built_in">CheckingAccount</span>) { <span class="hljs-comment">//...</span></pre>
<p class="calibre1">Great! Now <code class="calibre9">CheckingAccount</code> can still write checks, but you can’t create them from anywhere else.
</p>
<p class="calibre1">The <code class="calibre9">fileprivate</code> modifier is ideal for code that is “cohesive” within a source file; that is, code that is closely related or serves enough of a common purpose to have shared but protected access. <code class="calibre9">Check</code> and <code class="calibre9">CheckingAccount</code> are examples of two cohesive types.
</p>
<h3 class="segment-title2">Internal, public and open</h3>

<p class="calibre1">With <code class="calibre9">private</code> and <code class="calibre9">fileprivate</code>, you could protect code from being accessed by other types and files. These access modifiers <i class="calibre2">modified</i> access from the default access level of <em class="calibre5">internal</em>.
</p>
<p class="calibre1">The <code class="calibre9">internal</code> access level means that an entity can be accessed from anywhere within the software <i class="calibre2">module</i> in which it’s defined. So far, you’ve written all of your code in a single playground file, which means it’s all been in the same module.
</p>
<p class="calibre1">When you added code to the Sources directory in your playground, you effectively created a module that your playground consumed. The way playgrounds work in Xcode, all files in the Sources directory are part of one module, and everything in the playground is another module that <i class="calibre2">consumes</i> the module in the Sources folder.
</p>
<h4 class="segment-title2">Internal</h4>

<p class="calibre1">Back in your playground, uncomment the code that handles John writing checks to Jane:
</p><pre class="code-block"><span class="hljs-comment">// Create a checking account for John. Deposit $300.00</span>
<span class="hljs-keyword">let</span> johnChecking <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
johnChecking.deposit(amount: <span class="hljs-number">300.00</span>)
<span class="hljs-comment">// ...</span></pre>
<p class="calibre1"><code class="calibre9">CheckingAccount</code> has no access modifier specified and is treated as <code class="calibre9">internal</code>, so it is inaccessible to the playground.
</p><div class="image3"><img src="images/000057.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The result is that Swift displays a build error when trying to use the <code class="calibre9">CheckingAccount</code> type.
</p>
<p class="calibre1">To remedy this, you will have to learn about the <code class="calibre9">public</code> and <code class="calibre9">open</code> access modifiers.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Because <code class="calibre9">internal</code> is the default access level, you never need to declare your code <code class="calibre9">internal</code> explicitly. Whether you use the <code class="calibre9">internal</code> keyword in your definitions is a matter of style and preference.
</p></div>

<h4 class="segment-title2">Public</h4>

<p class="calibre1">To make <code class="calibre9">CheckingAccount</code> visible to your playground, you’ll need to change the access level from <code class="calibre9">internal</code> to <code class="calibre9">public</code>. An entity that is <code class="calibre9">public</code> can be seen and used by code outside the module in which it’s defined.
</p>
<p class="calibre1">Add the <code class="calibre9">public</code> modifier to class <code class="calibre9">CheckingAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-number">CheckingAccount</span>: <span class="hljs-number">BasicAccount</span> {</pre>
<p class="calibre1">You’ll also need to add <code class="calibre9">public</code> to <code class="calibre9">BasicAccount</code> since <code class="calibre9">CheckingAccount</code> subclasses it:
</p><pre class="code-block"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-number">BasicAccount</span>: <span class="hljs-number">Account</span></pre>
<p class="calibre1">The playground will now recognize <code class="calibre9">CheckingAccount</code>, yet you’re still not able to instantiate it.
</p><div class="image3"><img src="images/000069.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">While the type itself is now public, its members are still internal and unavailable outside the module. You’ll need to add <code class="calibre9">public</code> modifiers to all the entities you want to be part of your module’s interface.
</p>
<p class="calibre1">Start by adding a public initializer to <code class="calibre9">BasicAccount</code> and <code class="calibre9">CheckingAccount</code>:
</p><pre class="code-block"><span class="hljs-comment">// In BasicAccount:</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() { }

<span class="hljs-comment">// In CheckingAccount:</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() { }</pre>
<p class="calibre1">Next, in <code class="calibre9">BasicAccount</code>, add <code class="calibre9">public</code> to <code class="calibre9">balance</code>, <code class="calibre9">deposit(amount:)</code> and <code class="calibre9">withdraw(amount:)</code>. You’ll also need to make the <code class="calibre9">Dollars</code> typealias public, as this typealias is now used in public methods.
</p>
<p class="calibre1">Finally, in <code class="calibre9">CheckingAccount</code>, add <code class="calibre9">public</code> to <code class="calibre9">writeCheck(amount:)</code>, <code class="calibre9">deposit(_:)</code> and class <code class="calibre9">Check</code>. Save all files. You’ll find that everything builds and runs!
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Even though <code class="calibre9">BasicAccount</code> adopts <code class="calibre9">Account</code>, you may notice that the playground can’t see <code class="calibre9">Account</code>, nor does it know that <code class="calibre9">BasicAccount</code> conforms to it. Protocol conformance will be invisible to consuming modules if the protocol itself is not accessible.
</p></div>

<h4 class="segment-title2">Open</h4>

<p class="calibre1">Now that <code class="calibre9">CheckingAccount</code> and its public members are visible to the playground, you can use your banking interface as designed.
</p>
<p class="calibre1">Well &mdash; almost! The banking library should provide a set of standard accounts such as checking accounts and be open to extensibility for any special kind of account a bank may have.
</p>
<p class="calibre1">In your playground, create an interest-accumulating <code class="calibre9">SavingsAccount</code> that subclasses <code class="calibre9">BasicAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">SavingsAccount</span>: <span class="hljs-number">BasicAccount</span> {
  <span class="hljs-keyword">var</span> interestRate: <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">interestRate</span>: <span class="hljs-built_in">Double</span>) {
    <span class="hljs-keyword">self</span>.interestRate <span class="hljs-operator">=</span> interestRate
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">processInterest</span>() {
    <span class="hljs-keyword">let</span> interest <span class="hljs-operator">=</span> balance <span class="hljs-operator">*</span> interestRate
    deposit(amount: interest)
  }
}</pre>
<p class="calibre1">While <code class="calibre9">BasicAccount</code> is declared <code class="calibre9">public</code> and is accessible to the playground, Swift will show a build error when trying to subclass <code class="calibre9">BasicAccount</code>:
</p><div class="image3"><img src="images/000080.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can override a class, method, or property from another model by declaring it <code class="calibre9">open</code>. Go to the file <em class="calibre5">Account</em><em class="calibre5">.</em><em class="calibre5">swift</em> and replace the <code class="calibre9">public</code> access modifier for class <code class="calibre9">BasicAccount</code> with <code class="calibre9">open</code>:
</p><pre class="code-block"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-number">BasicAccount</span>: <span class="hljs-number">Account</span> { <span class="hljs-comment">//..</span></pre>
<p class="calibre1">Do you see it all coming together? The interfaces you’ve crafted using <code class="calibre9">public</code> and <code class="calibre9">open</code> permit subclassing of <code class="calibre9">BasicAccount</code> to provide new types of accounts. <code class="calibre9">withdraw(amount:)</code> and <code class="calibre9">deposit(amount:)</code>, because they’re public, can be used by those subclasses. The implementations of <code class="calibre9">withdraw(amount:)</code> and <code class="calibre9">deposit(amount:)</code> are safe from being overridden because they’re only public, not open!
</p>
<p class="calibre1">Imagine if you could override <code class="calibre9">withdraw(amount:)</code> and <code class="calibre9">deposit(amount:)</code>:
</p><pre class="code-block"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">deposit</span>(<span class="hljs-built_in">amount</span>: <span class="hljs-built_in">Dollars</span>) {
    <span class="hljs-comment">// LOL</span>
    <span class="hljs-keyword">super</span>.deposit(amount: <span class="hljs-number">1_000_000.00</span>)
}</pre>
<p class="calibre1">Oh noes!
</p>
<p class="calibre1">If you’re creating a library, you often want to restrict the ability to override methods and properties so you can avoid otherwise surprising behavior. The <code class="calibre9">open</code> access modifier allows you to control what other modules do to your code explicitly.
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a struct <code class="calibre9">Person</code> in a new Sources file. This struct should have <code class="calibre9">first</code>, <code class="calibre9">last</code> and <code class="calibre9">fullName</code> properties readable but not writable by the playground.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a similar type, except make it a class and call it <code class="calibre9">ClassyPerson</code>. In the playground, subclass <code class="calibre9">ClassyPerson</code> with class <code class="calibre9">Doctor</code> and make a doctor’s <code class="calibre9">fullName</code> print the prefix <code class="calibre9">"Dr."</code>.
</p></li>
</ol>

<h2 class="segment-chapter1">Organizing code into extensions</h2>

<p class="calibre1">A theme of access control is the idea that your code should be loosely coupled and highly cohesive. Loosely coupled code limits how much one entity knows about another, which in turn makes different parts of your code less dependent on others. As you learned earlier, highly cohesive code helps closely related code work together to fulfill a task.
</p>
<p class="calibre1">Swift features such as access modifiers, when used with extensions, can help you both organize your code and encourage good software design.
</p>
<h3 class="segment-title2">Extensions by behavior</h3>

<p class="calibre1">An effective strategy in Swift is to organize your code into extensions by behavior. You can even apply access modifiers to extensions themselves, which will help you categorize entire code sections as <code class="calibre9">public</code>, <code class="calibre9">internal</code> or <code class="calibre9">private</code>.
</p>
<p class="calibre1">Begin by adding some basic fraud protection to <code class="calibre9">CheckingAccount</code>. Add the following properties to <code class="calibre9">CheckingAccount</code>:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> issuedChecks: [<span class="hljs-built_in">Int</span>] <span class="hljs-operator">=</span> []
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentCheck <span class="hljs-operator">=</span> <span class="hljs-number">1</span></pre>
<p class="calibre1">These will keep track of checks that have been written by the checking account.
</p>
<p class="calibre1">Next, add the following private extension:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">extension</span> <span class="hljs-number">CheckingAccount</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">inspectForFraud</span>(<span class="hljs-built_in">with</span> <span class="hljs-built_in">checkNumber</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Bool</span> {
    issuedChecks.contains(checkNumber)
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">nextNumber</span>() -&gt; <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">let</span> next <span class="hljs-operator">=</span> currentCheck
    currentCheck <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> next
  }
}</pre>
<p class="calibre1"><code class="calibre9">CheckingAccount</code> can use these two methods to determine the check number and confirm that the account issued it.
</p>
<p class="calibre1">Notably, this extension is marked <code class="calibre9">private</code>. A <code class="calibre9">private</code> extension implicitly denotes all of its members as <code class="calibre9">private</code>. These fraud protection tools are features of <code class="calibre9">CheckingAccount</code> only &mdash; you don’t want other code incrementing the <code class="calibre9">currentCheck</code> number! Putting these two methods together also connects two related, cohesive methods. It’s clear to yourself and anyone else maintaining the code that these two are <i class="calibre2">cohesive</i> and help solve a common task.
</p>
<h3 class="segment-title2">Extensions by protocol conformance</h3>

<p class="calibre1">Another effective technique is to organize your extensions based on protocol conformance. You’ve already seen this technique used in Chapter 16, “Protocols”. As an example, let’s make <code class="calibre9">CheckingAccount</code> conform to <code class="calibre9">CustomStringConvertible</code> by adding the following extension:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">CheckingAccount</span>: <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"Checking Balance: $<span class="hljs-subst">\(balance)</span>"</span>
  }
}</pre>
<p class="calibre1">This extension implements <code class="calibre9">CustomStringConvertible</code>, and more importantly:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Makes it obvious <code class="calibre9">description</code> is part of <code class="calibre9">CustomStringConvertible</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><i class="calibre2">Doesn’t</i> help conform to other protocols.
</p></li>

<li class="calibre4">
<p class="calibre1">Can easily be removed without doing collateral damage to the rest of <code class="calibre9">CheckingAccount</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">It’s easy to understand!
</p></li>
</ul>

<h3 class="segment-title2">available()</h3>

<p class="calibre1">If you take a look at <code class="calibre9">SavingsAccount</code>, you’ll notice that you can abuse <code class="calibre9">processInterest()</code> by calling it multiple times and repeatedly adding interest to the account. To make this function more secure, you can add a PIN to the account.
</p>
<p class="calibre1">Add a <code class="calibre9">pin</code> property to <code class="calibre9">SavingsAccount</code>, and ensure the initializer and <code class="calibre9">processInterest()</code> method take this PIN as a parameter. The class should look like this:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">SavingsAccount</span>: <span class="hljs-number">BasicAccount</span> {
  <span class="hljs-keyword">var</span> interestRate: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> pin: <span class="hljs-built_in">Int</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">interestRate</span>: <span class="hljs-built_in">Double</span>, <span class="hljs-built_in">pin</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">self</span>.interestRate <span class="hljs-operator">=</span> interestRate
    <span class="hljs-keyword">self</span>.pin <span class="hljs-operator">=</span> pin
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">processInterest</span>(<span class="hljs-built_in">pin</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">if</span> pin <span class="hljs-operator">==</span> <span class="hljs-keyword">self</span>.pin {
      <span class="hljs-keyword">let</span> interest <span class="hljs-operator">=</span> balance <span class="hljs-operator">*</span> interestRate
      deposit(amount: interest)
    }
  }
}</pre>
<p class="calibre1">You’re thrilled with the new layer of security. However, after you send this updated code to the bank, you get angry phone calls. The bank’s code now doesn’t compile because it was using your old <code class="calibre9">SavingsAccount</code> class.
</p>
<p class="calibre1">To prevent breaking code that uses the old implementation, you need to deprecate the code rather than replacing it. Luckily, Swift has built-in support for this.
</p>
<p class="calibre1">Bring back the old implementation of the initializer and <code class="calibre9">processInterest()</code>, and add this line of code before the initializer:
</p><pre class="code-block"><span class="hljs-keyword">@available</span>(<span class="hljs-operator">*</span>, deprecated, message: <span class="hljs-string">"Use init(interestRate:pin:) instead"</span>)</pre>
<p class="calibre1">And this line of code before <code class="calibre9">processInterest()</code>:
</p><pre class="code-block"><span class="hljs-keyword">@available</span>(<span class="hljs-operator">*</span>, deprecated, message: <span class="hljs-string">"Use processInterest(pin:) instead"</span>)</pre>
<p class="calibre1">Now, these methods still work as expected; however, Xcode generates a warning with your custom message when someone tries to use them:
</p><div class="image3"><img src="images/000090.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The asterisk in the parameters denotes which platforms are affected by this deprecation. It accepts the values <code class="calibre9">*</code>, <code class="calibre9">iOS</code>, <code class="calibre9">iOSMac</code>, <code class="calibre9">tvOS</code> or <code class="calibre9">watchOS</code>. The second parameter details whether this method is <code class="calibre9">deprecated</code>, <code class="calibre9">renamed</code> or <code class="calibre9">unavailable</code>.
</p>
<h3 class="segment-title2">Opaque return types</h3>

<p class="calibre1">Imagine you need to create a public API for users of your banking library. You’re required to make a function called <code class="calibre9">createAccount</code> that creates a new account and returns it. One of the requirements of this API is to hide implementation details so that clients are encouraged to write generic code. It means that you shouldn’t expose the type of account you’re creating, be it a <code class="calibre9">BasicAccount</code>, <code class="calibre9">CheckingAccount</code> or <code class="calibre9">SavingsAccount</code>. Instead, you’ll return <i class="calibre2">some</i> instance that conforms to the protocol <code class="calibre9">Account</code>.
</p>
<p class="calibre1">To enable that, you need first to make the <code class="calibre9">Account</code> protocol public. Open <em class="calibre5">Account</em><em class="calibre5">.</em><em class="calibre5">swift</em> and add the <code class="calibre9">public</code> modifier before <code class="calibre9">protocol Account</code>. Now go back to your playground and insert this code:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">createAccount</span>() -&gt; <span class="hljs-built_in">Account</span> {
  <span class="hljs-built_in">CheckingAccount</span>()
}</pre>
<p class="calibre1">You’ll notice you get an error:
</p><div class="image3"><img src="images/000102.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">To solve this, you can add the keyword <code class="calibre9">some</code> before the return type so that it would look like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">createAccount</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">Account</span> {
  <span class="hljs-built_in">CheckingAccount</span>()
}</pre>
<p class="calibre1">This code is an opaque return type, and it lets the function decide what kind of <code class="calibre9">Account</code> it wants to return without exposing the class type.
</p>
<p class="calibre1">You’ll learn more about this feature in Chapter 28,  “Advanced Protocols &amp; Generics”.
</p>
<h2 class="segment-chapter1">Swift Package Manager</h2>

<p class="calibre1">Another powerful way to organize your code is to use Swift Package Manager, or SwiftPM for short. SwiftPM lets you “package” your module so that you or other developers can easily use it in their code. For example, a module that implements the logic of downloading images from the web is useful in many projects. Instead of copying &amp; pasting the code to all your projects that need image downloading functionality, you could import this module and reuse it.
</p>
<p class="calibre1">Swift Package Manager is out of scope for this book; however, you can read more about it here: <code class="calibre9">https://swift.org/package-manager/</code>.
</p>
<h2 class="segment-chapter1">Testing</h2>

<p class="calibre1">Imagine new engineers join your team to work on your banking library. These engineers are tasked with updating the <code class="calibre9">SavingsAccount</code> class to support taking loans. For that, they will need to update the basic functionally of the code you’ve written. This change is risky since they’re not familiar with the code, and their changes might introduce bugs to the existing logic. An excellent way to prevent this from happening is to write unit tests.
</p>
<p class="calibre1">Unit tests are pieces of code whose purpose is to test that your existing code works as expected. For example, you might write a test that deposits $100 to a new account and then verifies the balance is indeed $100.
</p>
<p class="calibre1">It might sound like overkill at first, but when many engineers are working on a codebase or going back to make changes to the code you wrote a long time ago, unit tests help you verify that you don’t break anything.
</p>
<h3 class="segment-title2">Creating a test class</h3>

<p class="calibre1">To write unit tests, you first need to import the XCTest framework. Add this at the top of the playground:
</p><pre class="code-block"><span class="hljs-keyword">import</span> XCTest</pre>
<p class="calibre1">Next, you need to create a new class that’s a subclass of <code class="calibre9">XCTestCase</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">BankingTests</span>: <span class="hljs-number">XCTestCase</span> {
}</pre>
<h3 class="segment-title2">Writing tests</h3>

<p class="calibre1">Once you have your test class ready, it’s time to add some tests. Tests should cover the core functionality of your code and some edge cases. The acronym FIRST describes a concise set of criteria for useful unit tests. Those criteria are:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Fast</em>: Tests should run quickly.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Independent/Isolated</em>: Tests should not share state.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Repeatable</em>: You should obtain the same results every time you run a test.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Self</em><em class="calibre5">-</em><em class="calibre5">validating</em>: Tests should be fully automated, and the output should be either “pass” or “fail”.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Timely</em>: Ideally, write tests before writing the code they test (Test-Driven Development).
</p></li>
</ul>

<p class="calibre1">Adding tests to a test class is super easy - just add a function that starts with the word <code class="calibre9">test</code>, takes no arguments and returns nothing.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testSomething</span>() {
}</pre>
<p class="calibre1">Congratulations! You’ve just written your first test.
</p>
<p class="calibre1">To run your tests in the playground, add this at the bottom, outside of the <code class="calibre9">BankingTests</code> class.
</p><pre class="code-block"><span class="hljs-built_in">BankingTests</span>.defaultTestSuite.run()</pre>
<p class="calibre1">Now run the playground, and you’ll see something similar to this printed to the console:
</p><pre class="code-block">Test Suite 'BankingTests' started at ...
Test Case '-[__lldb_expr_2.BankingTests testSomething]' started.
Test Case '-[__lldb_expr_2.BankingTests testSomething]' passed (0.837 seconds).
Test Suite 'BankingTests' passed at ...
   Executed 1 test, with 0 failures (0 unexpected) in 0.837 (0.840) seconds</pre>
<p class="calibre1">The test passed, which is unsurprising since it does nothing at the moment.
</p>
<h3 class="segment-title2">XCTAssert</h3>

<p class="calibre1"><code class="calibre9">XCTAssert</code> functions ensure your tests meet certain conditions. For example, you can verify that a certain value is greater than zero or that an object isn’t <code class="calibre9">nil</code>. Here’s an example of how to check that a new account starts with zero balance. Replace the <code class="calibre9">testSomething</code> method with this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testNewAccountBalanceZero</span>() {
  <span class="hljs-keyword">let</span> checkingAccount <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
  <span class="hljs-built_in">XCTAssertEqual</span>(checkingAccount.balance, <span class="hljs-number">0</span>)
}</pre>
<p class="calibre1">The method <code class="calibre9">XCTAssertEqual</code> verifies that the two parameters are equal, or else it fails the test. Note how the name of the test explicitly states what it tests.
</p>
<p class="calibre1">If you run your playground now, this should appear in your console:
</p><pre class="code-block">Test Case '-[__lldb_expr_4.BankingTests testNewAccountBalanceZero]' started.
Test Case '-[__lldb_expr_4.BankingTests testNewAccountBalanceZero]' passed (0.030 seconds).</pre>
<p class="calibre1">Awesome, your test is passing! If someone makes changes that inadvertently cause new accounts to start with a balance other than zero, the test will fail. Why not test it? Open the file <code class="calibre9">Account.swift</code>, find this line:
</p><pre class="code-block"><span class="hljs-keyword">public</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> balance: <span class="hljs-built_in">Dollars</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span></pre>
<p class="calibre1">and replace the <code class="calibre9">0.0</code> with <code class="calibre9">1.0</code>. Now run the test in your playground and you should see this printed to the console:
</p><pre class="code-block">error: -[BankingTests testNewAccountBalanceZero] : XCTAssertEqual failed: ("1.0") is not equal to ("0.0")</pre>
<p class="calibre1">You can see the test fails, and it even tells you why it failed! This functionality is the real power of unit tests. From now on, tests protect your accounts code from this kind of mistake.
</p>
<p class="calibre1">Now go ahead and return the variable <code class="calibre9">balance</code> to be <code class="calibre9">0.0</code> and then add one more test:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testCheckOverBudgetFails</span>() {
    <span class="hljs-keyword">let</span> checkingAccount <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
    <span class="hljs-keyword">let</span> check <span class="hljs-operator">=</span> checkingAccount.writeCheck(amount: <span class="hljs-number">100</span>)
    <span class="hljs-built_in">XCTAssertNil</span>(check)
}</pre>
<p class="calibre1">Can you figure out what this test does? It creates a new account and then tries to write a check for $100. The account balance is zero, so this test verifies that writing a check fails and returns <code class="calibre9">nil</code>.
</p>
<h3 class="segment-title2">XCTFail and XCTSkip</h3>

<p class="calibre1">If a certain pre-condition isn’t met, you can opt to fail the test. For example, suppose you’re writing a test to verify an API that’s only available on iOS 14 and above. In that case, you can fail the test for iOS simulators running older versions with an informative message:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testNewAPI</span>() {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">14</span>, <span class="hljs-operator">*</span>) <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">XCTFail</span>(<span class="hljs-string">"Only available in iOS 14 and above"</span>)
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// perform test</span>
}</pre>
<p class="calibre1">Alternatively, instead of failing the test, you can skip it. <code class="calibre9">XCTSkip</code> is a type of <code class="calibre9">Error</code> that a test can throw.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testNewAPI</span>() <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">14</span>, <span class="hljs-operator">*</span>) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">XCTSkip</span>(<span class="hljs-string">"Only available in iOS 14 and above"</span>)
    }
    <span class="hljs-comment">// perform test</span>
}</pre>
<h3 class="segment-title2">XCTFail and XCTSkip</h3>

<p class="calibre1">If a certain pre-condition isn’t met, you can opt to fail the test or skip it. For example, suppose you’re writing a test to verify an API that’s only available in iOS 15 and above. In that case, you can fail the test for iOS simulators running older versions with an informative message:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testNewAPI</span>() {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">15</span>, <span class="hljs-operator">*</span>) <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">XCTFail</span>(<span class="hljs-string">"Only availble in iOS 15 and above"</span>)
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">// perform test</span>
}</pre>
<h3 class="segment-title2">Making things @testable</h3>

<p class="calibre1">When you <code class="calibre9">import Foundation</code>, Swift brings in the public interface for that module. You might create a <code class="calibre9">Banking</code> module for your banking app that imports the public interface. But you might want to check the internal state with <code class="calibre9">XCTAssert.</code> Instead of making things public that really shouldn’t be, you can do this in your test code:
</p><pre class="code-block"><span class="hljs-keyword">@testable</span> <span class="hljs-keyword">import</span> Banking</pre>
<p class="calibre1">This attribute makes your internal interface visible. (<em class="calibre5">Note</em>: Private API remains private.) This technique is an excellent tool for testing, but you should never do this in production code. Always stick to the public API there.
</p>
<h3 class="segment-title2">The setUp and tearDown methods</h3>

<p class="calibre1">You’ll notice that both test methods start by creating a new checking account, and it’s likely that many of the tests you’d write will do the same. Luckily there’s a <code class="calibre9">setUp</code> method. This method executes before each test, and its purpose is to initialize the needed state for the tests to run.
</p>
<p class="calibre1">Add this at the top of your <code class="calibre9">BankingTests</code> class:
</p><pre class="code-block"><span class="hljs-keyword">var</span> checkingAccount: <span class="hljs-built_in">CheckingAccount</span>!

<span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">setUp</span>() {
  <span class="hljs-keyword">super</span>.setUp()
  checkingAccount <span class="hljs-operator">=</span> <span class="hljs-built_in">CheckingAccount</span>()
}</pre>
<p class="calibre1">and remove the line <code class="calibre9">let checkingAccount = CheckingAccount()</code> from both tests.
</p>
<p class="calibre1">Just as <code class="calibre9">setUp</code> executes before each test, <code class="calibre9">tearDown</code> runs after every test. It doesn’t matter whether the test passes or fails. It’s good when you need to release resources you acquired or when you need to reset the state of an object. For example, you could reset the balance of the <code class="calibre9">CheckingAccount</code> instance to zero. This code is not needed since <code class="calibre9">setUp</code> will initialize new accounts, but you can add it for the sake of the example.
</p>
<p class="calibre1">Add this below the <code class="calibre9">setUp</code> method:
</p><pre class="code-block"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">tearDown</span>() {
  checkingAccount.withdraw(amount: checkingAccount.balance)
  <span class="hljs-keyword">super</span>.tearDown()
}</pre>
<p class="calibre1">You can read more about unit tests at <code class="calibre9">https://developer.apple.com/documentation/xctest</code>.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of access control and code organization. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Singleton pattern</h3>

<p class="calibre1">A <em class="calibre5">singleton</em> is a design pattern that restricts the instantiation of a class to one object.
</p>
<p class="calibre1">Use access modifiers to create a singleton class <code class="calibre9">Logger</code>. This <code class="calibre9">Logger</code> should:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Provide shared, public, global access to the single <code class="calibre9">Logger</code> object.
</p></li>

<li class="calibre4">
<p class="calibre1">Not be able to be instantiated by consuming code.
</p></li>

<li class="calibre4">
<p class="calibre1">Have a method <code class="calibre9">log()</code> that will print a string to the console.
</p></li>
</ul>

<h3 class="segment-title2">Challenge 2: Stack</h3>

<p class="calibre1">Declare a generic type <code class="calibre9">Stack</code>. A stack is a LIFO (last-in-first-out) data structure that supports the following operations:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">peek</code>: returns the top element on the stack without removing it. Returns <code class="calibre9">nil</code> if the stack is empty.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">push</code>: adds an element on top of the stack.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">pop</code>: returns and removes the top element on the stack. Returns <code class="calibre9">nil</code> if the stack is empty.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">count</code>: returns the size of the stack.
</p></li>
</ul>

<p class="calibre1">Ensure that these operations are the only exposed interface. In other words, additional properties or methods needed to implement the type should not be visible.
</p>
<h3 class="segment-title2">Challenge 3: Character battle</h3>

<p class="calibre1">Utilize something called a <em class="calibre5">static factory method</em> to create a game of Wizards vs. Elves vs. Giants.
</p>
<p class="calibre1">Add a file <em class="calibre5">Characters</em><em class="calibre5">.</em><em class="calibre5">swift</em> in the Sources folder of your playground.
</p>
<p class="calibre1">To begin:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Create an enum <code class="calibre9">GameCharacterType</code> that defines values for <code class="calibre9">elf</code>, <code class="calibre9">giant</code> and <code class="calibre9">wizard</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a protocol <code class="calibre9">GameCharacter</code> that inherits from <code class="calibre9">AnyObject</code> and has properties <code class="calibre9">name</code>, <code class="calibre9">hitPoints</code> and <code class="calibre9">attackPoints</code>. Implement this protocol for every character type.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a struct <code class="calibre9">GameCharacterFactory</code> with a single static method <code class="calibre9">make(ofType: GameCharacterType) -&gt; GameCharacter</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a global function <code class="calibre9">battle</code> that pits two characters against each other &mdash; with the first character striking first! If a character reaches 0 hit points, they have lost.
</p></li>
</ul>

<p class="calibre1">Hints:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The playground should not be able to see the concrete types that implement <code class="calibre9">GameCharacter</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Elves have 3 hit points and 10 attack points. Wizards have 5 hit points and 5 attack points. Giants have 10 hit points and 3 attack points.
</p></li>

<li class="calibre4">
<p class="calibre1">The playground should know none of the above!
</p></li>
</ul>

<p class="calibre1">In your playground, you should use the following scenario as a test case:
</p><pre class="code-block"><span class="hljs-keyword">let</span> elf <span class="hljs-operator">=</span> <span class="hljs-built_in">GameCharacterFactory</span>.make(ofType: .elf)
<span class="hljs-keyword">let</span> giant <span class="hljs-operator">=</span> <span class="hljs-built_in">GameCharacterFactory</span>.make(ofType: .giant)
<span class="hljs-keyword">let</span> wizard <span class="hljs-operator">=</span> <span class="hljs-built_in">GameCharacterFactory</span>.make(ofType: .wizard)

battle(elf, vs: giant) <span class="hljs-comment">// Giant defeated!</span>
battle(wizard, vs: giant) <span class="hljs-comment">// Giant defeated!</span>
battle(wizard, vs: elf) <span class="hljs-comment">// Elf defeated!</span></pre>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Access control modifiers are <code class="calibre9">private</code>, <code class="calibre9">fileprivate</code>, <code class="calibre9">internal</code>, <code class="calibre9">public</code> and <code class="calibre9">open</code>. The <code class="calibre9">internal</code> access level is the default.
</p></li>

<li class="calibre4">
<p class="calibre1">Modifiers control your code’s visible interface and can hide complexity.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">private</code> and <code class="calibre9">fileprivate</code> protect code from being accessed by code in other types or files, respectively.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">public</code> and <code class="calibre9">open</code> allow code access from another module. The <code class="calibre9">open</code> modifier additionally lets you override from other modules.
</p></li>

<li class="calibre4">
<p class="calibre1">When you apply access modifiers to extensions, all members of the extension receive that access level.
</p></li>

<li class="calibre4">
<p class="calibre1">Extensions that mark protocol conformance cannot have access modifiers.
</p></li>

<li class="calibre4">
<p class="calibre1">The keyword <code class="calibre9">available</code> can be used to evolve a library by deprecating APIs.
</p></li>

<li class="calibre4">
<p class="calibre1">You use unit tests to verify your code works as expected.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">@testable import</code> lets you test internal API.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-38">


<h1 class="segment-chapter">Chapter 19: Custom Operators, Subscripts &amp; Keypaths</h1>

<p class="calibre1">You’ve learned the basics of <em class="calibre5">operator overloading</em> in Chapter 16, “Protocols”, where you implemented the <code class="calibre9">Equatable</code> and <code class="calibre9">Comparable</code> protocols and added custom behavior to standard operators.
</p>
<p class="calibre1">However, there are certain cases when overloading standard operators is simply not enough. This chapter will show you how to create custom operators from scratch and define your very own <em class="calibre5">subscripts</em>, a special case of computed properties. You’ll use subscripts to declare your own shortcuts for accessing the elements of custom types and provide <em class="calibre5">keypaths</em> as dynamic references for properties of objects.
</p>
<h2 class="segment-chapter1">Custom operators</h2>

<p class="calibre1">You declare your own operators when you want to define custom behavior not covered by the standard operators. Think of <em class="calibre5">exponentiation</em>, for example. You could overload the multiplication operator since exponentiation means repeated multiplication. Still, it would be confusing. Operators should do only one type of operation, not two.
</p>
<p class="calibre1">So you’ll define your own exponentiation operator, first only for a specific type, then extend it by making it <em class="calibre5">generic</em>. Before doing that, you need to know a little bit of theory about operator types. Time to dive in!
</p>
<h3 class="segment-title2">Types of operators</h3>

<p class="calibre1">There are three major types of operators: unary, binary and ternary.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Unary</em> operators work with only one operand and are defined either as <em class="calibre5">postfix</em> if they appear after the operand or <em class="calibre5">prefix</em> if they appear before the operand. The logical-not operator is a unary prefix operator, and the force unwrapping operator is a unary postfix one. You learned about them in Chapter 3, “Basic Control Flow,” and Chapter 6, “Optionals”.
</p></li>
</ul>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Binary</em> operators work with two operands and are <em class="calibre5">infix</em> because they appear between them. All the arithmetic operators (<code class="calibre9">+</code>, <code class="calibre9">-</code>, <code class="calibre9">*</code>, <code class="calibre9">/</code>, <code class="calibre9">%</code>),  comparison operators (<code class="calibre9">==</code>, <code class="calibre9">!=</code>, <code class="calibre9">&lt;</code>, <code class="calibre9">&gt;</code>, <code class="calibre9">&lt;=</code>, <code class="calibre9">&gt;=</code>) and most of the logical ones (<code class="calibre9">&amp;&amp;</code>, <code class="calibre9">||</code>) are binary infix.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Ternary</em> operators work with three operands. You’ve learned about the conditional operator in Chapter 3, “Basic Control Flow”, and this operator is the only ternary operator in Swift.
</p></li>
</ul>

<h3 class="segment-title2">Your own operator</h3>

<p class="calibre1">Let’s walk through the process of creating a new operator from scratch. We’ll create one for exponentiation. Since it’s a custom one, you get to choose the name yourself. It’s usually best to stick to the characters <code class="calibre9">/</code>, <code class="calibre9">=</code>, <code class="calibre9">-</code>, <code class="calibre9">+</code>, <code class="calibre9">!</code>, <code class="calibre9">*</code>, <code class="calibre9">%</code>, <code class="calibre9">&lt;</code>, <code class="calibre9">&gt;</code>, <code class="calibre9">&amp;</code>, <code class="calibre9">|</code>, <code class="calibre9">^</code> and <code class="calibre9">?</code>, although many other Unicode characters are allowed. You may need to type it often, so the fewer keystrokes, the better. Since exponentiation is repeated multiplication under the hood, it would be nice to choose something which reflects that. We’ll use <code class="calibre9">**</code> since some other languages use this name as well.
</p>
<p class="calibre1">Now for the operator’s type. The <code class="calibre9">**</code> operator works with two operands, an infix (binary) operator.
</p>
<p class="calibre1">Here’s what the operator’s signature looks like:
</p><pre class="code-block"><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-number">**</span></pre>
<p class="calibre1">Nothing fancy here: the operator’s name and type are bundled into one line of code with the <code class="calibre9">operator</code> keyword. As for the operator’s implementation, a naive one looks like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">**</span>(<span class="hljs-built_in">base</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">power</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-built_in">precondition</span>(power <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>)
  <span class="hljs-keyword">var</span> result <span class="hljs-operator">=</span> base
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">2</span><span class="hljs-operator">...</span>power {
    result <span class="hljs-operator">*=</span> base
  }
  <span class="hljs-keyword">return</span> result
}</pre>
<p class="calibre1">The function takes two arguments of type <code class="calibre9">Int</code> and uses loops, ranges and wildcards to return the first argument raised to the power of the second one. Note the multiplication assignment operator in action.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You use the <em class="calibre5">wildcard pattern</em> to discard the loop’s values. You’ll learn more about it and other pattern matching techniques in Chapter 21, “Pattern Matching”.
</p></div>

<p class="calibre1">Now test your brand-new operator:
</p><pre class="code-block"><span class="hljs-keyword">let</span> base <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> exponent <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> base <span class="hljs-operator">**</span> exponent</pre>
<h3 class="segment-title2">Compound assignment operator</h3>

<p class="calibre1">Most built-in operators have a corresponding <em class="calibre5">compound assignment</em> version. Do the same for the exponentiation operator:
</p><pre class="code-block"><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-number">**=</span>

<span class="hljs-keyword">func</span> <span class="hljs-number">**=</span>(<span class="hljs-built_in">lhs</span>: <span class="hljs-keyword">inout</span> <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">rhs</span>: <span class="hljs-built_in">Int</span>) {
  lhs <span class="hljs-operator">=</span> lhs <span class="hljs-operator">**</span> rhs
}</pre>
<p class="calibre1">The operator’s name is <code class="calibre9">**=</code> and its infix, just like the exponentiation operator created earlier. It has no return type and instead uses the <code class="calibre9">inout</code> keyword in front of the type of the operand you are modifying. You’ve already seen <code class="calibre9">inout</code> in action in Chapter 5, “Functions”. The function changes the <code class="calibre9">inout</code> parameter directly because it’s passed by reference.
</p>
<p class="calibre1">Here is how the operator works:
</p><pre class="code-block"><span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
number <span class="hljs-operator">**=</span> exponent</pre>
<p class="calibre1">Your custom operator is cool and all, but it only works for <code class="calibre9">Int</code>. Time to make it generic!
</p>
<h3 class="segment-title2">Mini-exercises</h3>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Implement a custom multiplication operator for strings so that the following code works:
</p></li>
</ol>
<pre class="code-block"><span class="hljs-keyword">let</span> baseString <span class="hljs-operator">=</span> <span class="hljs-string">"abc"</span>
<span class="hljs-keyword">let</span> times <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> multipliedString <span class="hljs-operator">=</span> baseString <span class="hljs-operator">**</span> times</pre>
<ol start="2" class="calibre11">
<li class="calibre4">
<p class="calibre1">Implement the corresponding multiplication assignment operator so that the following code runs without errors:
</p></li>
</ol>
<pre class="code-block">multipliedString <span class="hljs-operator">**=</span> times</pre>
<h3 class="segment-title2">Generic operators</h3>

<p class="calibre1">You want the exponentiation operator to work for all kind of integer types. Update your operator implementations as follows:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">**&lt;</span><span class="hljs-built_in">T</span>: <span class="hljs-built_in">BinaryInteger</span><span class="hljs-operator">&gt;</span>(base: <span class="hljs-built_in">T</span>, power: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">T</span> {
  <span class="hljs-built_in">precondition</span>(power <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>)
  <span class="hljs-keyword">var</span> result <span class="hljs-operator">=</span> base
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">2</span><span class="hljs-operator">...</span>power {
    result <span class="hljs-operator">*=</span> base
  }
  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">func</span> <span class="hljs-number">**=&lt;</span><span class="hljs-built_in">T</span>: <span class="hljs-built_in">BinaryInteger</span><span class="hljs-operator">&gt;</span>(lhs: <span class="hljs-keyword">inout</span> <span class="hljs-built_in">T</span>, rhs: <span class="hljs-built_in">Int</span>) {
  lhs <span class="hljs-operator">=</span> lhs <span class="hljs-operator">**</span> rhs
}</pre>
<p class="calibre1">Notice the <code class="calibre9">BinaryInteger</code> type constraint on the generic parameter. This constraint is required here as the <code class="calibre9">*=</code> operator used in the function body isn’t available on any type <code class="calibre9">T</code>. However, it’s available on all types that conform to the <code class="calibre9">BinaryInteger</code> protocol. The function’s body is the same as before since the generic operator does the same thing as its non-generic equivalent.
</p>
<p class="calibre1">Your previous code should still work. Now that the operator is generic, test it with some types other than <code class="calibre9">Int</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> unsignedBase: <span class="hljs-built_in">UInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> unsignedResult <span class="hljs-operator">=</span> unsignedBase <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> base8: <span class="hljs-built_in">Int8</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> result8 <span class="hljs-operator">=</span> base8 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> unsignedBase8: <span class="hljs-built_in">UInt8</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> unsignedResult8 <span class="hljs-operator">=</span> unsignedBase8 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> base16: <span class="hljs-built_in">Int16</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> result16 <span class="hljs-operator">=</span> base16 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> unsignedBase16: <span class="hljs-built_in">UInt16</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> unsignedResult16 <span class="hljs-operator">=</span> unsignedBase16 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> base32: <span class="hljs-built_in">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> result32 <span class="hljs-operator">=</span> base32 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> unsignedBase32: <span class="hljs-built_in">UInt32</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> unsignedResult32 <span class="hljs-operator">=</span> unsignedBase32 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> base64: <span class="hljs-built_in">Int64</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> result64 <span class="hljs-operator">=</span> base64 <span class="hljs-operator">**</span> exponent

<span class="hljs-keyword">let</span> unsignedBase64: <span class="hljs-built_in">UInt64</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> unsignedResult64 <span class="hljs-operator">=</span> unsignedBase64 <span class="hljs-operator">**</span> exponent</pre>
<p class="calibre1">The exponentiation operator now works for all integer types: <code class="calibre9">Int</code>, <code class="calibre9">UInt</code>, <code class="calibre9">Int8</code>, <code class="calibre9">UInt8</code>, <code class="calibre9">Int16</code>, <code class="calibre9">UInt16</code>, <code class="calibre9">Int32</code>, <code class="calibre9">UInt32</code>, <code class="calibre9">Int64</code> and <code class="calibre9">UInt64</code>.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can also use the <code class="calibre9">pow(_:_:)</code> function from the <code class="calibre9">Foundation</code> framework for exponentiation, but it doesn’t work for all the above types. However, it does handle negative and fractional exponents and O(log) instead of O(n) as in the naive implementation.
</p></div>

<h3 class="segment-title2">Precedence and associativity</h3>

<p class="calibre1">Your shiny new custom operator seems to work just fine, but if you use it in a complex expression, Swift won’t know what to do with it:
</p><pre class="code-block"><span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">**</span> <span class="hljs-number">3</span> <span class="hljs-operator">**</span> <span class="hljs-number">2</span> <span class="hljs-comment">// Does not compile!</span></pre>
<p class="calibre1">To understand this expression, Swift needs the following information about your operator:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Precedence</em>: Should the multiplication be done before or after the exponentiation?
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Associativity</em>: Should the consecutive exponentiations be done left to right or right to left?
</p></li>
</ul>

<p class="calibre1">Without this information, the only way to get Swift to understand your code is to add parentheses.
</p><pre class="code-block"><span class="hljs-number">2</span> <span class="hljs-operator">*</span> (<span class="hljs-number">2</span> <span class="hljs-operator">**</span> (<span class="hljs-number">3</span> <span class="hljs-operator">**</span> <span class="hljs-number">2</span>))</pre>
<p class="calibre1">These parentheses tell Swift that the exponentiation happens before the multiplication and from right to left. If this is always the case, you can define this behavior using a <em class="calibre5">precedence group</em>.
</p>
<p class="calibre1">Change your operator definition to the following:
</p><pre class="code-block"><span class="hljs-keyword">precedencegroup</span> <span class="hljs-number">ExponentiationPrecedence</span> {
  <span class="hljs-keyword">associativity</span>: <span class="hljs-keyword">right</span>
  <span class="hljs-keyword">higherThan</span>: <span class="hljs-built_in">MultiplicationPrecedence</span>
}

<span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> <span class="hljs-number">**</span>: <span class="hljs-built_in">ExponentiationPrecedence</span></pre>
<p class="calibre1">Here, you’re creating a precedence group for your exponentiation operator, telling Swift it’s right-associative and has higher precedence than multiplication.
</p>
<p class="calibre1">Swift will now understand your expression, even without parentheses:
</p><pre class="code-block"><span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> <span class="hljs-operator">**</span> <span class="hljs-number">3</span> <span class="hljs-operator">**</span> <span class="hljs-number">2</span></pre>
<p class="calibre1">Maybe that is a good thing, and perhaps it’s not. You may choose to make <code class="calibre9">associativity: none</code> and force users to make things explicit with parenthesis.
</p>
<p class="calibre1">That’s it for custom operators. Time for some fun with subscripts!
</p>
<h2 class="segment-chapter1">Subscripts</h2>

<p class="calibre1">You’ve already used <em class="calibre5">subscripts</em> in Chapter 7, “Arrays, Dictionaries &amp; Sets,” to retrieve the elements of arrays and dictionaries, and it’s high time you learned to create your very own subscripts. Think of them as overloading the <code class="calibre9">[]</code> operator to provide shortcuts for accessing elements of a collection, class, structure or enumeration.
</p>
<p class="calibre1">The subscript syntax is as follows:
</p><pre class="code-block"><span class="hljs-keyword">subscript</span>(parameterList) -&gt; <span class="hljs-built_in">ReturnType</span> {
  <span class="hljs-keyword">get</span> {
    <span class="hljs-comment">// return someValue of ReturnType</span>
  }
&nbsp;
  <span class="hljs-keyword">set</span>(newValue) {
    <span class="hljs-comment">// set someValue of ReturnType to newValue</span>
  }
}</pre>
<p class="calibre1">As you can see, subscripts behave like functions and computed properties:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The subscript’s prototype looks like a function’s signature: It has a parameter list and a return type, but instead of the <code class="calibre9">func</code> keyword and the function’s name, you use the <code class="calibre9">subscript</code> keyword. Subscripts may have variadic parameters and can throw errors but can’t use <code class="calibre9">inout</code> or default parameters. You’ll learn more about errors in Chapter 22, “Error Handling”.
</p></li>

<li class="calibre4">
<p class="calibre1">The subscript’s body looks like a computed property: it has a getter and a setter. The setter is optional so that the subscript can be either read-write or read-only. You can omit the setter’s <code class="calibre9">newValue</code> default parameter; its type is the same as the subscript’s return type. Only declare it if you want to change its name to something else.
</p></li>
</ul>

<p class="calibre1">Enough theory! Add a subscript to a <code class="calibre9">Person</code> class defined as follows:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> age: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">age</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age
  }
}</pre>
<p class="calibre1">The <code class="calibre9">Person</code> class has two stored properties: <code class="calibre9">name</code> of type <code class="calibre9">String</code> and <code class="calibre9">age</code> of type <code class="calibre9">Int</code>, along with a designated initializer to kick things off.
</p>
<p class="calibre1">Now suppose I want to create a version of myself right now, as follows:
</p><pre class="code-block"><span class="hljs-keyword">let</span> me <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(name: <span class="hljs-string">"Cosmin"</span>, age: <span class="hljs-number">36</span>)</pre>
<p class="calibre1">It would be nice to access my characteristics with a subscript like this:
</p><pre class="code-block">me[<span class="hljs-string">"name"</span>]
me[<span class="hljs-string">"age"</span>]
me[<span class="hljs-string">"gender"</span>]</pre>
<p class="calibre1">If you run this, Xcode would output the following error:
</p>
<div class="note">
<p class="calibre10"><code class="calibre9">Type "Person" has no subscripts members</code>
</p></div>

<p class="calibre1">Whenever you use the square brackets operator, you call a subscript under the hood. Your class doesn’t have any subscripts defined by default, so you have to declare them yourself.
</p>
<p class="calibre1">Add the following code to the <code class="calibre9">Person</code> class with an extension like this:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span>? {
    <span class="hljs-keyword">switch</span> key {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>: <span class="hljs-keyword">return</span> name
      <span class="hljs-keyword">case</span> <span class="hljs-string">"age"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">\(age)</span>"</span>
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
    }
  }
}</pre>
<p class="calibre1">The subscript returns an optional string based on the key you provide: you return the key’s corresponding property value or <code class="calibre9">nil</code> if you don’t use a valid key. The switch must be exhaustive, so you need a default case.
</p>
<p class="calibre1">The subscript is read-only, so its entire body is a getter &mdash; you don’t need to explicitly state that with the <code class="calibre9">get</code> keyword.
</p>
<p class="calibre1">The above test code works now:
</p><pre class="code-block">me[<span class="hljs-string">"name"</span>]
me[<span class="hljs-string">"age"</span>]
me[<span class="hljs-string">"gender"</span>]</pre>
<p class="calibre1">And outputs:
</p><pre class="code-block"><span class="hljs-built_in">Cosmin</span>
<span class="hljs-number">36</span>
<span class="hljs-keyword">nil</span></pre>
<h3 class="segment-title2">Subscript parameters</h3>

<p class="calibre1">You don’t have to use names for the subscript’s parameters when calling the subscript, even if you don’t use <i class="calibre2">underscores</i> when declaring them.
</p>
<p class="calibre1">Add <em class="calibre5">external parameter names</em> if you want to be more specific like this:
</p><pre class="code-block"><span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">key</span> <span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span>? {
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">The parameter’s name appears in the subscript call now:
</p><pre class="code-block">me[key: <span class="hljs-string">"name"</span>]
me[key: <span class="hljs-string">"age"</span>]
me[key: <span class="hljs-string">"gender"</span>]</pre>
<p class="calibre1">Use descriptive names for external parameters instead of their local counterparts if you want to add more context to the subscript:
</p><pre class="code-block"><span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">property</span> <span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span>? {
  <span class="hljs-comment">// original code</span>
}

me[property: <span class="hljs-string">"name"</span>]
me[property: <span class="hljs-string">"age"</span>]
me[property: <span class="hljs-string">"gender"</span>]</pre>
<h3 class="segment-title2">Static subscripts</h3>

<p class="calibre1">You can define <em class="calibre5">static subscripts</em> for custom types in Swift:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">File</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
  
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">switch</span> key {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"path"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"custom path"</span>
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"default path"</span>
    }
  }
}

<span class="hljs-comment">// 2</span>
<span class="hljs-built_in">File</span>[<span class="hljs-string">"path"</span>]
<span class="hljs-built_in">File</span>[<span class="hljs-string">"PATH"</span>]</pre>
<p class="calibre1">The code works like this:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Use <code class="calibre9">static</code> to create a static subscript that returns the default or custom path for <code class="calibre9">File</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Call the subscript on <code class="calibre9">File</code> instead of a <code class="calibre9">File</code> instance.
</p></li>
</ol>

<h3 class="segment-title2">Dynamic member lookup</h3>

<p class="calibre1">You use <em class="calibre5">dynamic member lookup</em> to provide arbitrary dot syntax to your type.
</p>
<p class="calibre1">Consider the following:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">@dynamicMemberLookup</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Instrument</span> {
  <span class="hljs-keyword">let</span> brand: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> year: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> details: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>]
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">brand</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">year</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">details</span>: [<span class="hljs-built_in">String</span>: <span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.brand <span class="hljs-operator">=</span> brand
    <span class="hljs-keyword">self</span>.year <span class="hljs-operator">=</span> year
    <span class="hljs-keyword">self</span>.details <span class="hljs-operator">=</span> details
  }
  
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">dynamicMember</span> <span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">switch</span> key {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"info"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">\(brand)</span> made in <span class="hljs-subst">\(year)</span>."</span>
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> details[key] <span class="hljs-operator">??</span> <span class="hljs-string">""</span>
    }
  }
}

<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">let</span> instrument <span class="hljs-operator">=</span> <span class="hljs-built_in">Instrument</span>(brand: <span class="hljs-string">"Roland"</span>, year: <span class="hljs-number">2021</span>, 
                            details: [<span class="hljs-string">"type"</span>: <span class="hljs-string">"acoustic"</span>, 
                                      <span class="hljs-string">"pitch"</span>: <span class="hljs-string">"C"</span>])
instrument.info 
instrument.pitch</pre>
<p class="calibre1">Going through the above code step by step:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Mark <code class="calibre9">Instrument</code> as <code class="calibre9">@dynamicMemberLookup</code> to enable dot syntax for its subscripts.
</p></li>

<li class="calibre4">
<p class="calibre1">Conform <code class="calibre9">Instrument</code> to <code class="calibre9">@dynamicMemberLookup</code> by implementing <code class="calibre9">subscript(dynamicMember:)</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Call the previously implemented subscript using dot syntax. It returns either contents from <code class="calibre9">details</code> or more information about <code class="calibre9">Instrument</code>.
</p></li>
</ol>

<p class="calibre1">Using <code class="calibre9">@dynamicMemberLookup</code> here makes the contents of the <code class="calibre9">details</code> dictionary available as properties, which improves readability.
</p>
<p class="calibre1">However, note that the compiler evaluates dynamic member calls at runtime, so you lose the usual compile-time safety. For example, this compiles without complaint:
</p><pre class="code-block">guitar.dlfksdf  <span class="hljs-comment">// Returns ""</span></pre>
<p class="calibre1">You should use <code class="calibre9">@dynamicMemberLookup</code> judiciously as it can prevent the compiler from checking an entire class of errors that it could previously identify at compile time. You can compose this feature with keypaths that you will learn about in a moment to maintain type safety and prevent the above sort of nonsense.
</p>
<p class="calibre1">This code also works:
</p><pre class="code-block">instrument.brand <span class="hljs-comment">// "Roland"</span>
instrument.year <span class="hljs-comment">// 2021</span></pre>
<p class="calibre1">A derived class inherits dynamic member lookup from its base one:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Guitar</span>: <span class="hljs-number">Instrument</span> {}
<span class="hljs-keyword">let</span> guitar <span class="hljs-operator">=</span> <span class="hljs-built_in">Guitar</span>(brand: <span class="hljs-string">"Fender"</span>, year: <span class="hljs-number">2021</span>, 
                    details: [<span class="hljs-string">"type"</span>: <span class="hljs-string">"electric"</span>, <span class="hljs-string">"pitch"</span>: <span class="hljs-string">"C"</span>])
guitar.info</pre>
<p class="calibre1">You use dot syntax to call the <code class="calibre9">Guitar</code> subscript since <code class="calibre9">Guitar</code> is an <code class="calibre9">Instrument</code> and <code class="calibre9">Instrument</code> implements <code class="calibre9">@dynamicMemberLookup</code>.
</p>
<p class="calibre1">You may use dynamic member lookup for <em class="calibre5">class subscripts</em> in Swift as well. They behave like static subscripts, and you can override them in subclasses:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">@dynamicMemberLookup</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Folder</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }
  
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">class</span> <span class="hljs-number">subscript</span>(<span class="hljs-number">dynamicMember</span> <span class="hljs-number">key</span>: <span class="hljs-number">String</span>) -&gt; <span class="hljs-number">String</span> {
    <span class="hljs-keyword">switch</span> key {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"path"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"custom path"</span>
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"default path"</span>
    }
  }
}

<span class="hljs-comment">// 3</span>
<span class="hljs-built_in">Folder</span>.path
<span class="hljs-built_in">Folder</span>.<span class="hljs-built_in">PATH</span></pre>
<p class="calibre1">Here’s what’s going on over here:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Mark <code class="calibre9">Folder</code> as <code class="calibre9">@dynamicMemberLookup</code> to enable dot syntax for custom subscripts.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <code class="calibre9">class</code> and dynamic member lookup to create a class subscript that returns the default or custom path for <code class="calibre9">Folder</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Call the subscript on <code class="calibre9">Folder</code> with dot syntax.
</p></li>
</ol>

<p class="calibre1">Subscripts are easy to use and implement, and they live somewhere between computed properties and methods. However, take care not to overuse them. Unlike computed properties and methods, subscripts have no name to make their intentions clear. Subscripts are almost exclusively used to access a collection’s elements, so don’t confuse the readers of your code by using them for something unrelated and unintuitive!
</p>
<h2 class="segment-chapter1">Keypaths</h2>

<p class="calibre1"><em class="calibre5">Keypaths</em> enable you to store references to properties. For example, this is how you model the tutorials on our website:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Tutorial</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">Person</span>
  <span class="hljs-keyword">let</span> details: (type: <span class="hljs-built_in">String</span>, category: <span class="hljs-built_in">String</span>)
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">author</span>: <span class="hljs-built_in">Person</span>, 
       <span class="hljs-built_in">details</span>: (type: <span class="hljs-built_in">String</span>, category: <span class="hljs-built_in">String</span>)) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
    <span class="hljs-keyword">self</span>.author <span class="hljs-operator">=</span> author
    <span class="hljs-keyword">self</span>.details <span class="hljs-operator">=</span> details
  }
}

<span class="hljs-keyword">let</span> tutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Object Oriented Programming in Swift"</span>, 
                        author: me, 
                        details: (type: <span class="hljs-string">"Swift"</span>, 
                                  category: <span class="hljs-string">"iOS"</span>))</pre>
<p class="calibre1">Each tutorial has a certain <code class="calibre9">title</code>, <code class="calibre9">author</code>, <code class="calibre9">type</code> and <code class="calibre9">category</code>. Using keypaths, you can get the tutorial’s title like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> title <span class="hljs-operator">=</span> \<span class="hljs-built_in">Tutorial</span>.title
<span class="hljs-keyword">let</span> tutorialTitle <span class="hljs-operator">=</span> tutorial[keyPath: title]</pre>
<p class="calibre1">You first use a <i class="calibre2">backslash</i> to create a keypath for the <code class="calibre9">title</code> property of the <code class="calibre9">Tutorial</code> class and then access its corresponding data with the <code class="calibre9">keyPath(_:)</code> subscript.
</p>
<p class="calibre1">Keypaths can access properties several levels deep:
</p><pre class="code-block"><span class="hljs-keyword">let</span> authorName <span class="hljs-operator">=</span> \<span class="hljs-built_in">Tutorial</span>.author.name
<span class="hljs-keyword">var</span> tutorialAuthor <span class="hljs-operator">=</span> tutorial[keyPath: authorName]</pre>
<p class="calibre1">You can also use keypaths for tuples in Swift:
</p><pre class="code-block"><span class="hljs-keyword">let</span> type <span class="hljs-operator">=</span> \<span class="hljs-built_in">Tutorial</span>.details.type
<span class="hljs-keyword">let</span> tutorialType <span class="hljs-operator">=</span> tutorial[keyPath: type]
<span class="hljs-keyword">let</span> category <span class="hljs-operator">=</span> \<span class="hljs-built_in">Tutorial</span>.details.category
<span class="hljs-keyword">let</span> tutorialCategory <span class="hljs-operator">=</span> tutorial[keyPath: category]</pre>
<p class="calibre1">Here you use keypaths to get <code class="calibre9">type</code> and <code class="calibre9">category</code> from <code class="calibre9">details</code> in <code class="calibre9">tutorial</code>.
</p>
<h3 class="segment-title2">Appending keypaths</h3>

<p class="calibre1">You can make new keypaths by <em class="calibre5">appending</em> to existing ones like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> authorPath <span class="hljs-operator">=</span> \<span class="hljs-built_in">Tutorial</span>.author
<span class="hljs-keyword">let</span> authorNamePath <span class="hljs-operator">=</span> authorPath.appending(path: \.name)
tutorialAuthor <span class="hljs-operator">=</span> tutorial[keyPath: authorNamePath]</pre>
<p class="calibre1">You use the <code class="calibre9">appending(path:)</code> method to add a new keypath to the already defined <code class="calibre9">authorPath</code> and infer the keypath’s base type.
</p>
<h3 class="segment-title2">Setting properties</h3>

<p class="calibre1">Keypaths can change property values. Suppose you set up your very own jukebox to play your favorite song:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Jukebox</span> {
  <span class="hljs-keyword">var</span> song: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.song <span class="hljs-operator">=</span> song
  }
}

<span class="hljs-keyword">let</span> jukebox <span class="hljs-operator">=</span> <span class="hljs-built_in">Jukebox</span>(song: <span class="hljs-string">"Nothing Else Matters"</span>)</pre>
<p class="calibre1">You declare the <code class="calibre9">song</code> property as a variable because your best friend comes to visit and wants to listen to her favorite song instead:
</p><pre class="code-block"><span class="hljs-keyword">let</span> song <span class="hljs-operator">=</span> \<span class="hljs-built_in">Jukebox</span>.song
jukebox[keyPath: song] <span class="hljs-operator">=</span> <span class="hljs-string">"Stairway to Heaven"</span></pre>
<p class="calibre1">You use the <code class="calibre9">song</code> keypath to change the song for your friend, and everyone is happy now!
</p>
<h3 class="segment-title2">Keypath member lookup</h3>

<p class="calibre1">You can use dynamic member lookup for keypaths:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">Point</span> {
  <span class="hljs-keyword">let</span> x, y: <span class="hljs-built_in">Int</span>
}

<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">@dynamicMemberLookup</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">Circle</span> {
  <span class="hljs-keyword">let</span> center: <span class="hljs-built_in">Point</span>
  <span class="hljs-keyword">let</span> radius: <span class="hljs-built_in">Int</span>
  
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">dynamicMember</span> <span class="hljs-built_in">keyPath</span>: <span class="hljs-built_in">KeyPath</span>&lt;<span class="hljs-built_in">Point</span>, <span class="hljs-built_in">Int</span>&gt;) -&gt; <span class="hljs-built_in">Int</span> {
    center[keyPath: keyPath]
  }
}

<span class="hljs-comment">// 4</span>
<span class="hljs-keyword">let</span> center <span class="hljs-operator">=</span> <span class="hljs-built_in">Point</span>(x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-built_in">Circle</span>(center: center, radius: <span class="hljs-number">1</span>)
circle.x
circle.y</pre>
<p class="calibre1">Here’s what this code does:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Declare a type <code class="calibre9">Point</code> with <code class="calibre9">x</code> and <code class="calibre9">y</code> coordinates.
</p></li>

<li class="calibre4">
<p class="calibre1">Annotate <code class="calibre9">Circle</code> with <code class="calibre9">@dynamicMemberLookup</code> to enable dot syntax for its subscripts.
</p></li>

<li class="calibre4">
<p class="calibre1">Create a subscript that uses keypaths to access <code class="calibre9">center</code> properties from <code class="calibre9">Circle</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Call <code class="calibre9">center</code> properties on <code class="calibre9">circle</code> using dynamic member lookup.
</p></li>
</ol>

<p class="calibre1">As you can see, using keypaths is more involved than using properties. With keypaths, accessing a property becomes a two-step process:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">First, you decide which property you need and create a keypath.
</p></li>

<li class="calibre4">
<p class="calibre1">Then, you pass this keypath to an instance using the keypath subscript to access the selected property.
</p></li>
</ol>

<p class="calibre1">By using dynamic member lookup with keypaths, you maintain type safety. In other words, you can access <code class="calibre9">circle.x</code> and <code class="calibre9">circle.y</code>, but <code class="calibre9">circle.z</code> and <code class="calibre9">circle.sdlkfj</code> don’t compile! This type safety makes these two language features a powerful combo.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The SwiftUI framework uses dynamic member lookup with keypaths to automatically wrap your properties inside other types that manage the <code class="calibre9">View</code> state and redrawing updates. You may not even realize your type is being used this way because you can access all of its properties as you normally would.
</p></div>

<h3 class="segment-title2">Keypaths as functions</h3>

<p class="calibre1">You can use keypaths as functions if the function is a closure with only one parameter and the keypath’s returned type matches the returned type of the closure:
</p><pre class="code-block"><span class="hljs-keyword">let</span> anotherTutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Encoding and Decoding in Swift"</span>, 
                               author: me, 
                               details: (type: <span class="hljs-string">"Swift"</span>, 
                                         category: <span class="hljs-string">"iOS"</span>))
<span class="hljs-keyword">let</span> tutorials <span class="hljs-operator">=</span> [tutorial, anotherTutorial]
<span class="hljs-keyword">let</span> titles <span class="hljs-operator">=</span> tutorials.map(\.title)</pre>
<p class="calibre1">Here you use the <code class="calibre9">title</code> keypath to map tutorials to their titles.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your custom operators, subscripts and keypaths knowledge. It’s best to try and solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Make it compile</h3>

<p class="calibre1">Modify the following subscript implementation so that it compiles in a playground:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Array</span> {
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">index</span>: <span class="hljs-built_in">Int</span>) -&gt; (<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>)<span class="hljs-operator">?</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>[index] <span class="hljs-keyword">as?</span> <span class="hljs-built_in">Int</span> <span class="hljs-keyword">else</span> {<span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>}
    <span class="hljs-keyword">switch</span> (value <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>, <span class="hljs-built_in">abs</span>(value) <span class="hljs-operator">%</span> <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">case</span> (<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> (<span class="hljs-string">"positive"</span>, <span class="hljs-string">"even"</span>)
      <span class="hljs-keyword">case</span> (<span class="hljs-keyword">true</span>, <span class="hljs-number">1</span>): <span class="hljs-keyword">return</span> (<span class="hljs-string">"positive"</span>, <span class="hljs-string">"odd"</span>)
      <span class="hljs-keyword">case</span> (<span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> (<span class="hljs-string">"negative"</span>, <span class="hljs-string">"even"</span>)
      <span class="hljs-keyword">case</span> (<span class="hljs-keyword">false</span>, <span class="hljs-number">1</span>): <span class="hljs-keyword">return</span> (<span class="hljs-string">"negative"</span>, <span class="hljs-string">"odd"</span>)
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
    }
  }
}</pre>
<h3 class="segment-title2">Challenge 2: Random access string</h3>

<p class="calibre1">Write a subscript that computes the character at a specific index in a string. Why is this considered harmful?
</p>
<h3 class="segment-title2">Challenge 3: Generic exponentiation</h3>

<p class="calibre1">Implement the exponentiation generic operator for float types so that the following code works:
</p><pre class="code-block"><span class="hljs-keyword">let</span> exponent <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> baseDouble <span class="hljs-operator">=</span> <span class="hljs-number">2.0</span>
<span class="hljs-keyword">var</span> resultDouble <span class="hljs-operator">=</span> baseDouble <span class="hljs-operator">**</span> exponent
<span class="hljs-keyword">let</span> baseFloat: <span class="hljs-built_in">Float</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0</span>
<span class="hljs-keyword">var</span> resultFloat <span class="hljs-operator">=</span> baseFloat <span class="hljs-operator">**</span> exponent
<span class="hljs-keyword">let</span> baseCG: <span class="hljs-built_in">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0</span>
<span class="hljs-keyword">var</span> resultCG <span class="hljs-operator">=</span> baseCG <span class="hljs-operator">**</span> exponent</pre>
<p class="calibre1">Hint: Import the <code class="calibre9">CoreGraphics</code> framework to work with <code class="calibre9">CGFloat</code>.
</p>
<h3 class="segment-title2">Challenge 4: Generic exponentiation assignment</h3>

<p class="calibre1">Implement the exponentiation assignment generic operator for float types so that the following code works:
</p><pre class="code-block">resultDouble <span class="hljs-operator">**=</span> exponent
resultFloat <span class="hljs-operator">**=</span> exponent
resultCG <span class="hljs-operator">**=</span> exponent</pre>
<h2 class="segment-chapter1">Key points</h2>

<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Remember the <em class="calibre5">custom operators</em> mantra when creating brand new operators from scratch: With great power comes great responsibility. Make sure the additional cognitive overhead of a custom operator introduces pays for itself.
</p></li>

<li class="calibre4">
<p class="calibre1">Choose the appropriate type for custom operators: <code class="calibre9">postfix</code>, <code class="calibre9">prefix</code> or <code class="calibre9">infix</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Don’t forget to define any related operators, such as compound assignment operators, for custom operators.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">subscripts</em> to overload the square brackets operator for classes, structures and enumerations.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">keypaths</em> to create dynamic references to properties.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">dynamic member lookup</em> to provide type-safe dot syntax access to internal properties.
</p></li>
</ol>
</div>

<div class="segment-title" id="calibre_link-41">


<h1 class="segment-chapter">Chapter 20: Result Builders</h1>

<p class="calibre1"><em class="calibre5">Result builders</em> first appeared on the scene as a feature of Apple’s SwiftUI, letting you declare your user interface in a compact, easy to read way. It was since expanded as a general language feature that lets you build values by combining a sequence of expressions. Using result builders to define things like HTML documents and database schemas could become commonplace in the future.
</p>
<p class="calibre1">In this chapter, you’ll make a result builder to <em class="calibre5">declaratively</em> define attributed strings in a way that is cleaner and more readable than if you built it <em class="calibre5">imperatively</em> using a long sequence of mutating functions. You’ll also use techniques from Chapter 16, “Protocols”, like extensions and <code class="calibre9">typealias</code>, to give your builder code extra clarity.
</p>
<h2 class="segment-chapter1">Meet NSAttributedString</h2>

<p class="calibre1">To demonstrate how result builders work, you’ll build a small project that uses <code class="calibre9">NSAttributedString</code> to show a fancy greet message. By the end of this chapter, you’ll create a string that looks like this:
</p><div class="image12"><img src="images/000009.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1"><code class="calibre9">NSAttributedString</code> is a special object that holds a string and lets you add attributes, like color and font, to the whole string or only to part of it.
</p>
<p class="calibre1">First, you’ll write some simple “regular” imperative code to generate the greeting. Later, you’ll convert that code to use a result builder.
</p>
<p class="calibre1">Open Xcode, go to <em class="calibre5">File ▸ New ▸ Playground</em><em class="calibre5">…</em>, choose <em class="calibre5">Blank</em> and name it <em class="calibre5">ResultBuilders</em>.
</p>
<p class="calibre1">Enter this function into the playground:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">greet</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">"Hello "</span> <span class="hljs-operator">+</span> name)
  <span class="hljs-keyword">return</span> message
}</pre>
<p class="calibre1">Now, call the function by adding <code class="calibre9">greet(name: "Daenerys")</code> below it. Finally, run the playground and observe the result by clicking the <em class="calibre5">Show Result</em> button to the right:
</p><div class="image3"><img src="images/000022.png" alt="" title="" class="calibre7" /></div>
<h3 class="segment-title2">Adding color with an attribute</h3>

<p class="calibre1">Right now, you aren’t using any of the capabilities of <code class="calibre9">NSAttributedString</code>. You’ll change that by adding some color to the greeting message by using an attribute.
</p>
<p class="calibre1">Replace <code class="calibre9">greet</code> with this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">greet</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-keyword">let</span> attributes <span class="hljs-operator">=</span> [<span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.foregroundColor : <span class="hljs-built_in">UIColor</span>.red]
  <span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">"Hello "</span> <span class="hljs-operator">+</span> name, attributes: attributes)
  <span class="hljs-keyword">return</span> message
}</pre>
<p class="calibre1">Run the playground now. You’ll see the string appear in red.
</p><div class="image12"><img src="images/000036.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Note that you’re using a different initializer that takes a dictionary of attributes as an argument. <code class="calibre9">NSAttributedString</code> supports many types of attributes, which you can examine by pressing <em class="calibre5">Command</em><em class="calibre5">-</em><em class="calibre5">Control</em> and left-clicking on <code class="calibre9">foregroundColor</code>.
</p>
<h3 class="segment-title2">Adding color to a specific string</h3>

<p class="calibre1">What if you wanted to change only the text color of the name of the person you’re greeting and not the word “Hello”? There are two ways to do that: using <code class="calibre9">Range</code> or combining two separate attributed strings. Here, you’ll use the second approach because it’s easier to understand.
</p>
<p class="calibre1">For this, you’ll use an <code class="calibre9">NSMutableAttributedString</code>, which lets you append attributed strings to it. You should already be familiar with the concept of mutable versus immutable objects since you read about them in the <em class="calibre5">Collection Types</em> section.
</p>
<p class="calibre1">Replace the current <code class="calibre9">NSAttributedString</code> initialization &mdash; the second line in your function &mdash; with this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span>()
message.append(<span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">"Hello "</span>))
message.append(<span class="hljs-built_in">NSAttributedString</span>(string: name, attributes: attributes))</pre>
<p class="calibre1">Here, you create a mutable attributed string that contains only the word “Hello” without any attributes. You then append another string with the <code class="calibre9">name</code> argument that was passed in and the attribute of the red color.
</p>
<p class="calibre1">Observe the results:
</p><div class="image12"><img src="images/000050.png" alt="" title="" class="calibre7" /></div>
<h3 class="segment-title2">Adding another attributed string</h3>

<p class="calibre1">If you want to add another string to the mix &mdash; for example, one with a different font size &mdash; you need yet another attributed string. Add the following code before the <code class="calibre9">return</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">let</span> attributes2 <span class="hljs-operator">=</span> [
  <span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.font : <span class="hljs-built_in">UIFont</span>.systemFont(ofSize: <span class="hljs-number">20</span>),
  <span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.foregroundColor : <span class="hljs-built_in">UIColor</span>.blue
]
message.append(<span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">", Mother of Dragons"</span>, attributes: attributes2))</pre>
<p class="calibre1">You’ll get a result with two different colors and a bigger font size for the last part of the string:
</p><div class="image12"><img src="images/000061.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can see how this kind of string building can get real messy, real quick. For cases like this, result builders make constructing the attributed string simpler and easier to read.
</p>
<p class="calibre1">Result builders enable you to write cleaner code that looks like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">greet</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">NSAttributedString</span>(string: name, attributes: <span class="hljs-operator">...</span>)
  <span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">", Mother of Dragons"</span>, attributes: <span class="hljs-operator">...</span>)
}</pre>
<p class="calibre1">This code doesn’t have a <code class="calibre9">return</code> statement and doesn’t need to append strings. A result builder gathers the expressions and combines them into a single attributed string. You’ll next see how to implement this.
</p>
<h2 class="segment-chapter1">Creating a result builder</h2>

<p class="calibre1">Start by creating a new <code class="calibre9">enum</code> called <code class="calibre9">AttributedStringBuilder</code>. To make it an actual result builder, you need to use the <code class="calibre9">@resultBuilder</code> annotation, which goes <i class="calibre2">above</i> the <code class="calibre9">enum</code> definition.
</p>
<p class="calibre1">Add this at the bottom of your playground:
</p><pre class="code-block"><span class="hljs-keyword">@resultBuilder</span>
<span class="hljs-keyword">enum</span> <span class="hljs-number">AttributedStringBuilder</span> {
}</pre>
<p class="calibre1">As soon as you add this piece of code, you’re greeted with an error message:
</p><div class="image3"><img src="images/000071.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Add the missing required method inside the <code class="calibre9">enum</code> definition:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildBlock</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">components</span>: <span class="hljs-built_in">NSAttributedString</span>...) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
}</pre>
<p class="calibre1"><code class="calibre9">buildBlock(_:)</code> is the main entry point; it performs the magic of combining the components. As you can see, it can take multiple components of type <code class="calibre9">NSAttributedString</code> and combine them into a single <code class="calibre9">NSAttributedString</code>.
</p>
<p class="calibre1">Two things to note here:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The method uses a variadic parameter (<code class="calibre9">NSAttributedString...</code>), which means the result builder can support any number of components.
</p></li>

<li class="calibre4">
<p class="calibre1">For now, the variadic parameter and the return value must be of the same type. There’s a way to work around this; you’ll read about it later.
</p></li>
</ol>

<p class="calibre1">Now, to implement the builder. Insert this code in the <code class="calibre9">buildBlock(_:)</code> method body:
</p><pre class="code-block"><span class="hljs-keyword">let</span> attributedString <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span>()
<span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> components {
  attributedString.append(component)
}
<span class="hljs-keyword">return</span> attributedString</pre>
<p class="calibre1">Here, you go over each component in the <code class="calibre9">components</code> parameter and append each one to an attributed string. Eventually, you return the result of appending all the strings.
</p>
<p class="calibre1">Simple, right? These few lines are enough to create the result builder and get you where you want to go.
</p>
<h3 class="segment-title2">Building the greeting string with the result builder</h3>

<p class="calibre1">Now, you’ll use the result builder to construct the same greeting string you created earlier by creating a new method.
</p>
<p class="calibre1">Add this to the bottom of your playground:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
}</pre>
<p class="calibre1">The new annotation, <code class="calibre9">@AttributedStringBuilder</code>, exists thanks to the result builder you defined earlier. You can use this annotation on methods, getters and closures.
</p>
<p class="calibre1">To examine how result builders work, you’ll add a few <code class="calibre9">NSMutableAttributedString</code>s, then call <code class="calibre9">greetBuilder</code>, like so:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: <span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: name)
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: <span class="hljs-string">", Mother of Dragons"</span>)
}

greetBuilder(name: <span class="hljs-string">"Daenerys"</span>)</pre>
<p class="calibre1">Here, you use <code class="calibre9">NSMutableAttributedString</code> because you want to have the ability to change the attributes later on.
</p>
<p class="calibre1">The method will return the string: “Hello Daenerys, Mother of Dragons”. Here, you send the <code class="calibre9">NSMutableAttributedString</code>s to <code class="calibre9">buildBlock(_:)</code>, which you implemented earlier. They’re appended to a single attributed string, then are eventually returned by the result builder.
</p>
<h3 class="segment-title2">Improving readability by using extensions and type aliases</h3>

<p class="calibre1">Earlier in the chapter, you applied attributes like color and font size by creating a dictionary of attributes and then using that dictionary in the attributed string initializer. Now, you’ll use a fancier approach that makes the code much more readable.
</p>
<p class="calibre1">Add the following code to the bottom of your playground:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">NSMutableAttributedString</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-number">color</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">color</span> : <span class="hljs-built_in">UIColor</span>) -&gt; <span class="hljs-built_in">NSMutableAttributedString</span> {
    <span class="hljs-keyword">self</span>.addAttribute(<span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.foregroundColor,
                      value: color,
                      range: <span class="hljs-built_in">NSRange</span>(location: <span class="hljs-number">0</span>, length: <span class="hljs-keyword">self</span>.length))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-number">font</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">font</span> : <span class="hljs-built_in">UIFont</span>) -&gt; <span class="hljs-built_in">NSMutableAttributedString</span> {
    <span class="hljs-keyword">self</span>.addAttribute(<span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.font,
                      value: font,
                      range: <span class="hljs-built_in">NSRange</span>(location: <span class="hljs-number">0</span>, length: <span class="hljs-keyword">self</span>.length))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>
  }
}</pre>
<p class="calibre1">This code uses an extension to add two new methods to the API of <code class="calibre9">NSMutableAttributedString</code>. These methods apply a new attribute to the string, then return it.
</p>
<p class="calibre1">Now, you could write something like this (don’t actually add this to the playground):
</p><pre class="code-block"><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span>(string: <span class="hljs-string">"Daenerys"</span>).color(.blue)</pre>
<p class="calibre1">Nice, isn’t it? This technique isn’t directly related to result builders, but it serves the same purpose by making the code cleaner and easier to read.
</p>
<h3 class="segment-title2">Adding fonts and color</h3>

<p class="calibre1">Now, go back to <code class="calibre9">greetBuilder</code>, which you created earlier, and use some fonts and color!  Replace it with this:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: <span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: name)
    .color(.red)
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: <span class="hljs-string">", "</span>)
  <span class="hljs-built_in">NSMutableAttributedString</span>(string: title)
    .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
    .color(.blue)
}</pre>
<p class="calibre1">In addition to the fonts and color, the method accepts the title as an argument.
</p>
<p class="calibre1">Go ahead and update your call <code class="calibre9">greetBuilder</code> to take the new argument:
</p><pre class="code-block">greetBuilder(name: <span class="hljs-string">"Daenerys"</span>, title: <span class="hljs-string">"Mother of Dragons"</span>)</pre>
<p class="calibre1">With this change, you can specify the title of your choice at the call site.
</p>
<h3 class="segment-title2">Using typealias</h3>

<p class="calibre1">While the result builder code is pretty straightforward, there are too many <code class="calibre9">NSMutableAttributedString</code> floating around. Fortunately, you can use <code class="calibre9">typealias</code> to make this code even shorter and more specific to your needs.
</p>
<p class="calibre1">Add this line to your playground:
</p><pre class="code-block"><span class="hljs-keyword">typealias</span> <span class="hljs-built_in">Text</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span></pre>
<p class="calibre1">Here, you just tell the compiler to treat <code class="calibre9">Text</code> as an alias of <code class="calibre9">NSMutableAttributedString</code>. You can now replace all occurrences of <code class="calibre9">NSMutableAttributedString</code> with <code class="calibre9">Text</code>:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">Text</span>(string: <span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">Text</span>(string: name)
    .color(.red)
  <span class="hljs-built_in">Text</span>(string: <span class="hljs-string">", "</span>)
  <span class="hljs-built_in">Text</span>(string: title)
    .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
    .color(.blue)
}</pre>
<p class="calibre1">Finally, you can remove the need to specify the argument label <code class="calibre9">string</code> every time. It’s already pretty clear that you’re passing in strings, so it feels redundant.
</p>
<p class="calibre1">To do this, you’ll add another initializer that omits the argument label to <code class="calibre9">NSMutableAttributedString</code>. Add this to the extension:
</p><pre class="code-block"><span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">string</span>: <span class="hljs-built_in">String</span>) {
  <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(string: string)
}</pre>
<p class="calibre1">This new initializer simply calls the old one with the <code class="calibre9">string</code> you pass in. Now, replace all occurrences of <code class="calibre9">Text(string:)</code> with <code class="calibre9">Text()</code>:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">Text</span>(name)
    .color(.red)
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">", "</span>)
  <span class="hljs-built_in">Text</span>(title)
    .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
    .color(.blue)
}</pre>
<p class="calibre1">Compare this to how the code looked previously, before you implemented the result builder:
</p><pre class="code-block"><span class="hljs-comment">// For comparison purposes only.</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greet</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-keyword">let</span> attributes <span class="hljs-operator">=</span> [<span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.foregroundColor : <span class="hljs-built_in">UIColor</span>.red]
  <span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span>()
  message.append(<span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">"Hello "</span>))
  message.append(<span class="hljs-built_in">NSAttributedString</span>(string: name, attributes: attributes))

  <span class="hljs-keyword">let</span> attributes2 <span class="hljs-operator">=</span> [
    <span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.font : <span class="hljs-built_in">UIFont</span>.systemFont(ofSize: <span class="hljs-number">20</span>),
    <span class="hljs-built_in">NSAttributedString</span>.<span class="hljs-built_in">Key</span>.foregroundColor : <span class="hljs-built_in">UIColor</span>.blue
  ]
  message.append(<span class="hljs-built_in">NSAttributedString</span>(string: <span class="hljs-string">", Mother of Dragons"</span>, attributes: attributes2))
  <span class="hljs-keyword">return</span> message
}</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Don’t add this last block of code! It is just for comparison.
</p></div>

<p class="calibre1"><code class="calibre9">greetBuilder</code> looks so much better! While the new code isn’t much shorter, it’s much easier to understand. It’s also easier to see what you’re building and which attributes you’ve applied to each string.
</p>
<h3 class="segment-title2">Using conditional logic</h3>

<p class="calibre1">If you pass in an empty title, you’ll get a weird result that looks like this:
</p><pre class="code-block">greetBuilder(name: <span class="hljs-string">"Daenerys"</span>, title: <span class="hljs-string">""</span>)
<span class="hljs-comment">// Hello Daenerys, </span></pre>
<p class="calibre1">See that extra comma at the end? That doesn’t look right. You need to check whether the title is empty, and if it is, don’t add the comma. That should be simple to do by adding an <code class="calibre9">if</code> statement.
</p>
<p class="calibre1">Wrap the last two <code class="calibre9">Text</code> elements in an <code class="calibre9">if</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>title.isEmpty {
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">", "</span>)
  <span class="hljs-built_in">Text</span>(title)
    .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
    .color(.blue)
}</pre>
<p class="calibre1">Oops! Once you add this code, you get an error: <code class="calibre9">Closure containing control flow statement cannot be used with result builder 'AttributedStringBuilder'</code>. What’s going on?
</p>
<p class="calibre1">For a result builder to support conditional logic, you need to add a new method to its definition. Add this to <code class="calibre9">enum AttributedStringBuilder</code>:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildOptional</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">component</span>: <span class="hljs-built_in">NSAttributedString</span>?) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  component <span class="hljs-operator">??</span> <span class="hljs-built_in">NSAttributedString</span>()
}</pre>
<p class="calibre1">Under the hood, this method uses <code class="calibre9">buildBlock(_:)</code> to combine all the components in the <code class="calibre9">if</code> statement’s body. It then returns it if the condition is met. If the condition isn’t met, it returns an empty <code class="calibre9">NSAttributedString</code>. The code now compiles just fine. Give the new logic a try by passing an empty string to the <code class="calibre9">title</code> parameter of <code class="calibre9">greetBuilder</code>. Once you’ve checked the result, set the <code class="calibre9">title</code> back to “Mother of Dragons”.
</p>
<h3 class="segment-title2">Using complex conditional logic</h3>

<p class="calibre1">Next, you’ll add one final touch: If the title is empty, you’ll make the greet building method append “No title” to the final result. Start by adding an <code class="calibre9">else</code> clause to the existing <code class="calibre9">if</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>title.isEmpty {
  <span class="hljs-operator">...</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">", No title"</span>)
}</pre>
<p class="calibre1">Ugh, another error! Wait, it’s the same error that you just fixed by implementing <code class="calibre9">buildOptional</code>. The problem is that <code class="calibre9">buildOptional</code> only works for plain <code class="calibre9">if</code> statements that don’t have an <code class="calibre9">else</code> clause. This limitation is also true for <code class="calibre9">switch</code> statements. You’ll need to implement two new methods for these cases: <code class="calibre9">buildEither(first:)</code> and <code class="calibre9">buildEither(second:)</code>.
</p>
<p class="calibre1">You add two methods for the <code class="calibre9">if-else</code> case because you might want to distinguish the cases where the <code class="calibre9">if</code> condition was met from cases where it wasn’t.
</p>
<p class="calibre1">Add these two methods to <code class="calibre9">AttributedStringBuilder</code>:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildEither</span>(<span class="hljs-built_in">first</span> <span class="hljs-built_in">component</span>: <span class="hljs-built_in">NSAttributedString</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  component
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildEither</span>(<span class="hljs-built_in">second</span> <span class="hljs-built_in">component</span>: <span class="hljs-built_in">NSAttributedString</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  component
}</pre>
<p class="calibre1">Similar to <code class="calibre9">buildOptional(_:)</code>, these methods use <code class="calibre9">buildBlock(_:)</code> to process the expressions, then send the results as the <code class="calibre9">component</code> parameter. You can decide what to do with this value. In this implementation, all you do is return the result both for the <code class="calibre9">if</code> and the <code class="calibre9">else</code> clause.
</p>
<p class="calibre1">Now, the error will go away. Call <code class="calibre9">greetBuilder</code>, like this:
</p><pre class="code-block">greetBuilder(name: <span class="hljs-string">"Daenerys"</span>, title: <span class="hljs-string">""</span>)</pre>
<p class="calibre1">This call now returns “Hello Daenerys, No title”.
</p>
<h3 class="segment-title2">Using loops with result builders</h3>

<p class="calibre1">If you’re familiar with Daenerys from the television show “Game of Thrones”, you know she has many titles: Mother of Dragons, Khaleesi, First of Her Name, Breaker of Chains and more. She insists on having all her titles next to her name, so you need support for multiple titles.
</p>
<p class="calibre1">To support this, update the declaration of <code class="calibre9">greetBuilder</code> to the following:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">titles</span>: [<span class="hljs-built_in">String</span>]) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">Text</span>(name)
    .color(.red)
  <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>titles.isEmpty {
    <span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> titles {
      <span class="hljs-built_in">Text</span>(<span class="hljs-string">", "</span>)
      <span class="hljs-built_in">Text</span>(title)
        .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
        .color(.blue)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">Text</span>(<span class="hljs-string">", No title"</span>)
  }
}</pre>
<p class="calibre1">Now, add all of Daenerys’ titles:
</p><pre class="code-block"><span class="hljs-keyword">let</span> titles <span class="hljs-operator">=</span> [<span class="hljs-string">"Khaleesi"</span>,
              <span class="hljs-string">"Mhysa"</span>,
              <span class="hljs-string">"First of Her Name"</span>,
              <span class="hljs-string">"Silver Lady"</span>,
              <span class="hljs-string">"The Mother of Dragons"</span>]
greetBuilder(name: <span class="hljs-string">"Daenerys"</span>, titles: titles)</pre>
<p class="calibre1">In this new <code class="calibre9">greetBuilder</code>, you iterate over each title and create an attributed string out of it. The result builder <i class="calibre2">should</i> append these to the final result. However, the compiler can’t infer that it needs to do this. You’ll see the familiar error: <code class="calibre9">Closure containing control flow statement cannot be used with result builder 'AttributedStringBuilder'</code>.
</p>
<p class="calibre1">You already know that the builder throws this error when it’s missing something. In this case, it’s missing a clear definition of how to handle <code class="calibre9">for-in</code> loops. To handle this, you’ll need to implement <code class="calibre9">buildArray(_:)</code>.
</p>
<p class="calibre1">Add the following to your result builder:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">components</span>: [<span class="hljs-built_in">NSAttributedString</span>]) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-keyword">let</span> attributedString <span class="hljs-operator">=</span> <span class="hljs-built_in">NSMutableAttributedString</span>()
  <span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> components {
    attributedString.append(component)
  }
  <span class="hljs-keyword">return</span> attributedString
}</pre>
<p class="calibre1">This piece of code might seem familiar to you because it’s identical to how you implemented <code class="calibre9">buildBlock(_:)</code>.
</p>
<p class="calibre1">Now that you’ve resolved the error, you’ll see the following result:
</p><div class="image10"><img src="images/000083.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You might need to enlarge the resulting pop-up to view the entire string.
</p>
<h3 class="segment-title2">Supporting multiple data types</h3>

<p class="calibre1">The greeting string is getting long, so you’d like to be able to break each title to a new line. This feature should be simple. Add <code class="calibre9">Text("\n")</code> line right after <code class="calibre9">Text(", ")</code> so the function looks like this:
</p><pre class="code-block"><span class="hljs-number">@AttributedStringBuilder</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">greetBuilder</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">titles</span>: [<span class="hljs-built_in">String</span>]) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-built_in">Text</span>(<span class="hljs-string">"Hello "</span>)
  <span class="hljs-built_in">Text</span>(name)
    .color(.red)
  <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>titles.isEmpty {
    <span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> titles {
      <span class="hljs-built_in">Text</span>(<span class="hljs-string">", "</span>)
      <span class="hljs-built_in">Text</span>(<span class="hljs-string">"<span class="hljs-subst">\n</span>"</span>)
      <span class="hljs-built_in">Text</span>(title)
        .font(.systemFont(ofSize: <span class="hljs-number">20</span>))
        .color(.blue)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">Text</span>(<span class="hljs-string">", No title"</span>)
  }
}</pre>
<p class="calibre1"><code class="calibre9">\n</code> is a special combination of characters that results in a new line in a string. Rerun the playground and observe the result.
</p><div class="image12"><img src="images/000095.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Now, your code has a few <code class="calibre9">Text</code> elements that only have a comma or a line break. Wouldn’t it be nice to replace these with a value that clearly denotes what these strings are?
</p>
<p class="calibre1">Add a new <code class="calibre9">enum</code> for the special characters:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">SpecialCharacters</span> {
  <span class="hljs-keyword">case</span> lineBreak
  <span class="hljs-keyword">case</span> comma
}</pre>
<p class="calibre1">Next, you’ll use the new <code class="calibre9">enum</code> inside <code class="calibre9">greetBuilder</code>.
</p>
<p class="calibre1">Replace <code class="calibre9">Text(", ")</code> with <code class="calibre9">SpecialCharacters.comma</code> and <code class="calibre9">Text("\n")</code> with <code class="calibre9">SpecialCharacters.lineBreak</code>. You’ll immediately get an error that says: <code class="calibre9">Cannot convert value of type 'SpecialCharacters' to expected argument type 'NSAttributedString'</code>. This error makes sense, because the builder expects only <code class="calibre9">NSAttributedString</code>s.
</p>
<p class="calibre1">Fortunately, there’s a solution for that. Result builders let you define how to handle expressions that aren’t of the same type as the result builder return type. You’ll do this by implementing <code class="calibre9">buildExpression(_:)</code>, which takes the type you want to support as an argument and returns the result builder type.
</p>
<p class="calibre1">Add this to the result builder definition:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildExpression</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">expression</span>: <span class="hljs-built_in">SpecialCharacters</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  <span class="hljs-keyword">switch</span> expression {
  <span class="hljs-keyword">case</span> .lineBreak:
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Text</span>(<span class="hljs-string">"<span class="hljs-subst">\n</span>"</span>)
  <span class="hljs-keyword">case</span> .comma:
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Text</span>(<span class="hljs-string">","</span>)
  }
}</pre>
<p class="calibre1">Whenever the result builder sees an expression of type <code class="calibre9">SpecialCharacters</code>, it will use the method above to process it before sending it to <code class="calibre9">buildBlock(_:)</code>. The contents of this method are pretty straightforward: If the expression is <code class="calibre9">SpecialCharacters.lineBreak</code>, it will return a <code class="calibre9">Text</code> with the special line break combination of characters. If the expression is <code class="calibre9">SpecialCharacters.comma</code>, it will return a <code class="calibre9">Text</code> with a comma.
</p>
<p class="calibre1">One important thing to know about <code class="calibre9">buildExpression(_:)</code> is that once it’s implemented, all expressions will be sent to it for processing before being passed to <code class="calibre9">buildBlock(_:)</code>. That’s also true for expressions of type <code class="calibre9">NSMutableAttributedString</code>. That’s why you now see the error <code class="calibre9">Cannot convert the value of type 'NSMutableAttributedString' to expected argument type 'SpecialCharacters'</code>.
</p>
<p class="calibre1">To fix this, you need to add another <code class="calibre9">buildExpression(_:)</code>, this time for expressions of type <code class="calibre9">NSAttributedString</code>:
</p><pre class="code-block"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">buildExpression</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">expression</span>: <span class="hljs-built_in">NSAttributedString</span>) -&gt; <span class="hljs-built_in">NSAttributedString</span> {
  expression
}</pre>
<p class="calibre1">And now, all the errors go away. You can use <code class="calibre9">buildExpression(_:)</code> to add support for more types if you’d like. However, all of them have to eventually return an <code class="calibre9">NSAttributedString</code> because that’s the return value of the result builder.
</p>
<h2 class="segment-chapter1">Key points</h2>

<p class="calibre1">Result builders have use beyond Apple’s SwiftUI. Before tackling the vital topic of pattern matching in Chapter 21, “Pattern Matching”, here are the key points to remember.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Result builders</em> let you define your own domain-specific language for declaring and configuring values of a specific type.
</p></li>

<li class="calibre4">
<p class="calibre1">You can use result builders on <em class="calibre5">functions</em>, <em class="calibre5">getters</em> and <em class="calibre5">closures</em>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">buildBlock(</em><em class="calibre5">_</em><em class="calibre5">:)</em> goes over all expressions in the result builder code and decides what to do with them. Eventually, it returns one expression of the result builder’s type.
</p></li>

<li class="calibre4">
<p class="calibre1">You must use <em class="calibre5">buildOptional(</em><em class="calibre5">_</em><em class="calibre5">:)</em> to support <code class="calibre9">if</code> statements.
</p></li>

<li class="calibre4">
<p class="calibre1">You must implement <em class="calibre5">buildEither(first:)</em> and <em class="calibre5">buildEither(second:)</em> to support <code class="calibre9">if-else</code> and <code class="calibre9">switch</code> statements.
</p></li>

<li class="calibre4">
<p class="calibre1">To support <code class="calibre9">for-in</code> loops, you need <em class="calibre5">buildArray(</em><em class="calibre5">_</em><em class="calibre5">:)</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">If you want to support expressions other than the result builder return type, you need to implement <em class="calibre5">buildExpression(</em><em class="calibre5">_</em><em class="calibre5">:)</em>.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-34">


<h1 class="segment-chapter">Chapter 21: Pattern Matching</h1>

<p class="calibre1">In this chapter, you’ll learn about proper golf attire: How to pair a striped shirt with plaid shorts:
</p><div class="image11"><img src="images/000116.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">No, just playing! This is <i class="calibre2">not</i> your grandfather’s pattern matching.
</p>
<p class="calibre1">You’ve already seen pattern matching in action. In Chapter 4, “Advanced Control Flow”, you used a <code class="calibre9">switch</code> statement to match numbers and strings in different cases. That’s a simple example, but there’s a lot more to explore on the topic.
</p>
<p class="calibre1">You’re going to dive deep into the underlying mechanisms and understand more about how the Swift compiler interprets the code you type.
</p>
<p class="calibre1">Swift is a multi-paradigm language that lets you build full-featured, production-ready, object-oriented software. The designers of Swift borrowed some tricks from more functional style languages like Haskell and Erlang.
</p>
<p class="calibre1">Pattern matching is a staple of those functional languages, and it saves you from having to type much longer and less readable statements to evaluate conditions.
</p>
<p class="calibre1">Suppose you have a coordinate with <i class="calibre2">x</i><i class="calibre2">-</i>, <i class="calibre2">y</i><i class="calibre2">-</i>, and <i class="calibre2">z</i><i class="calibre2">-</i> axis values:
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinate <span class="hljs-operator">=</span> (x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span>)</pre>
<p class="calibre1">Both of these code snippets will achieve the same result:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">if</span> (coordinate.y <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) <span class="hljs-operator">&amp;&amp;</span> (coordinate.z <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"along the x-axis"</span>)
}

<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> coordinate {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"along the x-axis"</span>)
}</pre>
<p class="calibre1">The first option digs into the internals of a tuple and has a lengthy equatable comparison. It also uses the logical <code class="calibre9">&amp;&amp;</code> operator to ensure both conditions are <code class="calibre9">true</code>.
</p>
<p class="calibre1">The second option, using pattern matching, is concise and readable.
</p>
<p class="calibre1">The following sections will show you how &mdash; and when &mdash; to use patterns in your code.
</p>
<h2 class="segment-chapter1">Introducing patterns</h2>

<p class="calibre1">Patterns provide rules to match values. You can use patterns in <code class="calibre9">switch</code> cases, as well as in <code class="calibre9">if</code>, <code class="calibre9">while</code>, <code class="calibre9">guard</code>, and <code class="calibre9">for</code> statements. You can also use patterns in variable and constant declarations.
</p>
<p class="calibre1">Believe it or not, you’ve already seen another powerful example of patterns with that <code class="calibre9">coordinate</code> tuple declaration. You construct a tuple by separating values with commas between parentheses, like <code class="calibre9">(x, y, z)</code>.  The compiler will understand that pattern refers to a tuple of 3 values: <i class="calibre2">x</i>, <i class="calibre2">y</i> and <i class="calibre2">z</i>. Tuples have the structure of a composite value.
</p>
<p class="calibre1">Single values also have a structure. The number <code class="calibre9">42</code> is a single value and, by its very nature, identifiable.
</p>
<p class="calibre1">A pattern defines the structure of a value, and pattern matching lets you check values against each other.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The structure of a value doesn’t refer to the <code class="calibre9">struct</code> type. They are different concepts, even though they use the same word. It could be a symptom of the paucity of language!
</p></div>

<h2 class="segment-chapter1">Basic pattern matching</h2>

<p class="calibre1">In this section, you’ll see some common uses for pattern matching.
</p>
<h3 class="segment-title2">If and guard</h3>

<p class="calibre1">Throughout the book so far, you’ve used plain old <code class="calibre9">if</code> and <code class="calibre9">guard</code> statements. You can transform them into pattern matching statements by using a <code class="calibre9">case</code> condition. The example below shows how you use an <code class="calibre9">if</code> statement with a <code class="calibre9">case</code> condition:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">process</span>(<span class="hljs-built_in">point</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>, z: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> point {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"At origin"</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Not at origin"</span>
}

<span class="hljs-keyword">let</span> point <span class="hljs-operator">=</span> (x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span>)
<span class="hljs-keyword">let</span> status <span class="hljs-operator">=</span> process(point: point) <span class="hljs-comment">// At origin</span></pre>
<p class="calibre1">In that code, all three axes match to zero values.
</p>
<p class="calibre1">A <code class="calibre9">case</code> condition in a <code class="calibre9">guard</code> statement achieves the same effect:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">process</span>(<span class="hljs-built_in">point</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>, z: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> point <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not at origin"</span>
  }
  <span class="hljs-comment">// guaranteed point is at the origin</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">"At origin"</span>
}</pre>
<p class="calibre1">In a <code class="calibre9">case</code> condition, you write the pattern first followed by an equals sign, <code class="calibre9">=</code>, and then the value you want to match to the pattern. <code class="calibre9">if</code> statements and <code class="calibre9">guard</code> statements work best if there is a single pattern you care to match.
</p>
<h3 class="segment-title2">Switch</h3>

<p class="calibre1">If you care to match multiple patterns, the <code class="calibre9">switch</code> statement is your best friend.
</p>
<p class="calibre1">You can rewrite <code class="calibre9">processPoint()</code> like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">process</span>(<span class="hljs-built_in">point</span>: (x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>, z: <span class="hljs-built_in">Int</span>)) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">let</span> closeRange <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">...</span><span class="hljs-number">2</span>
  <span class="hljs-keyword">let</span> midRange <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">5</span><span class="hljs-operator">...</span><span class="hljs-number">5</span>
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">switch</span> point {
  <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">"At origin"</span>
  <span class="hljs-keyword">case</span> (closeRange, closeRange, closeRange):
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Very close to origin"</span>
  <span class="hljs-keyword">case</span> (midRange, midRange, midRange):
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Nearby origin"</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not near origin"</span>
  }
}

<span class="hljs-keyword">let</span> point <span class="hljs-operator">=</span> (x: <span class="hljs-number">15</span>, y: <span class="hljs-number">5</span>, z: <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> status <span class="hljs-operator">=</span> process(point: point) <span class="hljs-comment">// Not near origin</span></pre>
<p class="calibre1">This code introduces a couple of new concepts:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">You can match against ranges of numbers.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">switch</code> statement allows for multiple cases to match patterns.
</p></li>
</ol>

<p class="calibre1">Because of its exhaustiveness checking, the <code class="calibre9">switch</code> statement also provides an advantage over the <code class="calibre9">if</code> statement. The compiler guarantees that you have checked for all possible values by the end of a switch statement.
</p>
<p class="calibre1">Also, recall that a <code class="calibre9">switch</code> statement will exit with the first <code class="calibre9">case</code> condition that matches. That’s why you place the <code class="calibre9">midRange</code> condition second. Even though the <code class="calibre9">midRange</code> condition would match a <code class="calibre9">closeRange</code> value, it won’t evaluate unless the previous condition fails. The <code class="calibre9">default</code> case is the catch-all. The’ default’ case will execute if there hasn’t been a match in all the other cases.
</p>
<h3 class="segment-title2">Mini exercise</h3>

<p class="calibre1">Given the population of a group, write a <code class="calibre9">switch</code> statement that prints out a comment for different group sizes: single, a few, several and many.
</p>
<h3 class="segment-title2">for</h3>

<p class="calibre1">A <code class="calibre9">for</code> loop churns through a collection of elements. Pattern matching can act as a filter:
</p><pre class="code-block"><span class="hljs-keyword">let</span> groupSizes <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">for</span> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> groupSizes {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found an individual"</span>) <span class="hljs-comment">// 2 times</span>
}</pre>
<p class="calibre1">In this example, the array provides a list of workgroup sizes for a school classroom. The loop’s body only runs for elements in the array that match the value <code class="calibre9">1</code>. Since students in the class are encouraged to work in teams instead of individually, you can isolate those who have not found a partner.
</p>
<h2 class="segment-chapter1">Patterns</h2>

<p class="calibre1">Now that you’ve seen some basic pattern matching examples, let’s talk about more patterns you can match.
</p>
<h3 class="segment-title2">Wildcard pattern</h3>

<p class="calibre1">Revisit the example you saw at the beginning of this chapter, where you wanted to check if a value was on the <i class="calibre2">x</i>-axis for the <code class="calibre9">(x, y, z)</code> tuple coordinate:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> coordinate {
  <span class="hljs-comment">// x can be any value. y and z must be exactly 0.</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x-axis"</span>) <span class="hljs-comment">// Printed!</span>
}</pre>
<p class="calibre1">The pattern in this <code class="calibre9">case</code> condition uses an underscore, <code class="calibre9">_</code>, to match any value of <i class="calibre2">x</i> component and exactly <code class="calibre9">0</code> for the <i class="calibre2">y</i> and <i class="calibre2">z</i> components.
</p>
<h3 class="segment-title2">Value-binding pattern</h3>

<p class="calibre1">The value-binding pattern sounds more sophisticated than it turns out to be in practice. You simply use <code class="calibre9">var</code> or <code class="calibre9">let</code> to declare a variable or a constant while matching a pattern.
</p>
<p class="calibre1">You can then use the value of the variable or constant inside the execution block:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> (<span class="hljs-keyword">let</span> x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> coordinate {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x-axis at <span class="hljs-subst">\(x)</span>"</span>) <span class="hljs-comment">// Printed: 1</span>
}</pre>
<p class="calibre1">The pattern in this <code class="calibre9">case</code> condition matches any value on the <i class="calibre2">x</i>-axis and binds its <i class="calibre2">x</i> component to the constant named <code class="calibre9">x</code> for use in the execution block.
</p>
<p class="calibre1">If you wanted to bind multiple values, you could write <code class="calibre9">let</code> multiple times or, even better, move the <code class="calibre9">let</code> outside the tuple:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (x, y, <span class="hljs-number">0</span>) <span class="hljs-operator">=</span> coordinate {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"On the x-y plane at (<span class="hljs-subst">\(x)</span>, <span class="hljs-subst">\(y)</span>)"</span>) <span class="hljs-comment">// Printed: 1, 0</span>
}</pre>
<p class="calibre1">The compiler will bind all the unknown constant names it finds by putting the <code class="calibre9">let</code> on the outside of the tuple.
</p>
<h3 class="segment-title2">Identifier pattern</h3>

<p class="calibre1">The identifier pattern is even more straightforward than the value-binding pattern. The identifier pattern is the constant or variable name itself; in the example above, that’s the <code class="calibre9">x</code> in the pattern. You’re telling the compiler, “When you find a value of <code class="calibre9">(something, 0, 0)</code>, assign the <code class="calibre9">something</code> to <code class="calibre9">x</code>.”
</p>
<p class="calibre1">This description feels intertwined with what you’ve seen before because the identifier pattern is a sub-pattern of the value-binding pattern.
</p>
<h3 class="segment-title2">Tuple pattern</h3>

<p class="calibre1">You’ve already been using another bonus pattern &mdash; did you recognize it? The tuple isn’t just a series of comma-separated values between parentheses: it’s comma-separated patterns. In the example tuple pattern, <code class="calibre9">(something, 0, 0)</code>, the interior patterns are (<i class="calibre2">identifier</i>, <i class="calibre2">expression</i>, <i class="calibre2">expression</i>).
</p>
<p class="calibre1">You’ll learn about expression patterns at the end of this chapter. For now, the important takeaway is that the tuple pattern combines many patterns into one and helps you write terse code.
</p>
<h3 class="segment-title2">Enumeration case pattern</h3>

<p class="calibre1">In Chapter 15, “Enumerations”, you saw how you could match the member values of an enumeration:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Direction</span> {
  <span class="hljs-keyword">case</span> north, south, east, west
}

<span class="hljs-keyword">let</span> heading <span class="hljs-operator">=</span> <span class="hljs-built_in">Direction</span>.north

<span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .north <span class="hljs-operator">=</span> heading {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Don’t forget your jacket"</span>) <span class="hljs-comment">// Printed!</span>
}</pre>
<p class="calibre1">As you can imagine, the enumeration case pattern matches the value of an enumeration. In this example, <code class="calibre9">case .north</code> will only match the <code class="calibre9">.north</code> value of the enumeration.
</p>
<p class="calibre1">The enumeration case pattern has some magic up its sleeve. When you combine it with the value binding pattern, you can extract associated values from an enumeration:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Organism</span> {
  <span class="hljs-keyword">case</span> plant
  <span class="hljs-keyword">case</span> animal(legs: <span class="hljs-built_in">Int</span>)
}

<span class="hljs-keyword">let</span> pet <span class="hljs-operator">=</span> <span class="hljs-built_in">Organism</span>.animal(legs: <span class="hljs-number">4</span>)

<span class="hljs-keyword">switch</span> pet {
<span class="hljs-keyword">case</span> .animal(<span class="hljs-keyword">let</span> legs):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Potentially cuddly with <span class="hljs-subst">\(legs)</span> legs"</span>) <span class="hljs-comment">// Printed: 4</span>
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No chance for cuddles"</span>)
}</pre>
<p class="calibre1">In that code, the associated value for <code class="calibre9">.animal</code> is bound to the constant named <code class="calibre9">legs</code>. You reference the <code class="calibre9">legs</code> constant in the <code class="calibre9">print</code> call inside the execution block of that condition.
</p>
<p class="calibre1">Associated values are locked away in enumeration values until you use the value-binding pattern to extract them.
</p>
<h3 class="segment-title2">Mini exercise</h3>

<p class="calibre1">In Chapter 15, “Enumerations”, you learned that an optional is an enumeration under the hood. An optional is either <code class="calibre9">.some(value)</code> or <code class="calibre9">.none</code>. You just learned how to extract associated values from optionals.
</p>
<p class="calibre1">Given the following array of optionals, print the names that are not <code class="calibre9">nil</code> with a <code class="calibre9">for</code> loop:
</p><pre class="code-block"><span class="hljs-keyword">let</span> names: [<span class="hljs-built_in">String</span>?] <span class="hljs-operator">=</span>
  [<span class="hljs-string">"Michelle"</span>, <span class="hljs-keyword">nil</span>, <span class="hljs-string">"Brandon"</span>, <span class="hljs-string">"Christine"</span>, <span class="hljs-keyword">nil</span>, <span class="hljs-string">"David"</span>]</pre>
<h3 class="segment-title2">Optional pattern</h3>

<p class="calibre1">Speaking of optionals, there is also an optional pattern. The optional pattern consists of an identifier pattern followed immediately by a question mark. You can use this pattern in the same places you would use enumeration case patterns.
</p>
<p class="calibre1">You can rewrite the solution to the mini exercise as:
</p><pre class="code-block"><span class="hljs-keyword">for</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> name<span class="hljs-operator">?</span> <span class="hljs-keyword">in</span> names {
  <span class="hljs-built_in">print</span>(name) <span class="hljs-comment">// 4 times</span>
}</pre>
<p class="calibre1">Optional patterns are <em class="calibre5">syntactic sugar</em> for enumeration case patterns containing optional values. Syntactic sugar merely means a more pleasant way of writing the same thing.
</p>
<h3 class="segment-title2">“Is” type-casting pattern</h3>

<p class="calibre1">Using the <code class="calibre9">is</code> operator in a case condition, you check if an instance is of a particular type.  An example of when to use this is parsing through a JSON export. If you’re not familiar, JSON is an array full of all different types, which you can write as <code class="calibre9">[Any]</code> in Swift. Web APIs and website developers make use of JSON a lot.
</p>
<p class="calibre1">Therefore, when you’re parsing data from a web API, you’ll need to check if each value is of a particular type:
</p><pre class="code-block"><span class="hljs-keyword">let</span> response: [<span class="hljs-keyword">Any</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">15</span>, <span class="hljs-string">"George"</span>, <span class="hljs-number">2.0</span>]

<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> response {
 <span class="hljs-keyword">switch</span> element {
 <span class="hljs-keyword">case</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">String</span>:
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found a string"</span>) <span class="hljs-comment">// 1 time</span>
 <span class="hljs-keyword">default</span>:
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found something else"</span>) <span class="hljs-comment">// 2 times</span>
 }
}</pre>
<p class="calibre1">With this code, you find out that one of the elements is of type <code class="calibre9">String</code>. But you don’t have access to the value of that <code class="calibre9">String</code> in the implementation. That’s where the next pattern comes to the rescue.
</p>
<h3 class="segment-title2">“As” type-casting pattern</h3>

<p class="calibre1">The <code class="calibre9">as</code> operator combines the <code class="calibre9">is</code> type casting pattern with the value-binding pattern. Extending the example above, you could write a case like this:
</p><pre class="code-block"><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> response {
 <span class="hljs-keyword">switch</span> element {
 <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> text <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>:
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found a string: <span class="hljs-subst">\(text)</span>"</span>) <span class="hljs-comment">// 1 time</span>
 <span class="hljs-keyword">default</span>:
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found something else"</span>) <span class="hljs-comment">// 2 times</span>
 }
}</pre>
<p class="calibre1">So when the compiler finds an object that it can cast to a <code class="calibre9">String</code>, the compiler will bind the value to the <code class="calibre9">text</code> constant.
</p>
<h2 class="segment-chapter1">Advanced patterns</h2>

<p class="calibre1">You’ve blazed through all the above patterns! What you’ve learned so far in this chapter will carry you quite far as a developer. In the upcoming section, you’ll learn some modifier tricks that enable you to consolidate your code even further.
</p>
<h3 class="segment-title2">Qualifying with where</h3>

<p class="calibre1">You can specify a <code class="calibre9">where</code> condition to further filter a match by checking a unary condition in-line. In Chapter 4, “Advanced Control Flow”, you saw an example like this:
</p><pre class="code-block"><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">9</span> {
  <span class="hljs-keyword">switch</span> number {
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> x <span class="hljs-keyword">where</span> x <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"even"</span>) <span class="hljs-comment">// 4 times</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"odd"</span>) <span class="hljs-comment">// 5 times</span>
  }
}</pre>
<p class="calibre1">If the number in the code above is divisible evenly by two, the first case matches.
</p>
<p class="calibre1">You can utilize <code class="calibre9">where</code> in a more sophisticated way with enumerations. Imagine you’re writing a game where you want to save the player’s progress for each level:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">LevelStatus</span> {
  <span class="hljs-keyword">case</span> complete
  <span class="hljs-keyword">case</span> inProgress(percent: <span class="hljs-built_in">Double</span>)
  <span class="hljs-keyword">case</span> notStarted
}

<span class="hljs-keyword">let</span> levels: [<span class="hljs-built_in">LevelStatus</span>] <span class="hljs-operator">=</span>
  [.complete, .inProgress(percent: <span class="hljs-number">0.9</span>), .notStarted]

<span class="hljs-keyword">for</span> level <span class="hljs-keyword">in</span> levels {
  <span class="hljs-keyword">switch</span> level {
  <span class="hljs-keyword">case</span> .inProgress(<span class="hljs-keyword">let</span> percent) <span class="hljs-keyword">where</span> percent <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.8</span> :
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Almost there!"</span>)
  <span class="hljs-keyword">case</span> .inProgress(<span class="hljs-keyword">let</span> percent) <span class="hljs-keyword">where</span> percent <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.5</span> :
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Halfway there!"</span>)
  <span class="hljs-keyword">case</span> .inProgress(<span class="hljs-keyword">let</span> percent) <span class="hljs-keyword">where</span> percent <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.2</span> :
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Made it through the beginning!"</span>)
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>
  }
}</pre>
<p class="calibre1">In this code, one level in the game is currently in progress. That level matches the first case as 90% complete and prints <code class="calibre9">"Almost there!"</code>. The <code class="calibre9">where</code> condition tests the associated value from the enumeration case.
</p>
<h3 class="segment-title2">Chaining with commas</h3>

<p class="calibre1">Another thing you learned in Chapter 4, “Advanced Control Flow”, was how to match multiple patterns in a single-case condition. Here’s an example similar to what you saw previously:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">timeOfDayDescription</span>(<span class="hljs-built_in">hour</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">switch</span> hour {
  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Early morning"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Morning"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Afternoon"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Evening"</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Late evening"</span>
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">"INVALID HOUR!"</span>
  }
}
<span class="hljs-keyword">let</span> timeOfDay <span class="hljs-operator">=</span> timeOfDayDescription(hour: <span class="hljs-number">12</span>) <span class="hljs-comment">// Afternoon</span></pre>
<p class="calibre1">Here you see several identifier patterns matched in each case condition. You can list as many as you like, separated by commas.
</p>
<p class="calibre1">The constants and variables you bind in a pattern are available in subsequent patterns. Here’s a refinement to the cuddly animal test:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .animal(<span class="hljs-keyword">let</span> legs) <span class="hljs-operator">=</span> pet, <span class="hljs-keyword">case</span> <span class="hljs-number">2</span><span class="hljs-operator">...</span><span class="hljs-number">4</span> <span class="hljs-operator">=</span> legs {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"potentially cuddly"</span>) <span class="hljs-comment">// Printed!</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"no chance for cuddles"</span>)
}</pre>
<p class="calibre1">The first pattern, before the comma, binds the associated value of the enumeration to the constant <code class="calibre9">legs</code>. In the second pattern, after the comma, the value of the <code class="calibre9">legs</code> constant is matched against a range.
</p>
<p class="calibre1">Swift’s <code class="calibre9">if</code> statement is surprisingly capable. An <code class="calibre9">if</code> statement can have multiple conditions, separated by commas. Conditions fall into one of three categories:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Simple logical test</em> E.g.: <code class="calibre9">foo == 10 || bar &gt; baz</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Optional binding</em> E.g.: <code class="calibre9">let foo = maybeFoo</code>.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Pattern matching</em> E.g.: <code class="calibre9">case .bar(let value) = something</code>.
</p></li>
</ul>

<p class="calibre1">Conditions evaluate in the order they are defined. At runtime, no conditions following a failing condition evaluate. Here is a contrived example of a complicated <code class="calibre9">if</code> statement:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Number</span> {
  <span class="hljs-keyword">case</span> integerValue(<span class="hljs-built_in">Int</span>)
  <span class="hljs-keyword">case</span> doubleValue(<span class="hljs-built_in">Double</span>)
  <span class="hljs-keyword">case</span> booleanValue(<span class="hljs-built_in">Bool</span>)
}

<span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">6</span>
<span class="hljs-keyword">let</span> c: <span class="hljs-built_in">Number</span>? <span class="hljs-operator">=</span> .integerValue(<span class="hljs-number">7</span>)
<span class="hljs-keyword">let</span> d: <span class="hljs-built_in">Number</span>? <span class="hljs-operator">=</span> .integerValue(<span class="hljs-number">8</span>)

<span class="hljs-keyword">if</span> a <span class="hljs-operator">!=</span> b {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> c <span class="hljs-operator">=</span> c {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> d <span class="hljs-operator">=</span> d {
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .integerValue(<span class="hljs-keyword">let</span> cValue) <span class="hljs-operator">=</span> c {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .integerValue(<span class="hljs-keyword">let</span> dValue) <span class="hljs-operator">=</span> d {
          <span class="hljs-keyword">if</span> dValue <span class="hljs-operator">&gt;</span> cValue {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"a and b are different"</span>) <span class="hljs-comment">// Printed!</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"d is greater than c"</span>) <span class="hljs-comment">// Printed!</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"sum: <span class="hljs-subst">\(a <span class="hljs-operator">+</span> b <span class="hljs-operator">+</span> cValue <span class="hljs-operator">+</span> dValue)</span>"</span>) <span class="hljs-comment">// 26</span>
          }
        }
      }
    }
  }
}</pre>
<p class="calibre1">Nesting all those if statements one inside the other is known a <em class="calibre5">pyramid of doom</em>. Instead, you can use the unwrapped and bound values immediately after consecutive commas:
</p><pre class="code-block"><span class="hljs-keyword">if</span> a <span class="hljs-operator">!=</span> b,
   <span class="hljs-keyword">let</span> c <span class="hljs-operator">=</span> c,
   <span class="hljs-keyword">let</span> d <span class="hljs-operator">=</span> d,
   <span class="hljs-keyword">case</span> .integerValue(<span class="hljs-keyword">let</span> cValue) <span class="hljs-operator">=</span> c,
   <span class="hljs-keyword">case</span> .integerValue(<span class="hljs-keyword">let</span> dValue) <span class="hljs-operator">=</span> d,
   dValue <span class="hljs-operator">&gt;</span> cValue {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"a and b are different"</span>) <span class="hljs-comment">// Printed!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"d is greater than c"</span>) <span class="hljs-comment">// Printed!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"sum: <span class="hljs-subst">\(a <span class="hljs-operator">+</span> b <span class="hljs-operator">+</span> cValue <span class="hljs-operator">+</span> dValue)</span>"</span>) <span class="hljs-comment">// Printed: 26</span>
}</pre>
<p class="calibre1">So now, you see that pattern matching can be combined with simple logical conditions and optional binding within a single <code class="calibre9">if</code> statement. Your code is looking more elegant already!
</p>
<h3 class="segment-title2">Custom tuple</h3>

<p class="calibre1">In this chapter, you saw how a tuple pattern could match a three-dimensional coordinate <code class="calibre9">(x, y, z)</code>.  You can create a just-in-time tuple expression at the moment you’re ready to match it.
</p>
<p class="calibre1">Here’s a tuple that does just that:
</p><pre class="code-block"><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Bob"</span>
<span class="hljs-keyword">let</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> (<span class="hljs-string">"Bob"</span>, <span class="hljs-number">23</span>) <span class="hljs-operator">=</span> (name, age) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Found the right Bob!"</span>) <span class="hljs-comment">// Printed!</span>
}</pre>
<p class="calibre1">Here you combine the name and age constants into a tuple and evaluate them together.
</p>
<p class="calibre1">Another such example involves a login form with a username and password field. Users are notorious for leaving fields incomplete then clicking Submit. In these cases, you want to show a specific error message to the user that indicates the missing field, like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> username: <span class="hljs-built_in">String</span>?
<span class="hljs-keyword">var</span> password: <span class="hljs-built_in">String</span>?

<span class="hljs-keyword">switch</span> (username, password) {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (username<span class="hljs-operator">?</span>, password<span class="hljs-operator">?</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Success! User: <span class="hljs-subst">\(username)</span> Pass: <span class="hljs-subst">\(password)</span>"</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (username<span class="hljs-operator">?</span>, <span class="hljs-keyword">nil</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Password is missing. User: <span class="hljs-subst">\(username)</span>"</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> (<span class="hljs-keyword">nil</span>, password<span class="hljs-operator">?</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Username is missing. Pass: <span class="hljs-subst">\(password)</span>"</span>)
<span class="hljs-keyword">case</span> (<span class="hljs-keyword">nil</span>, <span class="hljs-keyword">nil</span>):
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Both username and password are missing"</span>)  <span class="hljs-comment">// Printed!</span>
}</pre>
<p class="calibre1">Each case checks one of the possible submissions. You write the success case first because there is no need to check the rest of the cases if it is true. Swift’s switch` statements don’t fall through, so the remaining conditions don’t evaluate if the first case condition is true.
</p>
<h3 class="segment-title2">Fun with wildcards</h3>

<p class="calibre1">One fun way to use the wildcard pattern is within the definition of a <code class="calibre9">for</code> loop:
</p><pre class="code-block"><span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"hi"</span>) <span class="hljs-comment">// 3 times</span>
}</pre>
<p class="calibre1">This code performs its action three times. The underscore <code class="calibre9">_</code> means that you don’t care to use each value from the sequence. If you ever need to repeat an action, this is a clean way to write the code.
</p>
<h4 class="segment-title2">Validate that an optional exists</h4>
<pre class="code-block"><span class="hljs-keyword">let</span> user: <span class="hljs-built_in">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">"Bob"</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> user <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"There is no user."</span>)
  <span class="hljs-built_in">fatalError</span>()
}
<span class="hljs-built_in">print</span>(<span class="hljs-string">"User exists, but identity not needed."</span>) <span class="hljs-comment">// Printed!</span></pre>
<p class="calibre1">In this code, you check to make sure <code class="calibre9">user</code> has a value. You use the underscore to indicate that, right now, you don’t care what value it contains.
</p>
<p class="calibre1">Even though you <i class="calibre2">can</i> do something, it doesn’t mean you <i class="calibre2">should</i>. The best way to validate an optional where you don’t care about the value is like so:
</p><pre class="code-block"><span class="hljs-keyword">guard</span> user <span class="hljs-operator">!=</span> <span class="hljs-keyword">nil</span> <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"There is no user."</span>)
  <span class="hljs-built_in">fatalError</span>()
}</pre>
<p class="calibre1">Here, <code class="calibre9">user != nil</code> does the same thing as <code class="calibre9">let _ = user</code>, but the intent is more apparent.
</p>
<h4 class="segment-title2">Organize an if-else-if</h4>

<p class="calibre1">In app development, views are rectangles. Here’s a simplified version:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Rectangle</span> {
  <span class="hljs-keyword">let</span> width: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> height: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> background: <span class="hljs-built_in">String</span>
}

<span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> <span class="hljs-built_in">Rectangle</span>(width: <span class="hljs-number">15</span>, height: <span class="hljs-number">60</span>, background: <span class="hljs-string">"Green"</span>)
<span class="hljs-keyword">switch</span> view {
<span class="hljs-keyword">case</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">where</span> view.height <span class="hljs-operator">&lt;</span> <span class="hljs-number">50</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Shorter than 50 units"</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">where</span> view.width <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Over 50 tall, &amp; over 20 wide"</span>)
<span class="hljs-keyword">case</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">where</span> view.background <span class="hljs-operator">==</span> <span class="hljs-string">"Green"</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Over 50 tall, at most 20 wide, &amp; green"</span>) <span class="hljs-comment">// Printed!</span>
<span class="hljs-keyword">default</span>:
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"This view can’t be described by this example"</span>)
}</pre>
<p class="calibre1">You could write this code as a chain of <code class="calibre9">if</code> statements. When you use the <code class="calibre9">switch</code> statement, it becomes clear that each condition is a case. Notice that each case uses an underscore with a qualifying <code class="calibre9">where</code> clause.
</p>
<h2 class="segment-chapter1">Programming exercises</h2>

<p class="calibre1">As you develop confidence with Swift, you may find yourself applying for a job where you’d use Swift at work. Hiring interviews have some classic questions like the Fibonacci and FizzBuzz algorithms, and pattern matching can come in handy for both of these challenges.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note:</em> Both algorithms are call-intensive. If you’re following along in a playground, please start a new playground and use it for the rest of this chapter to avoid it stuttering under the processing load.
</p></div>

<h4 class="segment-title2">Fibonacci</h4>

<p class="calibre1">In the Fibonacci sequence, every element is the sum of the two preceding elements. The sequence starts with 0, 1, 1, 2, 3, 5, 8 …
</p>
<p class="calibre1">Here’s how you could find the 15th number of the Fibonacci sequence:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">fibonacci</span>(<span class="hljs-built_in">position</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
  <span class="hljs-keyword">switch</span> position {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> n <span class="hljs-keyword">where</span> n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> n:
    <span class="hljs-keyword">return</span> fibonacci(position: n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> fibonacci(position: n <span class="hljs-operator">-</span> <span class="hljs-number">2</span>)
  }
}

<span class="hljs-keyword">let</span> fib15 <span class="hljs-operator">=</span> fibonacci(position: <span class="hljs-number">15</span>) <span class="hljs-comment">// 377</span></pre>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">If the current sequence position is less than two, the function will return <code class="calibre9">0</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">If the current sequence position is equal to two, the function will return <code class="calibre9">1</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Otherwise, the function will use recursion to call itself and sum up all the numbers. This code is also an example of avoiding the <code class="calibre9">default</code> case in a <code class="calibre9">switch</code> statement. The <code class="calibre9">let n</code> case matches all values, so the <code class="calibre9">default</code> case is unnecessary.
</p></li>
</ol>

<h4 class="segment-title2">FizzBuzz</h4>

<p class="calibre1">In the FizzBuzz algorithm, your objective is to print the numbers from 1 to 100, except:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">On multiples of three, print <code class="calibre9">"Fizz"</code> instead of the number.
</p></li>

<li class="calibre4">
<p class="calibre1">On multiples of five, print <code class="calibre9">"Buzz"</code> instead of the number.
</p></li>

<li class="calibre4">
<p class="calibre1">On multiples of both three and five, print <code class="calibre9">"FizzBuzz"</code> instead of the number.
</p></li>
</ul>
<pre class="code-block"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">100</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">switch</span> (i <span class="hljs-operator">%</span> <span class="hljs-number">3</span>, i <span class="hljs-operator">%</span> <span class="hljs-number">5</span>) {
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"FizzBuzz"</span>, terminator: <span class="hljs-string">" "</span>)
  <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-keyword">_</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Fizz"</span>, terminator: <span class="hljs-string">" "</span>)
  <span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-number">0</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Buzz"</span>, terminator: <span class="hljs-string">" "</span>)
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">case</span> (<span class="hljs-keyword">_</span>, <span class="hljs-keyword">_</span>):
    <span class="hljs-built_in">print</span>(i, terminator: <span class="hljs-string">" "</span>)
  }
}
<span class="hljs-built_in">print</span>(<span class="hljs-string">""</span>)</pre>
<p class="calibre1">Here’s what’s going on:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">You construct a tuple in the <code class="calibre9">switch</code> expression.
</p></li>

<li class="calibre4">
<p class="calibre1">Each of the cases checks a result of the modulo operation. The underscore means you don’t care, and it matches any value.
</p></li>

<li class="calibre4">
<p class="calibre1">In this code, you see another equivalent way to avoid writing the <code class="calibre9">default</code> case of a <code class="calibre9">switch</code> statement with a tuple pattern of all underscores <code class="calibre9">(_, _)</code> that match any value. This type of pattern is known in the Swift lexicon as an <em class="calibre5">irrefutable pattern</em>.
</p></li>
</ol>

<p class="calibre1">The <code class="calibre9">terminator</code> parameter of the <code class="calibre9">print</code> call tells the compiler to end each line with a space character instead of a new line. All the numbers in the algorithm will print on one line in your debug area. The final <code class="calibre9">print("")</code> call adds an empty string with a new line so that any future code will print on a new line.
</p>
<p class="calibre1">Now you know how to ace those tricky interview questions in a surprisingly elegant fashion using pattern matching. You can thank me later for your new Swift job!
</p>
<h2 class="segment-chapter1">Expression pattern</h2>

<p class="calibre1">With all the pattern matching skills you’ve developed so far, you’re finally ready to learn what’s underneath the hood. The expression pattern is simple, but oh, so powerful.
</p>
<p class="calibre1">At the beginning of this chapter, you saw the example tuple pattern <code class="calibre9">(x, 0, 0)</code>. You learned that, internally, the tuple is a comma-separated list of patterns.  You also learned that the <code class="calibre9">x</code> is an identifier pattern, while the <code class="calibre9">0</code>’s are examples of the expression pattern. So the tuple’s internal patterns are (<i class="calibre2">identifier</i>, <i class="calibre2">expression</i>, <i class="calibre2">expression</i>).
</p>
<p class="calibre1">The expression pattern compares values with the pattern matching operator, <code class="calibre9">~=</code>. The match succeeds when a comparison returns <code class="calibre9">true</code>. If the values are the same type, the common <code class="calibre9">==</code> equality operator performs the comparison instead. You learned how to implement <code class="calibre9">Equatable</code> and <code class="calibre9">==</code> for your own named types back in Chapter 16, “Protocols”.
</p>
<p class="calibre1">When the values aren’t of the same type or the type doesn’t implement the <code class="calibre9">Equatable</code> protocol, the <code class="calibre9">~=</code> pattern matching operator is used.
</p>
<p class="calibre1">For instance, the compiler uses the <code class="calibre9">~=</code> operator to check whether an integer value falls within a range. The range is not an integer, so the compiler cannot use the <code class="calibre9">==</code> operator.  However, you can conceptualize the idea of checking whether an <code class="calibre9">Int</code> is within a range. That’s where the <code class="calibre9">~=</code> pattern matching operator comes in:
</p><pre class="code-block"><span class="hljs-keyword">let</span> matched <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span> <span class="hljs-operator">~=</span> <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span></pre>
<p class="calibre1">As in the definition of a case condition, the pattern must be on the operator’s left-hand side and the value on the right-hand side of the operator. Here’s what the equivalent case condition looks like:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"In the range"</span>)
}</pre>
<p class="calibre1">This <code class="calibre9">if case</code> statement is functionally equivalent to using the <code class="calibre9">~=</code> operator in the previous example.
</p>
<h3 class="segment-title2">Overloading <code class="calibre12">~=</code></h3>

<p class="calibre1">You can overload the <code class="calibre9">~=</code> operator to provide a custom expression matching behavior. You’ll implement a pattern match between an array and an integer to check if the integer is an element of the array. A value of <code class="calibre9">2</code> should match the pattern <code class="calibre9">[0, 1, 2, 3]</code>. With the standard library, you’ll get an error on this code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> list <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> integer <span class="hljs-operator">=</span> <span class="hljs-number">2</span>

<span class="hljs-keyword">let</span> isInArray <span class="hljs-operator">=</span> (list <span class="hljs-operator">~=</span> integer) <span class="hljs-comment">// Error!</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> list <span class="hljs-operator">=</span> integer { <span class="hljs-comment">// Error!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The integer is in the array"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The integer is not in the array"</span>)
}</pre>
<p class="calibre1">Sure, you could check if the integer is in the array like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> isInList <span class="hljs-operator">=</span> list.contains(integer) <span class="hljs-comment">// true</span></pre>
<p class="calibre1">But it would be nice to use pattern matching so that you could check for a match within a <code class="calibre9">switch</code> statement. You can implement the missing pattern matcher with this code:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">~=</span>(<span class="hljs-built_in">pattern</span>: [<span class="hljs-built_in">Int</span>], <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Bool</span> {
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pattern {
    <span class="hljs-keyword">if</span> i <span class="hljs-operator">==</span> value {
      <span class="hljs-comment">// 3</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
    }
  }
  <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
}</pre>
<p class="calibre1">Here’s what’s happening:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The function takes an array of integers as its <code class="calibre9">pattern</code> parameter and an integer as its <code class="calibre9">value</code> parameter. The function returns a <code class="calibre9">Bool</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">In the implementation, a <code class="calibre9">for</code> loop iterates through each element in the array.
</p></li>
</ol>

<ol start="3" class="calibre11">
<li class="calibre4">
<p class="calibre1">If the value is equal to the current array element, the function immediately returns <code class="calibre9">true</code>, and no more code runs within the function implementation.
</p></li>

<li class="calibre4">
<p class="calibre1">If the <code class="calibre9">for</code> loop finishes without any matches, the function returns <code class="calibre9">false</code>.
</p></li>
</ol>

<p class="calibre1">Now that the pattern matching operator is overloaded, the expression patterns you saw earlier now match correctly with no errors.
</p><pre class="code-block"><span class="hljs-keyword">let</span> isInArray <span class="hljs-operator">=</span> (list <span class="hljs-operator">~=</span> integer) <span class="hljs-comment">// true</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> list <span class="hljs-operator">=</span> integer {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The integer is in the array"</span>) <span class="hljs-comment">// Printed!</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The integer is not in the array"</span>)
}</pre>
<p class="calibre1">You are now a pattern-matching ninja! With your mastery of patterns, you’re ready to write clear, concise, readable code.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of pattern matching. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Carded</h3>

<p class="calibre1">Given this code, write an <code class="calibre9">if</code> statement that shows an error if the user is not yet 21 years old:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">FormField</span> {
  <span class="hljs-keyword">case</span> firstName(<span class="hljs-built_in">String</span>)
  <span class="hljs-keyword">case</span> lastName(<span class="hljs-built_in">String</span>)
  <span class="hljs-keyword">case</span> emailAddress(<span class="hljs-built_in">String</span>)
  <span class="hljs-keyword">case</span> age(<span class="hljs-built_in">Int</span>)
}
<span class="hljs-keyword">let</span> minimumAge <span class="hljs-operator">=</span> <span class="hljs-number">21</span>
<span class="hljs-keyword">let</span> submittedAge <span class="hljs-operator">=</span> <span class="hljs-built_in">FormField</span>.age(<span class="hljs-number">22</span>)</pre>
<h3 class="segment-title2">Challenge 2: Planets with liquid water</h3>

<p class="calibre1">Given this code, find the planets with liquid water using a <code class="calibre9">for</code> loop:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">CelestialBody</span> {
  <span class="hljs-keyword">case</span> star
  <span class="hljs-keyword">case</span> planet(liquidWater: <span class="hljs-built_in">Bool</span>)
  <span class="hljs-keyword">case</span> comet
}

<span class="hljs-keyword">let</span> telescopeCensus <span class="hljs-operator">=</span> [
  <span class="hljs-built_in">CelestialBody</span>.star,
  .planet(liquidWater: <span class="hljs-keyword">false</span>),
  .planet(liquidWater: <span class="hljs-keyword">true</span>),
  .planet(liquidWater: <span class="hljs-keyword">true</span>),
  .comet
]</pre>
<h3 class="segment-title2">Challenge 3: Find the year</h3>

<p class="calibre1">Given this code, find the albums that were released in 1974 with a <code class="calibre9">for</code> loop:
</p><pre class="code-block"><span class="hljs-keyword">let</span> queenAlbums <span class="hljs-operator">=</span> [
  (<span class="hljs-string">"A Night at the Opera"</span>, <span class="hljs-number">1974</span>),
  (<span class="hljs-string">"Sheer Heart Attack"</span>, <span class="hljs-number">1974</span>),
  (<span class="hljs-string">"Jazz"</span>, <span class="hljs-number">1978</span>),
  (<span class="hljs-string">"The Game"</span>, <span class="hljs-number">1980</span>)
]</pre>
<h3 class="segment-title2">Challenge 4: Where in the world</h3>

<p class="calibre1">Given the following code, write a <code class="calibre9">switch</code> statement that will print out whether the monument is located in the northern hemisphere, the southern hemisphere, or on the equator.
</p><pre class="code-block"><span class="hljs-keyword">let</span> coordinates <span class="hljs-operator">=</span> (lat: <span class="hljs-number">37.334890</span>, long: <span class="hljs-operator">-</span><span class="hljs-number">122.009000</span>)</pre>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A pattern represents the structure of a value.
</p></li>

<li class="calibre4">
<p class="calibre1">Pattern matching can help you write more readable code than the alternative logical conditions.
</p></li>

<li class="calibre4">
<p class="calibre1">Pattern matching is the only way to extract associated values from enumeration values.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-2">


<h1 class="segment-chapter">Chapter 22: Error Handling</h1>

<p class="calibre1">Skilled developers design their software for errors. Error handling is the art of failing gracefully. Although you have complete control of your code, you don’t control outside events and resources. These include user input, network connections, available system memory and files your app needs to access.
</p>
<p class="calibre1">In this chapter, you’ll learn the fundamentals of error handling: what it is and different strategies for implementing it.
</p>
<h2 class="segment-chapter1">What is error handling?</h2>

<p class="calibre1">Imagine you’re in the desert and you decide to surf the internet. You’re miles away from the nearest hotspot with no cellular signal. You open your internet browser. What happens? Does your browser hang there forever with a spinning wheel of death, or does it immediately alert you to the fact that you have no internet access?
</p>
<p class="calibre1">When you’re designing the user experience for your apps, you must think about the error states. Think about what can go wrong, how you want your app to respond, and how you want to surface that information to users to allow them to act on it appropriately.
</p>
<h2 class="segment-chapter1">First level error handling with optionals</h2>

<p class="calibre1">Throughout this book, you have already seen an elementary form of error handling in action. Optionals model missing information and provide compiler and runtime guarantees that you won’t accidentally act on values that are not available. This predictability is the foundation of Swift’s safety.
</p>
<h3 class="segment-title2">Failable initializers</h3>

<p class="calibre1">When you try to initialize an object from external input, it may fail. For example, if you’re converting a <code class="calibre9">String</code> into an <code class="calibre9">Int</code>, there is no guarantee it’ll work.
</p><pre class="code-block"><span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>(<span class="hljs-string">"3"</span>)          <span class="hljs-comment">// Optional(3)</span>
<span class="hljs-keyword">let</span> failedValue <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>(<span class="hljs-string">"nope"</span>) <span class="hljs-comment">// nil</span></pre>
<p class="calibre1">You saw in Chapter 15, “Enumerations”, if you make your own raw representable enumeration type, the compiler creates a <em class="calibre5">failable initializer</em> for you. For example, suppose you have some pet foods backed by a string.
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">PetFood</span>: <span class="hljs-number">String</span> {
  <span class="hljs-keyword">case</span> kibble, canned
}

<span class="hljs-keyword">let</span> morning <span class="hljs-operator">=</span> <span class="hljs-built_in">PetFood</span>(rawValue: <span class="hljs-string">"kibble"</span>)  <span class="hljs-comment">// Optional(.kibble)</span>
<span class="hljs-keyword">let</span> snack <span class="hljs-operator">=</span> <span class="hljs-built_in">PetFood</span>(rawValue: <span class="hljs-string">"fuuud!"</span>)    <span class="hljs-comment">// nil</span></pre>
<p class="calibre1">The return type is optional to recognize the risk of failure, and the return value will be <code class="calibre9">nil</code> if initialization fails.
</p>
<p class="calibre1">You can create failable initializers yourself. Try it out:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PetHouse</span> {
  <span class="hljs-keyword">let</span> squareFeet: <span class="hljs-built_in">Int</span>
  
  <span class="hljs-keyword">init?</span>(<span class="hljs-built_in">squareFeet</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">if</span> squareFeet <span class="hljs-operator">&lt;</span> <span class="hljs-number">1</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
    }
    <span class="hljs-keyword">self</span>.squareFeet <span class="hljs-operator">=</span> squareFeet
  }
}

<span class="hljs-keyword">let</span> tooSmall <span class="hljs-operator">=</span> <span class="hljs-built_in">PetHouse</span>(squareFeet: <span class="hljs-number">0</span>) <span class="hljs-comment">// nil</span>
<span class="hljs-keyword">let</span> house <span class="hljs-operator">=</span> <span class="hljs-built_in">PetHouse</span>(squareFeet: <span class="hljs-number">1</span>)    <span class="hljs-comment">// Optional(Pethouse)</span></pre>
<p class="calibre1">To make a failable initializer, you simply name it <code class="calibre9">init?(...)</code> and return <code class="calibre9">nil</code> if it fails. Using a failable initializer, you can <i class="calibre2">guarantee</i> that your instance has the correct attributes, or it will never exist.
</p>
<h3 class="segment-title2">Optional chaining</h3>

<p class="calibre1">Have you ever seen a prompt in Xcode from the compiler that something is wrong, and you are supposed to add <code class="calibre9">!</code> to a property? The compiler tells you that you’re dealing with an optional value and sometimes suggests that you deal with it by force unwrapping.
</p>
<p class="calibre1">Sometimes force unwrapping or using an implicitly unwrapped optional is just fine. If you have <code class="calibre9">@IBOutlets</code> in your UIKit app, you know those elements must exist after the view loads, and if they don’t, there is something wrong with your app. In general, force unwrap or using implicitly unwrapped optionals is appropriate only when an optional <i class="calibre2">must</i> contain a value. In all other cases, you’re asking for trouble!
</p>
<p class="calibre1">Consider this code:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">var</span> breed: <span class="hljs-built_in">String</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">breed</span>: <span class="hljs-built_in">String</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>) {
    <span class="hljs-keyword">self</span>.breed <span class="hljs-operator">=</span> breed
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">let</span> pet: <span class="hljs-built_in">Pet</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">pet</span>: <span class="hljs-built_in">Pet</span>) {
    <span class="hljs-keyword">self</span>.pet <span class="hljs-operator">=</span> pet
  }
}

<span class="hljs-keyword">let</span> delia <span class="hljs-operator">=</span> <span class="hljs-built_in">Pet</span>(breed: <span class="hljs-string">"pug"</span>)
<span class="hljs-keyword">let</span> olive <span class="hljs-operator">=</span> <span class="hljs-built_in">Pet</span>()

<span class="hljs-keyword">let</span> janie <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(pet: olive)
<span class="hljs-keyword">let</span> dogBreed <span class="hljs-operator">=</span> janie.pet.breed<span class="hljs-operator">!</span> <span class="hljs-comment">// This is bad! Will cause a crash!</span></pre>
<p class="calibre1">In this simple example, Olive has no breed. She was a rescue from the pound, so her breed is unknown. But she’s still a sweetheart.
</p>
<p class="calibre1">If you assume she has a breed and force unwraps this property, it will cause the program to crash. There’s a better way of handling this situation.
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> dogBreed <span class="hljs-operator">=</span> janie.pet.breed {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Olive is a <span class="hljs-subst">\(dogBreed)</span>."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Olive’s breed is unknown."</span>)
}</pre>
<p class="calibre1">This code is pretty standard optional handling, but you can take you far even with more complicated types with nested optionals.
</p>
<p class="calibre1">Comment out what you have so far and start over with the following types:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Toy</span> {

  <span class="hljs-keyword">enum</span> <span class="hljs-number">Kind</span> {
    <span class="hljs-keyword">case</span> ball, zombie, bone, mouse
  }

  <span class="hljs-keyword">enum</span> <span class="hljs-number">Sound</span> {
    <span class="hljs-keyword">case</span> squeak, bell
  }

  <span class="hljs-keyword">let</span> kind: <span class="hljs-built_in">Kind</span>
  <span class="hljs-keyword">let</span> color: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> sound: <span class="hljs-built_in">Sound</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">kind</span>: <span class="hljs-built_in">Kind</span>, <span class="hljs-built_in">color</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">sound</span>: <span class="hljs-built_in">Sound</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>) {
    <span class="hljs-keyword">self</span>.kind <span class="hljs-operator">=</span> kind
    <span class="hljs-keyword">self</span>.color <span class="hljs-operator">=</span> color
    <span class="hljs-keyword">self</span>.sound <span class="hljs-operator">=</span> sound
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Pet</span> {

  <span class="hljs-keyword">enum</span> <span class="hljs-number">Kind</span> {
    <span class="hljs-keyword">case</span> dog, cat, guineaPig
  }

  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> kind: <span class="hljs-built_in">Kind</span>
  <span class="hljs-keyword">let</span> favoriteToy: <span class="hljs-built_in">Toy</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">kind</span>: <span class="hljs-built_in">Kind</span>, <span class="hljs-built_in">favoriteToy</span>: <span class="hljs-built_in">Toy</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.kind <span class="hljs-operator">=</span> kind
    <span class="hljs-keyword">self</span>.favoriteToy <span class="hljs-operator">=</span> favoriteToy
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">let</span> pet: <span class="hljs-built_in">Pet</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">pet</span>: <span class="hljs-built_in">Pet</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>) {
    <span class="hljs-keyword">self</span>.pet <span class="hljs-operator">=</span> pet
  }
}</pre>
<p class="calibre1">A lot of raywenderlich.com team members own pets &mdash; but not all. Some pets have a favorite toy, and others don’t. Even further into this, some of these toys make noise, and others don’t.
</p>
<p class="calibre1">For example, Tammy Coron’s evil cat is methodically plotting her death.
</p><div class="image4"><img src="images/000013.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">This cat’s favorite toy to chew on (besides Tammy) is a catnip mouse. This toy doesn’t make any noise.
</p>
<p class="calibre1">Felipe Marsetti is a Ray Wenderlich team member who lives in a condo and isn’t allowed to have pets.
</p><pre class="code-block"><span class="hljs-keyword">let</span> janie <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(pet: <span class="hljs-built_in">Pet</span>(name: <span class="hljs-string">"Delia"</span>, kind: .dog, 
                   favoriteToy: <span class="hljs-built_in">Toy</span>(kind: .ball, 
                   color: <span class="hljs-string">"Purple"</span>, sound: .bell)))
<span class="hljs-keyword">let</span> tammy <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(pet: <span class="hljs-built_in">Pet</span>(name: <span class="hljs-string">"Evil Cat Overlord"</span>, 
                   kind: .cat, favoriteToy: <span class="hljs-built_in">Toy</span>(kind: .mouse, 
                   color: <span class="hljs-string">"Orange"</span>)))
<span class="hljs-keyword">let</span> felipe <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>()</pre>
<p class="calibre1">You want to check if any team members have a pet with a favorite toy that makes a sound. You can use <em class="calibre5">optional chaining</em> for this; it’s a quick way to walk through a chain of optionals by adding a <code class="calibre9">?</code> after every property or method that can return <code class="calibre9">nil</code>. If any of the chain’s values were <code class="calibre9">nil</code>, the result will be <code class="calibre9">nil</code> as well. So instead of having to test every optional along the chain, you simply test the result!
</p>
<p class="calibre1">For example:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> sound <span class="hljs-operator">=</span> janie.pet<span class="hljs-operator">?</span>.favoriteToy<span class="hljs-operator">?</span>.sound {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sound <span class="hljs-subst">\(sound)</span>."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No sound."</span>)
}</pre>
<p class="calibre1">Janie’s pet &mdash; one of her pugs, not just any old pet &mdash; fulfills all of the conditions, and therefore the sound is accessible.
</p>
<p class="calibre1">Try accessing the sound with Tammy and Felipe:
</p><pre class="code-block"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> sound <span class="hljs-operator">=</span> tammy.pet<span class="hljs-operator">?</span>.favoriteToy<span class="hljs-operator">?</span>.sound {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sound <span class="hljs-subst">\(sound)</span>."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No sound."</span>)
}

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> sound <span class="hljs-operator">=</span> felipe.pet<span class="hljs-operator">?</span>.favoriteToy<span class="hljs-operator">?</span>.sound {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sound <span class="hljs-subst">\(sound)</span>."</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"No sound."</span>)
}</pre>
<p class="calibre1">During each stage of this chain, the compiler checks whether or not each optional property is present.
</p>
<p class="calibre1">Since Tammy’s cat’s toy does not have a sound, the process bails out after <code class="calibre9">favoriteToy?.</code> Since Felipe doesn’t have a pet at all, the process bails out after <code class="calibre9">pet?.</code>
</p>
<p class="calibre1">All this checking is repetitive. What if you wanted to iterate through the entire array of team members to find this information?
</p>
<h3 class="segment-title2">Map and compactMap</h3>

<p class="calibre1">Let’s say you want to create an array of pets the team owns. First off, you need to create an array of team members:
</p><pre class="code-block"><span class="hljs-keyword">let</span> team <span class="hljs-operator">=</span> [janie, tammy, felipe]</pre>
<p class="calibre1">You want to iterate through this array and extract all pet names. You could use a <code class="calibre9">for</code> loop, but you’ve already learned a better way to do this: <code class="calibre9">map</code>.
</p><pre class="code-block"><span class="hljs-keyword">let</span> petNames <span class="hljs-operator">=</span> team.map { <span class="hljs-variable">$0</span>.pet<span class="hljs-operator">?</span>.name }</pre>
<p class="calibre1">This code creates a new array of pet names by pulling out the pet name from each team member in the array. You want to see what these values are, so why not print them out?
</p><pre class="code-block"><span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> petNames {
  <span class="hljs-built_in">print</span>(pet)
}</pre>
<p class="calibre1">The compiler generates a warning. Look at the output for this <code class="calibre9">print</code> statement:
</p><pre class="code-block"><span class="hljs-built_in">Optional</span>(<span class="hljs-string">"Delia"</span>)
<span class="hljs-built_in">Optional</span>(<span class="hljs-string">"Evil Cat Overlord"</span>)
<span class="hljs-keyword">nil</span></pre>
<p class="calibre1">Ew! That doesn’t look right. Instead of having a nice list of names, you have many optional values and even a <code class="calibre9">nil</code>! This won’t do at all.
</p><div class="image11"><img src="images/000026.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You could take this array, filter it and then call <code class="calibre9">map</code> again to unwrap all the values that are not <code class="calibre9">nil</code>, but that seems somewhat convoluted. Iterating through an array of optional values that you need to unwrap and ensure are not <code class="calibre9">nil</code> is a very common operation.
</p>
<p class="calibre1">There is a better way to accomplish this task: <code class="calibre9">compactMap</code>. Try out the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> betterPetNames <span class="hljs-operator">=</span> team.compactMap { <span class="hljs-variable">$0</span>.pet<span class="hljs-operator">?</span>.name }

<span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> betterPetNames {
  <span class="hljs-built_in">print</span>(pet)
}</pre>
<p class="calibre1">You should see a far more helpful and user-friendly output:
</p><pre class="code-block"><span class="hljs-built_in">Delia</span>
<span class="hljs-built_in">Evil</span> <span class="hljs-built_in">Cat</span> <span class="hljs-built_in">Overlord</span></pre>
<p class="calibre1"><code class="calibre9">compactMap</code> does a regular <code class="calibre9">map</code> operation and potentially “compacts” or shrinks the result array’s size. In this case, you’re using <code class="calibre9">compactMap</code> to compact the return type <code class="calibre9">[Optional&lt;String&gt;]</code> into the type <code class="calibre9">[String]</code>.
</p>
<p class="calibre1">So far, you’ve learned how to do some informal error handling. Up next, you’ll learn about the <code class="calibre9">Error</code> protocol to do some proper error handling.
</p>
<h2 class="segment-chapter1">Error protocol</h2>

<p class="calibre1">Swift includes the <code class="calibre9">Error</code> protocol, which forms the basis of the error-handling architecture. Any type that conforms to this protocol represents an error.
</p>
<p class="calibre1">Any named type can conform to the <code class="calibre9">Error</code>, but it’s especially well-suited to enumerations.  Try it out now.
</p>
<p class="calibre1">Create a new playground where you will create an abstraction for a bakery and use it to learn how to throw and handle errors.
</p>
<p class="calibre1">Add this code to your playground:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Pastry</span> {
  <span class="hljs-keyword">let</span> flavor: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> numberOnHand: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">flavor</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">numberOnHand</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">self</span>.flavor <span class="hljs-operator">=</span> flavor
    <span class="hljs-keyword">self</span>.numberOnHand <span class="hljs-operator">=</span> numberOnHand
  }
}

<span class="hljs-keyword">enum</span> <span class="hljs-number">BakeryError</span>: <span class="hljs-number">Error</span> {
  <span class="hljs-keyword">case</span> tooFew(numberOnHand: <span class="hljs-built_in">Int</span>), doNotSell, wrongFlavor
  <span class="hljs-keyword">case</span> inventory, noPower
}</pre>
<p class="calibre1">The <code class="calibre9">Error</code> protocol tells the compiler that this enumeration represents errors that you can throw. There are many types of errors at a bakery. You may be out of stock, have the wrong flavor, or you may not sell an item altogether. The bakery may also be closed because it ran out of inventory or because of a power outage.
</p>
<h2 class="segment-chapter1">Throwing errors</h2>

<p class="calibre1">What does your program do with these errors? It throws them, of course! That’s the actual terminology you’ll see: <em class="calibre5">throwing</em> errors then <em class="calibre5">catching</em> them.
</p>
<p class="calibre1">Add this class to your playground:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Bakery</span> {
  <span class="hljs-keyword">var</span> itemsForSale <span class="hljs-operator">=</span> [
    <span class="hljs-string">"Cookie"</span>: <span class="hljs-built_in">Pastry</span>(flavor: <span class="hljs-string">"ChocolateChip"</span>, numberOnHand: <span class="hljs-number">20</span>),
    <span class="hljs-string">"PopTart"</span>: <span class="hljs-built_in">Pastry</span>(flavor: <span class="hljs-string">"WildBerry"</span>, numberOnHand: <span class="hljs-number">13</span>),
    <span class="hljs-string">"Donut"</span> : <span class="hljs-built_in">Pastry</span>(flavor: <span class="hljs-string">"Sprinkles"</span>, numberOnHand: <span class="hljs-number">24</span>),
    <span class="hljs-string">"HandPie"</span>: <span class="hljs-built_in">Pastry</span>(flavor: <span class="hljs-string">"Cherry"</span>, numberOnHand: <span class="hljs-number">6</span>)
  ]
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">open</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">now</span>: <span class="hljs-built_in">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Bool</span>.random()) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-built_in">Bool</span> {
    <span class="hljs-keyword">guard</span> now <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bool</span>.random() <span class="hljs-operator">?</span> <span class="hljs-built_in">BakeryError</span>.inventory 
                          : <span class="hljs-built_in">BakeryError</span>.noPower
    }
    <span class="hljs-keyword">return</span> now
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">orderPastry</span>(<span class="hljs-built_in">item</span>: <span class="hljs-built_in">String</span>,
                   <span class="hljs-built_in">amountRequested</span>: <span class="hljs-built_in">Int</span>,
                   <span class="hljs-built_in">flavor</span>: <span class="hljs-built_in">String</span>)  <span class="hljs-keyword">throws</span>  -&gt; <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> pastry <span class="hljs-operator">=</span> itemsForSale[item] <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BakeryError</span>.doNotSell
    }
    <span class="hljs-keyword">guard</span> flavor <span class="hljs-operator">==</span> pastry.flavor <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BakeryError</span>.wrongFlavor
    }
    <span class="hljs-keyword">guard</span> amountRequested <span class="hljs-operator">&lt;=</span> pastry.numberOnHand <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BakeryError</span>.tooFew(numberOnHand: 
                               pastry.numberOnHand)
    }
    pastry.numberOnHand <span class="hljs-operator">-=</span> amountRequested

    <span class="hljs-keyword">return</span> pastry.numberOnHand
  }
}</pre>
<p class="calibre1">The bakery sometimes closes because unexpected things like an inventory or a power shortage may happen randomly, so you should first check if it is open right now.
</p>
<p class="calibre1">Next, you need to have some items to sell. Each item needs to have a flavor and an amount on hand. When customers order a pastry from you, they need to tell you what pastry they want, what flavor, and how many they want. Customers can be incredibly demanding. :]
</p>
<p class="calibre1">First, you need to check if you even carry what the customer wants. If the customer tries to order albatross with wafers, you don’t want the bakery to crash. After you verify that the bakery carries the item the customer wants, you need to check if you have the requested flavor and have enough of that item to fulfill the customer’s order.
</p>
<p class="calibre1">As this example shows, you throw errors using <code class="calibre9">throw</code>. The errors you throw must be instances of a type that conforms to <code class="calibre9">Error</code>. A function (or method) that throws errors and does not immediately handle them must clarify this by adding <code class="calibre9">throws</code> to its declaration.
</p>
<p class="calibre1">Next, try out your bakery:
</p><pre class="code-block"><span class="hljs-keyword">let</span> bakery <span class="hljs-operator">=</span> <span class="hljs-built_in">Bakery</span>()
bakery.open()
bakery.orderPastry(item: <span class="hljs-string">"Albatross"</span>,
                   amountRequested: <span class="hljs-number">1</span>,
                   flavor: <span class="hljs-string">"AlbatrossFlavor"</span>)</pre>
<p class="calibre1">The code above does not compile. What’s wrong? Oh, right &mdash; you need to catch the error and do something with it.
</p>
<h2 class="segment-chapter1">Handling errors</h2>

<p class="calibre1">After your program throws an error, you need to handle that error. There are two ways to approach this problem: Immediately handling your errors or bubble them up to another level.
</p>
<p class="calibre1">To choose your approach, you need to think about where it makes the most sense to handle the error. If it makes sense to handle the error immediately, then do so. Suppose you’re in a situation where you have to alert the user and have her take action, but you’re several function calls away from a user interface element. In that case, it makes sense to bubble up the error until you reach the point where you can alert the user.
</p>
<p class="calibre1">It’s up to you at what level in your call stack to handle the error, but <i class="calibre2">not</i> handling it isn’t an option. Swift requires you to deal with the error at some point in the chain, or your program won’t compile.
</p>
<p class="calibre1">Replace the previous line of code with this:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> bakery.open()
  <span class="hljs-keyword">try</span> bakery.orderPastry(item: <span class="hljs-string">"Albatross"</span>,
                          amountRequested: <span class="hljs-number">1</span>,
                          flavor: <span class="hljs-string">"AlbatrossFlavor"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-built_in">BakeryError</span>.inventory, <span class="hljs-built_in">BakeryError</span>.noPower {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sorry, the bakery is now closed."</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-built_in">BakeryError</span>.doNotSell {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sorry, but we don’t sell this item."</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-built_in">BakeryError</span>.wrongFlavor {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sorry, but we don’t carry this flavor."</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-built_in">BakeryError</span>.tooFew {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Sorry, we don’t have enough items to fulfill your 
         order."</span>)
}</pre>
<p class="calibre1">Code that can throw errors must always be inside a <code class="calibre9"><em class="calibre13">do</em></code> block, which creates a new scope. Even more, the possible points where errors can occur have a <code class="calibre9"><em class="calibre13">try</em></code> in front of them. The <code class="calibre9">try</code> serves as a reminder to anyone reading your code that something could go wrong.
</p>
<p class="calibre1">You’re now catching each error condition and providing helpful feedback to the user about why the bakery is closed for now and why you can’t fulfill their order. You can catch multiple errors in the same <code class="calibre9">catch</code> block - really cool! :]
</p><div class="image12"><img src="images/000041.png" alt="" title="" class="calibre7" /></div>
<h3 class="segment-title2">Not looking at the detailed error</h3>

<p class="calibre1">If you don’t care about the error details, you can use <code class="calibre9">try?</code> to wrap the result of a function (or method) in an optional. The function will then return <code class="calibre9">nil</code> instead of throwing an error. No need to set up a <code class="calibre9">do {} catch {}</code> block.
</p>
<p class="calibre1">For example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> <span class="hljs-keyword">open</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> bakery.open(<span class="hljs-keyword">false</span>)
<span class="hljs-keyword">let</span> remaining <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> bakery.orderPastry(item: <span class="hljs-string">"Albatross"</span>,
                                        amountRequested: <span class="hljs-number">1</span>,
                                        flavor: <span class="hljs-string">"AlbatrossFlavor"</span>)</pre>
<p class="calibre1">This code is nice and short to write, but the downside is that you don’t get any details if the request fails.
</p>
<h3 class="segment-title2">Stoping your program on an error</h3>

<p class="calibre1">Sometimes you know for sure that your code is not going to fail. For example, if you certainly know the bakery is now open and you just restocked the cookie jar, you’ll be able to order a cookie. Add:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> bakery.open(<span class="hljs-keyword">true</span>)
  <span class="hljs-keyword">try</span> bakery.orderPastry(item: <span class="hljs-string">"Cookie"</span>,
                         amountRequested: <span class="hljs-number">1</span>,
                         flavor: <span class="hljs-string">"ChocolateChip"</span>)
}
<span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">fatalError</span>()
}</pre>
<p class="calibre1">Swift gives you a short way to write the same thing:
</p><pre class="code-block"><span class="hljs-keyword">try!</span> bakery.open(<span class="hljs-keyword">true</span>)
<span class="hljs-keyword">try!</span> bakery.orderPastry(item: <span class="hljs-string">"Cookie"</span>, amountRequested: <span class="hljs-number">1</span>, 
                        flavor: <span class="hljs-string">"ChocolateChip"</span>)</pre>
<p class="calibre1">It’s delicious syntactic sugar, but know that your program will halt if the no error assumption does not hold. So, just as with implicitly unwrapped optionals, you need to be extra careful when using <code class="calibre9">try!</code> and avoid it in production code.
</p>
<h2 class="segment-chapter1">Advanced error handling</h2>

<p class="calibre1">Cool, you know how to handle errors! That’s neat, but how do you scale your error handling to a more extensive, more complex app?
</p>
<h3 class="segment-title2">PugBot</h3>

<p class="calibre1">The sample project you’ll work with in this second half of the chapter is <em class="calibre5">PugBot</em>. The PugBot is cute and friendly, but sometimes it gets lost and confused.
</p>
<p class="calibre1">As the programmer of the PugBot, it’s your responsibility to make sure it doesn’t get lost on the way home from your PugBot lab.
</p><div class="image11"><img src="images/000053.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You’ll learn how to make sure your PugBot finds its way home by throwing an error if it steers off course.
</p>
<p class="calibre1">First, you need to set up an enum containing all of the directions your <code class="calibre9">PugBot</code> can move:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Direction</span> {
  <span class="hljs-keyword">case</span> left, right, forward
}</pre>
<p class="calibre1">You’ll also need an error type to indicate what can go wrong:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">PugBotError</span>: <span class="hljs-number">Error</span> {
  <span class="hljs-keyword">case</span> invalidMove(found: <span class="hljs-built_in">Direction</span>, expected: <span class="hljs-built_in">Direction</span>)
  <span class="hljs-keyword">case</span> endOfPath
}</pre>
<p class="calibre1">Here, associated values store additional details about what went wrong. With any luck, you’ll be able to use these to rescue a lost <code class="calibre9">PugBot</code>!
</p><div class="image13"><img src="images/000066.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Last but not least, create your <code class="calibre9">PugBot</code> class:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">PugBot</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> correctPath: [<span class="hljs-built_in">Direction</span>]
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentStepInPath <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">correctPath</span>: [<span class="hljs-built_in">Direction</span>]) {
    <span class="hljs-keyword">self</span>.correctPath <span class="hljs-operator">=</span> correctPath
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">move</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">direction</span>: <span class="hljs-built_in">Direction</span>) <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">guard</span> currentStepInPath <span class="hljs-operator">&lt;</span> correctPath.count <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">PugBotError</span>.endOfPath
    }
    <span class="hljs-keyword">let</span> nextDirection <span class="hljs-operator">=</span> correctPath[currentStepInPath]
    <span class="hljs-keyword">guard</span> nextDirection <span class="hljs-operator">==</span> direction <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">PugBotError</span>.invalidMove(found: direction, 
                                    expected: nextDirection)
    }
    currentStepInPath <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">reset</span>() {
    currentStepInPath <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
  }
}</pre>
<p class="calibre1">When creating a <code class="calibre9">PugBot</code>, you tell it how to get home by passing it the correct directions. <code class="calibre9">move(_:)</code> causes the <code class="calibre9">PugBot</code> to move in the corresponding <code class="calibre9">direction</code>. If at any point the program notices the <code class="calibre9">PugBot</code> isn’t doing what it’s supposed to do, it throws an error.
</p>
<p class="calibre1">Give your <code class="calibre9">PugBot</code> a test:
</p><pre class="code-block"><span class="hljs-keyword">let</span> pug <span class="hljs-operator">=</span> <span class="hljs-built_in">PugBot</span>(name: <span class="hljs-string">"Pug"</span>,
                 correctPath: [.forward, .left, .forward, .right])

<span class="hljs-keyword">func</span> <span class="hljs-number">goHome</span>() <span class="hljs-keyword">throws</span> {
  <span class="hljs-keyword">try</span> pug.move(.forward)
  <span class="hljs-keyword">try</span> pug.move(.left)
  <span class="hljs-keyword">try</span> pug.move(.forward)
  <span class="hljs-keyword">try</span> pug.move(.right)
}

<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> goHome()
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"PugBot failed to get home."</span>)
}</pre>
<p class="calibre1">Every single command in <code class="calibre9">goHome()</code> must pass for the method to complete successfully. The moment an error is thrown, your <code class="calibre9">PugBot</code> will stop trying to get home and will stay put until you come and rescue it.
</p>
<h3 class="segment-title2">Handling multiple errors</h3>

<p class="calibre1">Since you’re a savvy developer, you’ve noticed that you’re not handling errors in <code class="calibre9">goHome()</code>. Instead, it just passes the error up to the caller.
</p>
<p class="calibre1">You might benefit from a function that can move the <code class="calibre9">PugBot</code> and handle errors by reporting what went wrong in a <code class="calibre9">String</code>.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">moveSafely</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">movement</span>: () <span class="hljs-keyword">throws</span> -&gt; ()) -&gt; <span class="hljs-built_in">String</span> {
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> movement()
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Completed operation successfully."</span>
  } <span class="hljs-keyword">catch</span> <span class="hljs-built_in">PugBotError</span>.invalidMove(<span class="hljs-keyword">let</span> found, <span class="hljs-keyword">let</span> expected) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"The PugBot was supposed to move <span class="hljs-subst">\(expected)</span>, 
            but moved <span class="hljs-subst">\(found)</span> instead."</span>
  } <span class="hljs-keyword">catch</span> <span class="hljs-built_in">PugBotError</span>.endOfPath {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"The PugBot tried to move past the end of the path."</span>
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"An unknown error occurred."</span>
  }
}</pre>
<p class="calibre1">This function takes a movement function (like <code class="calibre9">goHome()</code>) or a closure containing movement function calls and handles any errors thrown.
</p>
<p class="calibre1">You might notice that you have to add a default case to the end. What gives? You’ve exhausted the cases in your <code class="calibre9">PugBotError</code> enum, so why is the compiler hassling you?
</p>
<p class="calibre1">Unfortunately, at this point, Swift’s <code class="calibre9">do</code>-<code class="calibre9">try</code>-<code class="calibre9">catch</code> system isn’t type-specific. There’s no way to tell the compiler that it should only expect <code class="calibre9">PugBotError</code>s. To the compiler, that isn’t exhaustive because it doesn’t handle every possible error that it knows about, so you still need a default case. Now you can use your function to handle movement safely:
</p><pre class="code-block">pug.reset()
moveSafely(goHome)

pug.reset()
moveSafely {
  <span class="hljs-keyword">try</span> pug.move(.forward)
  <span class="hljs-keyword">try</span> pug.move(.left)
  <span class="hljs-keyword">try</span> pug.move(.forward)
  <span class="hljs-keyword">try</span> pug.move(.right)
}</pre>
<p class="calibre1">Thanks to trailing closure syntax, your movement calls are cleanly wrapped in the call to <code class="calibre9">moveSafely(_:)</code>. Here, your <code class="calibre9">PugBot</code> will find her way home safely.
</p><div class="image13"><img src="images/000076.png" alt="" title="" class="calibre7" /></div>
<h2 class="segment-chapter1">Rethrows</h2>

<p class="calibre1">A function that takes a throwing closure as a parameter has to choose: either catch every error or be a throwing function. Let’s say you want a utility function to perform a certain movement or set of movements several times in a row.
</p>
<p class="calibre1">You could define this function as follows:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">perform</span>(<span class="hljs-built_in">times</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">movement</span>: () <span class="hljs-keyword">throws</span> -&gt; ()) <span class="hljs-keyword">rethrows</span> {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>times {
    <span class="hljs-keyword">try</span> movement()
  }
}</pre>
<p class="calibre1">Notice the <code class="calibre9">rethrows</code> here. This function does not handle errors like <code class="calibre9">moveSafely(_:)</code>. Instead, it leaves error handling to the function’s caller, such as <code class="calibre9">goHome()</code>.  The above function uses <code class="calibre9">rethrows</code> to indicate that it will only rethrow errors thrown by the closure passed into it, and it will never throw errors of its own.
</p>
<h2 class="segment-chapter1">Throwable properties</h2>

<p class="calibre1">You can throw errors from <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">only</em> computed properties:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">age</span>: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age
  }
}

<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">enum</span> <span class="hljs-number">PersonError</span>: <span class="hljs-number">Error</span> {
  <span class="hljs-keyword">case</span> noName, noAge, noData
}

<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">extension</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">var</span> data: <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">get</span> <span class="hljs-keyword">throws</span> {
      <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>name.isEmpty <span class="hljs-keyword">else</span> {<span class="hljs-keyword">throw</span> <span class="hljs-built_in">PersonError</span>.noName}
      <span class="hljs-keyword">guard</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> {<span class="hljs-keyword">throw</span> <span class="hljs-built_in">PersonError</span>.noAge}
      <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">\(name)</span> is <span class="hljs-subst">\(age)</span> years old."</span>
    }
  }
}</pre>
<p class="calibre1">Here is what happens in the code:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Define a <code class="calibre9">Person</code> class with <code class="calibre9">name</code> and <code class="calibre9">age</code> properties.
</p></li>

<li class="calibre4">
<p class="calibre1">Declare a <code class="calibre9">PersonError</code> enumeration with specific <code class="calibre9">Person</code> errors.
</p></li>

<li class="calibre4">
<p class="calibre1">Define a read-only computed property that returns custom <code class="calibre9">Person</code> data and throws errors if either <code class="calibre9">name</code> or <code class="calibre9">age</code> has an invalid value.
</p></li>
</ol>

<p class="calibre1">Time to see your throwable property in action:
</p><pre class="code-block"><span class="hljs-keyword">let</span> me <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(name: <span class="hljs-string">"Cosmin"</span>, age: <span class="hljs-number">36</span>)

me.name <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me.data
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error) <span class="hljs-comment">// "noName"</span>
}

me.age <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">36</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me.data
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error) <span class="hljs-comment">// "noName"</span>
}

me.name <span class="hljs-operator">=</span> <span class="hljs-string">"Cosmin"</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me.data
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error) <span class="hljs-comment">// "noAge"</span>
}

me.age <span class="hljs-operator">=</span> <span class="hljs-number">36</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me.data <span class="hljs-comment">// "Cosmin is 36 years old."</span>
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error)
}</pre>
<p class="calibre1">It works for all possible cases - way to go!
</p>
<h2 class="segment-chapter1">Throwable subscripts</h2>

<p class="calibre1">You can also throw errors from <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">only</em> subscripts:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">get</span> <span class="hljs-keyword">throws</span> {
      <span class="hljs-keyword">switch</span> key {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>: <span class="hljs-keyword">return</span> name
        <span class="hljs-keyword">case</span> <span class="hljs-string">"age"</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">\(age)</span>"</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-built_in">PersonError</span>.noData
      }
    }
  }
}</pre>
<p class="calibre1">The above read-only subscript returns either the person’s name or age and throws errors for invalid keys. Go ahead and try it out:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me[<span class="hljs-string">"name"</span>] <span class="hljs-comment">// "Cosmin"</span>
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error)
}

<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me[<span class="hljs-string">"age"</span>] <span class="hljs-comment">// "36"</span>
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error)
}

<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">try</span> me[<span class="hljs-string">"gender"</span>] 
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-built_in">print</span>(error) <span class="hljs-comment">// "noData"</span>
}</pre>
<p class="calibre1">It works for all possible scenarios - really cool!
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your error handling knowledge. It’s best to try and solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Even strings</h3>

<p class="calibre1">Write a throwing function that converts a <code class="calibre9">String</code> to an even number, rounding down if necessary.
</p>
<h3 class="segment-title2">Challenge 2: Safe division</h3>

<p class="calibre1">Write a throwing function that divides type Int types.
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A type can conform to the <em class="calibre5">Error</em> protocol to work with Swift’s error-handling system.
</p></li>

<li class="calibre4">
<p class="calibre1">Any function that can throw an error, or call a function that can throw an error, has to be marked with <em class="calibre5">throws</em> or <em class="calibre5">rethrows</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">When calling an error-throwing function, you must embed the function call in a <code class="calibre9"><em class="calibre13">do</em></code> block. Within that block, you <code class="calibre9"><em class="calibre13">try</em></code> the function, and if it fails, you <code class="calibre9"><em class="calibre13">catch</em></code> the error.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Read</em><em class="calibre5">-</em><em class="calibre5">only</em> computed properties and subscripts can throw errors.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-27">


<h1 class="segment-chapter">Chapter 23: Encoding &amp; Decoding Types</h1>

<p class="calibre1">There are several scenarios where you’ll need to save data to a file or send it over the network. This chapter will teach you how to convert types like an <code class="calibre9">Employee</code> to a  stream of bytes ready to be transported. This process is called encoding, also known as <em class="calibre5">serialization</em>.
</p>
<p class="calibre1">The reverse process of turning the data into an instance is called decoding, or <em class="calibre5">deserialization</em>.
</p>
<p class="calibre1">Imagine you have an instance you want to write to a file. The instance itself cannot be written as-is to the file, so you need to encode it into another representation, such as a stream of bytes:
</p><div class="image1"><img src="images/000097.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Once the data is encoded and saved to a file, you can turn it back into an instance whenever you want by using a decoder:
</p><div class="image1"><img src="images/000109.png" alt="" title="" class="calibre7" /></div>
<h2 class="segment-chapter1">Encodable and Decodable protocols</h2>

<p class="calibre1">The <code class="calibre9">Encodable</code> protocol expresses that a type can convert itself into another representation. It declares a single method:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">encode</span>(<span class="hljs-built_in">to</span>: <span class="hljs-built_in">Encoder</span>) <span class="hljs-keyword">throws</span></pre>
<p class="calibre1">The compiler automatically generates this for you if all the stored properties of that type conform to <code class="calibre9">Encodable</code>. You’ll learn more about this later on in the chapter.
</p>
<p class="calibre1">The <code class="calibre9">Decodable</code> protocol expresses that a type can create itself from another representation. It declares just a single initializer:
</p><pre class="code-block"><span class="hljs-keyword">init</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">decoder</span>: <span class="hljs-built_in">Decoder</span>) <span class="hljs-keyword">throws</span></pre>
<p class="calibre1">Again, the compiler will make this initializer for you if all stored properties conform to <code class="calibre9">Decodable</code>. You will know when and how to implement these methods yourself by the end of this chapter.
</p>
<h2 class="segment-chapter1">What is <code class="calibre12">Codable</code>?</h2>

<p class="calibre1"><code class="calibre9">Codable</code> is a protocol that a type can conform to, which means it can be encoded and decoded. It’s an alias for the <code class="calibre9">Encodable</code> and <code class="calibre9">Decodable</code> protocols. Literally:
</p><pre class="code-block">  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">Codable</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Encodable</span> &amp; <span class="hljs-built_in">Decodable</span></pre>
<h2 class="segment-chapter1">Automatic encoding and decoding</h2>

<p class="calibre1">Many of Swift’s types are codable out of the box: <code class="calibre9">Int</code>, <code class="calibre9">String</code>, <code class="calibre9">Date</code>, <code class="calibre9">Array</code> and many other types from the Standard Library and the Foundation framework. If you want your type to be codable, the simplest way to do it is by conforming to <code class="calibre9">Codable</code> and ensuring all its stored properties are also codable.
</p>
<p class="calibre1">For example, let’s say you own a toy factory, and you have this struct to store employee data:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Employee</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Int</span>
}</pre>
<p class="calibre1">All you need to do to be able to encode and decode this type to conform to the <code class="calibre9">Codable</code> protocol, like so:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Codable</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Int</span>
}</pre>
<p class="calibre1">Wow, that was easy. You could do it because both <code class="calibre9">name</code> (<code class="calibre9">String</code>) and <code class="calibre9">id</code> (<code class="calibre9">Int</code>) are codable.
</p>
<p class="calibre1">This automatic process works when you’re only using types that are already <code class="calibre9">Codable</code>. But what if your type includes other custom types as properties? For example, looking at your <code class="calibre9">Employee</code> struct, assume that it also has an optional <code class="calibre9">favoriteToy</code> property:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Codable</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> favoriteToy: <span class="hljs-built_in">Toy</span>?
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">Toy</span>: <span class="hljs-number">Codable</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">By making sure <code class="calibre9">Toy</code> also conforms to <code class="calibre9">Codable</code>, you maintain the overall conformance to <code class="calibre9">Codable</code> for <code class="calibre9">Employee</code> as well.
</p>
<p class="calibre1">All collections types, like <code class="calibre9">Array</code> and <code class="calibre9">Dictionary</code> are also codable if they contain codable types.
</p>
<h2 class="segment-chapter1">Encoding and decoding custom types</h2>

<p class="calibre1">You can encode to or decode from several representations, such as XML or a Property List. This section will show you how to encode to and decode from JSON by using Swift’s <code class="calibre9">JSONEncoder</code> and <code class="calibre9">JSONDecoder</code> classes.
</p>
<p class="calibre1">JSON stands for JavaScript Object Notation and is one of the most popular ways to serialize data. It’s easily readable by humans and easy for computers to parse and generate.
</p>
<p class="calibre1">For example, if you were to encode an instance of type <code class="calibre9">Employee</code> to JSON, it might look something like this:
</p><pre class="code-block">{ "name": "John Appleseed", "id": 7 }</pre>
<p class="calibre1">The conversion between an <code class="calibre9">Employee</code> type and serialized JSON is almost trivial.
</p>
<h3 class="segment-title2">JSONEncoder and JSONDecoder</h3>

<p class="calibre1">Once you have a codable type, you can use <code class="calibre9">JSONEncoder</code> to convert your type to <code class="calibre9">Data</code> that can be either written to a file or sent over the network. Assume you have this employee instance:
</p><pre class="code-block"><span class="hljs-keyword">let</span> toy1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Toy</span>(name: <span class="hljs-string">"Teddy Bear"</span>);
<span class="hljs-keyword">let</span> employee1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Employee</span>(name: <span class="hljs-string">"John Appleseed"</span>, id: <span class="hljs-number">7</span>, favoriteToy: toy1)</pre>
<p class="calibre1">John’s birthday is coming up, and you want to give him his favorite toy as a gift. You need to send this data to the gift department. Before you can do that, you need to encode it, like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> jsonEncoder <span class="hljs-operator">=</span> <span class="hljs-built_in">JSONEncoder</span>()
<span class="hljs-keyword">let</span> jsonData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> jsonEncoder.encode(employee1)</pre>
<p class="calibre1">You’ll notice that you need to use <code class="calibre9">try</code> because <code class="calibre9">encode(_:)</code> might fail and throw an error.
</p>
<p class="calibre1">If you try to print <code class="calibre9">jsonData</code> like this:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(jsonData)</pre>
<p class="calibre1">You’ll see that Xcode omits the data and only provides the number of bytes in <code class="calibre9">jsonData</code>. This is fine, because <code class="calibre9">jsonData</code> contains an unreadable representation of <code class="calibre9">employee1</code>. If you would like to create a readable version of this JSON as a string, you can use  the<code class="calibre9">String</code> initializer:
</p><pre class="code-block"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span>(data: jsonData, encoding: .utf8)<span class="hljs-operator">!</span>
<span class="hljs-built_in">print</span>(jsonString)
<span class="hljs-comment">// {"name":"John Appleseed","id":7,"favoriteToy":{"name":"Teddy Bear"}}</span></pre>
<p class="calibre1">Now you can send <code class="calibre9">jsonData</code> or <code class="calibre9">jsonString</code> over to the gift department using their special gift API.
</p>
<p class="calibre1">If you want to decode the JSON data back into an instance, you need to use <code class="calibre9">JSONDecoder</code>:
</p><pre class="code-block"><span class="hljs-keyword">let</span> jsonDecoder <span class="hljs-operator">=</span> <span class="hljs-built_in">JSONDecoder</span>()
<span class="hljs-keyword">let</span> employee2 <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> jsonDecoder.decode(<span class="hljs-built_in">Employee</span>.<span class="hljs-keyword">self</span>, from: jsonData)</pre>
<p class="calibre1">Note that you need to tell the decoder what type to decode with <code class="calibre9">Employee.self</code>.
</p>
<p class="calibre1">By design, you specify the type at compile-time as it prevents a security vulnerability where someone on the outside might try to inject a type you weren’t expecting. It also plays well with Swift’s natural preference for static types.
</p>
<h2 class="segment-chapter1">Renaming properties with CodingKeys</h2>

<p class="calibre1">It turns out that the gifts department API requires that the employee ID appear as <code class="calibre9">employeeId</code> instead of <code class="calibre9">id</code>. Luckily, Swift provides a solution to this kind of problem.
</p>
<h3 class="segment-title2">CodingKey protocol and CodingKeys enum</h3>

<p class="calibre1">The <code class="calibre9">CodingKeys</code> enum, which conforms to the <code class="calibre9">CodingKey</code> protocol, lets you rename specific properties if the serialized format doesn’t match the API requirements.
</p>
<p class="calibre1">Add the nested enumeration <code class="calibre9">CodingKeys</code> like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Codable</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> favoriteToy: <span class="hljs-built_in">Toy</span>?

  <span class="hljs-keyword">enum</span> <span class="hljs-number">CodingKeys</span>: <span class="hljs-number">String</span>, <span class="hljs-number">CodingKey</span> {
    <span class="hljs-keyword">case</span> id <span class="hljs-operator">=</span> <span class="hljs-string">"employeeId"</span>
    <span class="hljs-keyword">case</span> name
    <span class="hljs-keyword">case</span> favoriteToy
  }
}</pre>
<p class="calibre1">There are several things to note here:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">CodingKeys</code> is a nested enumeration in your type.
</p></li>

<li class="calibre4">
<p class="calibre1">It has to conform to <code class="calibre9">CodingKey</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">You also need <code class="calibre9">String</code> as the raw type since the keys must be strings or integers.
</p></li>

<li class="calibre4">
<p class="calibre1">You have to include all properties in the enumeration, even if you don’t plan to rename them.
</p></li>

<li class="calibre4">
<p class="calibre1">By default, the compiler creates this enumeration, but when you need to rename a key, you need to implement it yourself.
</p></li>
</ol>

<p class="calibre1">Now, if you print the JSON, you’ll see that <code class="calibre9">id</code> has changed to <code class="calibre9">employeeId</code>.
</p><pre class="code-block">{ "employeeId": 7, "name": "John Appleseed", "favoriteToy": {"name": "Teddy Bear"}}</pre>
<h2 class="segment-chapter1">Manual encoding and decoding</h2>

<p class="calibre1">You try to send the data over to the gifts department, and again the data gets rejected. This time they claim that the information of the gift you want to send to the employee should not be inside a nested type, but rather as a property called <code class="calibre9">gift</code>. So the JSON should look like this:
</p><pre class="code-block">{ "employeeId": 7, "name": "John Appleseed", "gift": "Teddy Bear" }</pre>
<p class="calibre1">In this case, you can’t use <code class="calibre9">CodingKeys</code> since you need to alter the structure of the JSON and not just rename properties. You need to write your own encoding and decoding logic.
</p>
<h3 class="segment-title2">The encode function</h3>

<p class="calibre1">As mentioned earlier in the chapter, <code class="calibre9">Codable</code> is just a typealias for the <code class="calibre9">Encodable</code> and <code class="calibre9">Decodable</code> protocols. You need to implement <code class="calibre9">encode(to: Encoder)</code> and describe how to encode each property.
</p>
<p class="calibre1">It might sound complicated, but it’s pretty simple. First, update <code class="calibre9">CodingKeys</code> to use the key <code class="calibre9">gift</code> instead of <code class="calibre9">favoriteToy</code>:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">CodingKeys</span>: <span class="hljs-number">String</span>, <span class="hljs-number">CodingKey</span> {
  <span class="hljs-keyword">case</span> id <span class="hljs-operator">=</span> <span class="hljs-string">"employeeId"</span>
  <span class="hljs-keyword">case</span> name
  <span class="hljs-keyword">case</span> gift
}</pre>
<p class="calibre1">Then, you need to remove <code class="calibre9">Employee</code>’s conformance to <code class="calibre9">Codable</code> and add this extension:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Encodable</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">encode</span>(<span class="hljs-built_in">to</span> <span class="hljs-built_in">encoder</span>: <span class="hljs-built_in">Encoder</span>) <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> encoder.container(keyedBy: <span class="hljs-built_in">CodingKeys</span>.<span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">try</span> container.encode(name, forKey: .name)
    <span class="hljs-keyword">try</span> container.encode(id, forKey: .id)
    <span class="hljs-keyword">try</span> container.encode(favoriteToy<span class="hljs-operator">?</span>.name, forKey: .gift)
  }
}</pre>
<p class="calibre1">First, you get the <code class="calibre9">container</code> of the encoder back, giving you a view into the encoder’s storage that you can access with keys. Note how you choose which properties to encode for which keys. Importantly, you flatten <code class="calibre9">favoriteToy?.name</code> down to the <code class="calibre9">.gift</code> key. If you stop now, you’ll get the following error:
</p><pre class="code-block">'Employee' does not conform to expected type 'Decodable'</pre>
<p class="calibre1">This error is because you removed the conformance to <code class="calibre9">Codable</code> and only added conformance to <code class="calibre9">Encodable</code>. For now, you can comment out the code that decodes <code class="calibre9">jsonString</code> to <code class="calibre9">employee2</code>. If you print <code class="calibre9">jsonString</code> once more, this is what you’ll get:
</p><pre class="code-block">{"name":"John Appleseed","gift":"Teddy Bear","employeeId":7}</pre>
<h3 class="segment-title2">The decode function</h3>

<p class="calibre1">Once the data arrives at the gift department, it needs to be converted to an instance in the department’s system. Clearly, the gift department needs a decoder. Add the following code to your playground to make <code class="calibre9">Employee</code> conform to <code class="calibre9">Decodable</code>, and thus also <code class="calibre9">Codable</code>:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Decodable</span> {
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">decoder</span>: <span class="hljs-built_in">Decoder</span>) <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">let</span> values <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-built_in">CodingKeys</span>.<span class="hljs-keyword">self</span>)
    name <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decode(<span class="hljs-built_in">String</span>.<span class="hljs-keyword">self</span>, forKey: .name)
    id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decode(<span class="hljs-built_in">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> gift <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decode(<span class="hljs-built_in">String</span>?.<span class="hljs-keyword">self</span>, forKey: .gift) {
      favoriteToy <span class="hljs-operator">=</span> <span class="hljs-built_in">Toy</span>(name: gift)
    }
  }
}</pre>
<p class="calibre1">Here you’re pretty much doing the opposite of what you did in the <code class="calibre9">encode</code> method using the decoder’s keyed storage container.
</p>
<h3 class="segment-title2">encodeIfPresent and decodeIfPresent</h3>

<p class="calibre1">It turns out not all employees have a favorite toy. In this case, the <code class="calibre9">encode</code> method will create a JSON that looks like this:
</p><pre class="code-block">{"name":"John Appleseed","gift":null,"employeeId":7}</pre>
<p class="calibre1">In order to fix this, you can use <code class="calibre9">encodeIfPresent</code> so the <code class="calibre9">encode</code> method will look like this:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Encodable</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">encode</span>(<span class="hljs-built_in">to</span> <span class="hljs-built_in">encoder</span>: <span class="hljs-built_in">Encoder</span>) <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> encoder.container(keyedBy: <span class="hljs-built_in">CodingKeys</span>.<span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">try</span> container.encode(name, forKey: .name)
    <span class="hljs-keyword">try</span> container.encode(id, forKey: .id)
    <span class="hljs-keyword">try</span> container.encodeIfPresent(favoriteToy<span class="hljs-operator">?</span>.name, forKey: .gift)
  }
}</pre>
<p class="calibre1">With this change, the JSON won’t contain a <code class="calibre9">gift</code> key if the employee doesn’t have a favorite toy.
</p>
<p class="calibre1">Next, update the decoder using <code class="calibre9">decodeIfPresent</code>:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Employee</span>: <span class="hljs-number">Decodable</span> {
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">from</span> <span class="hljs-built_in">decoder</span>: <span class="hljs-built_in">Decoder</span>) <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">let</span> values <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-built_in">CodingKeys</span>.<span class="hljs-keyword">self</span>)
    name <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decode(<span class="hljs-built_in">String</span>.<span class="hljs-keyword">self</span>, forKey: .name)
    id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decode(<span class="hljs-built_in">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> gift <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> values.decodeIfPresent(<span class="hljs-built_in">String</span>.<span class="hljs-keyword">self</span>, forKey: .gift) {
      favoriteToy <span class="hljs-operator">=</span> <span class="hljs-built_in">Toy</span>(name: gift)
    }
  }
}</pre>
<h2 class="segment-chapter1">Writing tests for the Encoder and Decoder</h2>

<p class="calibre1">If you change your encoder and forget to update the decoder (or vice versa), you might get nasty errors at runtime. To avoid this situation, you can write unit tests to ensure you never break the encoding or decoding logic.
</p>
<p class="calibre1">To do that, you first need to import the XCTest framework. Add this at the top of the playground:
</p><pre class="code-block"><span class="hljs-keyword">import</span> XCTest</pre>
<p class="calibre1">Then you should add a test class and implement the <code class="calibre9">setUp</code> method to initialize a <code class="calibre9">JSONEncoder</code> and <code class="calibre9">JSONDecoder</code>. Also, initialize one <code class="calibre9">Toy</code> and one <code class="calibre9">Employee</code> instance, so you have them ready to use.
</p>
<p class="calibre1">Add this at the end of the playground:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">EncoderDecoderTests</span>: <span class="hljs-number">XCTestCase</span> {
  <span class="hljs-keyword">var</span> jsonEncoder: <span class="hljs-built_in">JSONEncoder</span>!
  <span class="hljs-keyword">var</span> jsonDecoder: <span class="hljs-built_in">JSONDecoder</span>!
  <span class="hljs-keyword">var</span> toy1: <span class="hljs-built_in">Toy</span>!
  <span class="hljs-keyword">var</span> employee1: <span class="hljs-built_in">Employee</span>!

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-number">setUp</span>() {
    <span class="hljs-keyword">super</span>.setUp()
    jsonEncoder <span class="hljs-operator">=</span> <span class="hljs-built_in">JSONEncoder</span>()
    jsonDecoder <span class="hljs-operator">=</span> <span class="hljs-built_in">JSONDecoder</span>()
    toy1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Toy</span>(name: <span class="hljs-string">"Teddy Bear"</span>)
    employee1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Employee</span>(name: <span class="hljs-string">"John Appleseed"</span>, id: <span class="hljs-number">7</span>,
                         favoriteToy: toy1)
  }
}</pre>
<p class="calibre1">The next step is to add the tests themselves. Remember that all tests have to start with <code class="calibre9">test</code>.
</p>
<p class="calibre1">Add this inside the class <code class="calibre9">EncoderDecoderTests</code>. The contents of the methods should look familiar since it’s mostly a copy of what you previously wrote when you learned how to use encoders and decoders.
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">testEncoder</span>() {
  <span class="hljs-keyword">let</span> jsonData <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> jsonEncoder.encode(employee1)
  <span class="hljs-built_in">XCTAssertNotNil</span>(jsonData, <span class="hljs-string">"Encoding failed"</span>)
  
  <span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span>(data: jsonData<span class="hljs-operator">!</span>, encoding: .utf8)<span class="hljs-operator">!</span>
  <span class="hljs-built_in">XCTAssertEqual</span>(jsonString, <span class="hljs-string">"{<span class="hljs-subst">\"</span>name<span class="hljs-subst">\"</span>:<span class="hljs-subst">\"</span>John Appleseed<span class="hljs-subst">\"</span>,<span class="hljs-subst">\"</span>gift<span class="hljs-subst">\"</span>:<span class="hljs-subst">\"</span>Teddy Bear<span class="hljs-subst">\"</span>,<span class="hljs-subst">\"</span>employeeId<span class="hljs-subst">\"</span>:7}"</span>)
}

<span class="hljs-keyword">func</span> <span class="hljs-number">testDecoder</span>() {
  <span class="hljs-keyword">let</span> jsonData <span class="hljs-operator">=</span> <span class="hljs-keyword">try!</span> jsonEncoder.encode(employee1)
  <span class="hljs-keyword">let</span> employee2 <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> jsonDecoder.decode(<span class="hljs-built_in">Employee</span>.<span class="hljs-keyword">self</span>, from: jsonData)
  <span class="hljs-built_in">XCTAssertNotNil</span>(employee2)
  
  <span class="hljs-built_in">XCTAssertEqual</span>(employee1.name, employee2<span class="hljs-operator">!</span>.name)
  <span class="hljs-built_in">XCTAssertEqual</span>(employee1.id, employee2<span class="hljs-operator">!</span>.id)
  <span class="hljs-built_in">XCTAssertEqual</span>(employee1.favoriteToy<span class="hljs-operator">?</span>.name,
                 employee2<span class="hljs-operator">!</span>.favoriteToy<span class="hljs-operator">?</span>.name)
}</pre>
<p class="calibre1">The most important thing here is the usage of <code class="calibre9">XCTAssert</code> methods. They guarantee the logic is correct and that your encoder and decoder are working correctly.
</p>
<p class="calibre1">There’s only one thing missing to start using the tests. As explained in Chapter 18, for the playground to run the tests, add this at the end of the playground:
</p><pre class="code-block"><span class="hljs-built_in">EncoderDecoderTests</span>.defaultTestSuite.run()</pre>
<p class="calibre1">Once you run the playground, you should see something similar to this:
</p><pre class="code-block">Test Suite 'EncoderDecoderTests' started at ...
Test Case '-[__lldb_expr_2.EncoderDecoderTests testDecoder]' started.
Test Case '-[__lldb_expr_2.EncoderDecoderTests testDecoder]' passed (0.781 seconds).
Test Case '-[__lldb_expr_2.EncoderDecoderTests testEncoder]' started.
Test Case '-[__lldb_expr_2.EncoderDecoderTests testEncoder]' passed (0.004 seconds).
Test Suite 'EncoderDecoderTests' passed at ...
   Executed 2 tests, with 0 failures (0 unexpected) in 0.785 (0.788) seconds</pre>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of encoding, decoding and serialization. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Spaceship</h3>

<p class="calibre1">Given the structures below, make the necessary modifications to make <code class="calibre9">Spaceship</code> codable:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Spaceship</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> crew: [<span class="hljs-built_in">CrewMember</span>]
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">CrewMember</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> race: <span class="hljs-built_in">String</span>
}</pre>
<h3 class="segment-title2">Challenge 2: Custom keys</h3>

<p class="calibre1">It appears that the spaceship’s interface is different than that of the outpost on Mars. The Mars outpost expects to get the spaceship’s name as <em class="calibre5">spaceship</em><em class="calibre5">_</em><em class="calibre5">name</em>. Make the necessary modifications so that encoding the structure would return the JSON in the correct format.
</p>
<h3 class="segment-title2">Challenge 3: Write a decoder</h3>

<p class="calibre1">You received a transmission from planet Earth about a new spaceship. Write a custom decoder to convert this JSON into a <code class="calibre9">Spaceship</code>. This is the incoming transmission:
</p><pre class="code-block">{"spaceship_name":"USS Enterprise", "captain":{"name":"Spock", "race":"Human"}, "officer":{"name": "Worf", "race":"Klingon"}}</pre>
<p class="calibre1">Hint: There are no ranks in your type, just an array of crew members, so you’ll need to use different keys for encoding and decoding.
</p>
<h3 class="segment-title2">Challenge 4: Decoding property lists</h3>

<p class="calibre1">You intercepted some weird transmissions from the Klingon, which you can’t decode. Your scientists deduced that these transmissions are encoded with a <code class="calibre9">PropertyListEncoder</code> and that they’re also information about spaceships. Try your luck with decoding this message:
</p><pre class="code-block"><span class="hljs-keyword">var</span> klingonSpaceship <span class="hljs-operator">=</span> <span class="hljs-built_in">Spaceship</span>(name: <span class="hljs-string">"IKS NEGH’VAR"</span>, crew: [])
<span class="hljs-keyword">let</span> klingonMessage <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-built_in">PropertyListEncoder</span>().encode(klingonSpaceship)</pre>
<h2 class="segment-chapter1">Challenge 5: Enumeration with associated values</h2>

<p class="calibre1">The compiler can (as of Swift 5.5) automatically generate codable for enumerations with associated values. Check out how it works by encoding and printing out the following list of items.
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">Item</span> {
  <span class="hljs-keyword">case</span> message(<span class="hljs-built_in">String</span>)
  <span class="hljs-keyword">case</span> numbers([<span class="hljs-built_in">Int</span>])
  <span class="hljs-keyword">case</span> mixed(<span class="hljs-built_in">String</span>, [<span class="hljs-built_in">Int</span>])
  <span class="hljs-keyword">case</span> person(name: <span class="hljs-built_in">String</span>)
}

<span class="hljs-keyword">let</span> items: [<span class="hljs-built_in">Item</span>] <span class="hljs-operator">=</span> [.message(<span class="hljs-string">"Hi"</span>),
                     .mixed(<span class="hljs-string">"Things"</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]),
                     .person(name: <span class="hljs-string">"Kirk"</span>),
                     .message(<span class="hljs-string">"Bye"</span>)]</pre>
<h2 class="segment-chapter1">Key points</h2>

<p class="calibre1">Codable is a powerful tool for saving and loading types. Here are some important takeaways:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You need to encode (or <em class="calibre5">serialize</em>) an instance before you can save it to a file or send it over the web.
</p></li>

<li class="calibre4">
<p class="calibre1">You need to decode (or <em class="calibre5">deserialize</em>) to bring it back from a file or the web as an instance.
</p></li>

<li class="calibre4">
<p class="calibre1">Your type should conform to the <code class="calibre9">Codable</code> protocol to support encoding and decoding.
</p></li>

<li class="calibre4">
<p class="calibre1">If all stored properties of your type are <code class="calibre9">Codable</code>, then the compiler can automatically implement the requirements of <code class="calibre9">Codable</code> for you.
</p></li>

<li class="calibre4">
<p class="calibre1">JSON is the most common encoding in modern applications and web services, and you can use <code class="calibre9">JSONEncoder</code> and <code class="calibre9">JSONDecoder</code> to encode and decode your types to and from JSON.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">Codable</code> is very flexible and can be customized to handle almost any valid JSON.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">Codable</code> supports serialization formats beyond JSON.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-40">


<h1 class="segment-chapter">Chapter 24: Memory Management</h1>

<p class="calibre1">In Chapter 14, “Advanced Classes,” you explored elementary memory management when examining the class lifetime and <em class="calibre5">automatic reference counting</em> (ARC). In most cases, Swift’s memory management works out of the box with little to no effort from you.
</p>
<p class="calibre1">However, there are cases when ARC can’t infer the proper relationships between objects. That’s where you come in.
</p>
<p class="calibre1">In this chapter, you’ll revisit the concept of <em class="calibre5">reference cycles</em> and learn about resolving them for classes and closures. You’ll also learn to use <em class="calibre5">capture lists</em> in closures to capture values from the enclosing scope. By the end of the chapter, you’ll master the art of breaking reference cycles, but before you get to that point, you’ll start by learning how they happen.
</p>
<h2 class="segment-chapter1">Reference cycles for classes</h2>

<p class="calibre1">Two class instances that hold a <em class="calibre5">strong reference</em> to each other create a <em class="calibre5">strong reference cycle</em> that leads to a <em class="calibre5">memory leak</em>. That’s because each instance keeps the other one alive, so their reference counts never reach zero.
</p>
<p class="calibre1">For example, our website has a mountain of top-notch programming tutorials, most of which are scrutinized by an editor before you see them. You can model these tutorials with the following class:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Tutorial</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> editor: <span class="hljs-built_in">Editor</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye tutorial <span class="hljs-subst">\(title)</span>!"</span>)
  }
}</pre>
<p class="calibre1">In addition to a <code class="calibre9">title</code> property, a tutorial might have an editor, so it’s an optional. Recall that when the reference count drops to zero, Swift automatically calls the <em class="calibre5">deinitializer</em> and releases the object from memory.
</p>
<p class="calibre1">Now that you’ve defined an editor for each tutorial, you need to declare an <code class="calibre9">Editor</code> class, like so:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Editor</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> tutorials: [<span class="hljs-built_in">Tutorial</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye editor <span class="hljs-subst">\(name)</span>!"</span>)
  }
}</pre>
<p class="calibre1">Each editor has a name and a list of tutorials they have edited. The <code class="calibre9">tutorials</code> property is an array so that you can add to it.
</p>
<p class="calibre1">Now define a brand new tutorial for publishing and an editor to ensure it meets our high standards:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> tutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Memory management"</span>)
  <span class="hljs-keyword">let</span> editor <span class="hljs-operator">=</span> <span class="hljs-built_in">Editor</span>(name: <span class="hljs-string">"Ray"</span>)
}</pre>
<p class="calibre1">Each example uses a <code class="calibre9">do {}</code> scope to force the references inside them to decrement and, hopefully, deallocate. This way, you can see everything is working.
</p>
<p class="calibre1">Something happens when you instead make a relationship between the two objects, like this:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> tutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Memory management"</span>)
  <span class="hljs-keyword">let</span> editor <span class="hljs-operator">=</span> <span class="hljs-built_in">Editor</span>(name: <span class="hljs-string">"Ray"</span>)
  tutorial.editor <span class="hljs-operator">=</span> editor
  editor.tutorials.append(tutorial)
}</pre>
<p class="calibre1">Although both objects go out of scope, deinitializers aren’t called, and nothing prints to the console &mdash; bummer! That’s because you’ve just created a reference cycle between the tutorial and its corresponding editor. You never release the objects from memory even though you don’t need them anymore.
</p>
<p class="calibre1">Now that you understand how reference cycles happen, you can break them. Weak references to the rescue!
</p>
<h3 class="segment-title2">Weak references</h3>

<p class="calibre1"><em class="calibre5">Weak references</em> are references that don’t play any role in the <em class="calibre5">ownership</em> of an object. The great thing about using them is that they automatically detect when the underlying object has gone away. This automatic detection is why you <i class="calibre2">always</i> declare them with an optional type. They become <code class="calibre9">nil</code> once the reference count reaches zero.
</p>
<p class="calibre1">A tutorial doesn’t always have an editor assigned, so it makes sense to model it as an optional type. Also, a tutorial doesn’t own the editor, so it makes perfect sense to make it a weak reference. Change the property’s declaration in the <code class="calibre9">Tutorial</code> class to the following:
</p><pre class="code-block"><span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> editor: <span class="hljs-built_in">Editor</span>?</pre>
<p class="calibre1">You break the reference cycle with the <code class="calibre9">weak</code> keyword.
</p>
<p class="calibre1">Both deinitializers now run and print the following output to the console:
</p><pre class="code-block">Goodbye editor Ray!
Goodbye tutorial Memory management!</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You can’t define a weak reference as constant because it will change to <code class="calibre9">nil</code> during runtime when the underlying object goes away.
</p></div>

<h3 class="segment-title2">Unowned references</h3>

<p class="calibre1">You have another means to break reference cycles: <em class="calibre5">Unowned references</em>, which behave much like weak ones in that they don’t change the object’s reference count.
</p>
<p class="calibre1">However, unlike weak references, they <em class="calibre5">always</em> expect to have a value &mdash; you can’t declare them as optionals. Think of it this way: A tutorial cannot exist without an author. Somebody has to write words for the editor to redline. :] At the same time, a tutorial does not “own” the author, so the reference should be unowned.
</p>
<p class="calibre1">Modify the <code class="calibre9">Tutorial</code> class as shown below:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Tutorial</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">Author</span>  
  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> editor: <span class="hljs-built_in">Editor</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">author</span>: <span class="hljs-built_in">Author</span>) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
    <span class="hljs-keyword">self</span>.author <span class="hljs-operator">=</span> author
  }
  
  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye tutorial <span class="hljs-subst">\(title)</span>!"</span>)
  }
}</pre>
<p class="calibre1">Add the following <code class="calibre9">Author</code> class as well:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Author</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> tutorials: [<span class="hljs-built_in">Tutorial</span>] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye author <span class="hljs-subst">\(name)</span>!"</span>)
  }
}</pre>
<p class="calibre1">Here you guarantee that a tutorial always has an author. Hence, <code class="calibre9">Author</code> is not declared as optional. On the other hand, <code class="calibre9">tutorials</code> is a variable that can change after initialization.
</p>
<p class="calibre1">An error persists in your code, however. The tutorial doesn’t yet have an author. Modify its declaration as follows:
</p><pre class="code-block"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> author <span class="hljs-operator">=</span> <span class="hljs-built_in">Author</span>(name: <span class="hljs-string">"Cosmin"</span>)
  <span class="hljs-keyword">let</span> tutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Memory management"</span>, 
                          author: author)
  <span class="hljs-keyword">let</span> editor <span class="hljs-operator">=</span> <span class="hljs-built_in">Editor</span>(name: <span class="hljs-string">"Ray"</span>)                         
  author.tutorials.append(tutorial)
  tutorial.editor <span class="hljs-operator">=</span> editor
  editor.tutorials.append(tutorial)
}</pre>
<p class="calibre1">Here you release the editor but not the rest of the objects. And you’re making another reference cycle, this time between the tutorial and its corresponding author. Each tutorial on the website has an author, and there are no anonymous authors here! The tutorial’s <code class="calibre9">author</code> property is the perfect match for an unowned reference since it’s never <code class="calibre9">nil</code>. Change the property’s declaration in the <code class="calibre9">Tutorial</code> class to the following:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Tutorial</span> {
  <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">Author</span>
  <span class="hljs-comment">// original code</span>
}</pre>
<p class="calibre1">This code breaks the reference cycle with the <code class="calibre9">unowned</code> keyword. All the <code class="calibre9">deinit</code> methods run and print the following output to the console:
</p><pre class="code-block">Goodbye editor Ray!
Goodbye author Cosmin!
Goodbye tutorial Memory management!</pre>
<p class="calibre1">That’s it for reference cycles for classes. Now let’s look at reference cycles with closures.
</p>
<h2 class="segment-chapter1">Reference cycles for closures</h2>

<p class="calibre1">In Chapter 8, “Collection Iteration With Closures”, you learned that closures capture values from the enclosing scope. Because Swift is a safe language, closures extend the lifetime of any object they use to guarantee those objects are alive and valid. This automatic safety is convenient, but the downside of this is you can inadvertently create a reference cycle if you extend the lifetime of an object that itself captures the closure. Closures, you see, are reference types themselves.
</p>
<p class="calibre1">For example, add a property that computes the tutorial’s description to the <code class="calibre9">Tutorial</code> class like this:
</p><pre class="code-block"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> description: () -&gt; <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> {
  <span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.title)</span> by <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.author.name)</span>"</span>
}</pre>
<p class="calibre1">Remember that a <em class="calibre5">lazy property</em> isn’t assigned until its first use and that <code class="calibre9">self</code> is only available after initialization.
</p>
<p class="calibre1">Print the tutorial’s description to the console. Add the following code right after the <code class="calibre9">tutorial</code> object’s declaration:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(tutorial.description())</pre>
<p class="calibre1">You created another strong reference cycle between the tutorial object and the closure by capturing <code class="calibre9">self</code>, so only the author’s <code class="calibre9">deinit</code> method runs.
</p>
<p class="calibre1">You’ll need to know about a language feature called <em class="calibre5">capture lists</em> to break the cycle.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Swift requires <code class="calibre9">self</code> inside of closures of reference types, and it’s a good reminder that you are capturing a reference to the current object. The other place where you can omit <code class="calibre9">self</code> is when the closure is <em class="calibre5">non</em><em class="calibre5">-</em><em class="calibre5">escaping</em>, which you’ll learn about next.
</p></div>

<h3 class="segment-title2">Escaping closures</h3>

<p class="calibre1">In Chapter 8, “Collection Iteration With Closures”, all of the closures you used were <em class="calibre5">non</em><em class="calibre5">-</em><em class="calibre5">escaping</em>. Closure parameters are by default non-escaping because they are assumed to not be used after the function returns. This is the case for map, filter, reduce, sort and more. If the closure <i class="calibre2">is</i> going to be used at a later time, it needs to let the caller know. You do this by marking the closure parameter with the <code class="calibre9">@escaping</code> attribute. A minimal example looks like this:
</p><pre class="code-block"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-number">FunctionKeeper</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> function: () -&gt; <span class="hljs-built_in">Void</span> <span class="hljs-comment">// 1       </span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">function</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-built_in">Void</span>) { <span class="hljs-comment">// 2 </span>
    <span class="hljs-keyword">self</span>.function <span class="hljs-operator">=</span> function
  }

  <span class="hljs-keyword">func</span> <span class="hljs-number">run</span>() { <span class="hljs-comment">// 3                           </span>
    function()
  }
}</pre>
<p class="calibre1">Here is what <code class="calibre9">FunctionKeeper</code> does:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The stored property <code class="calibre9">function</code> keeps a reference to a closure.
</p></li>

<li class="calibre4">
<p class="calibre1">You pass a closure on initialization. Because it is going to put it into a stored property and keep using it after <code class="calibre9">init(function:)</code> returns, it must be marked as <code class="calibre9">@escaping</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">run()</code> function executes the function.
</p></li>
</ol>

<p class="calibre1">You might use the function this way:
</p><pre class="code-block"><span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> <span class="hljs-string">"Cosmin"</span>
<span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> <span class="hljs-built_in">FunctionKeeper</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, <span class="hljs-subst">\(name)</span>"</span>)
}
f.run()</pre>
<p class="calibre1">This creates a <code class="calibre9">FunctionKeeper</code> object and prints, “Hello, Cosmin”. The escaping closure extends the lifetime of the <code class="calibre9">name</code> variable by capturing it so it’s available when <code class="calibre9">run()</code> executes.
</p>
<h3 class="segment-title2">Capture lists</h3>

<p class="calibre1"><em class="calibre5">Capture lists</em> are a language feature to help you control exactly how a closure extends the lifetime of instances it references. Capture lists are lists of variables captured by a closure and appear at the beginning of the closure before any arguments.
</p>
<p class="calibre1">First, consider the following code snippet with no capture list:
</p><pre class="code-block"><span class="hljs-keyword">var</span> counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">var</span> g <span class="hljs-operator">=</span> {<span class="hljs-built_in">print</span>(counter)}
counter <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
g()</pre>
<p class="calibre1">The <code class="calibre9">g()</code> closure prints the <code class="calibre9">counter</code> variable’s updated value of 1 because it has a reference to the <code class="calibre9">counter</code> variable. Now add a <code class="calibre9">[c = counter]</code> capture list:
</p><pre class="code-block">counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
g <span class="hljs-operator">=</span> {[c <span class="hljs-operator">=</span> counter] <span class="hljs-keyword">in</span> <span class="hljs-built_in">print</span>(c)}
counter <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
g()</pre>
<p class="calibre1">Most of the time, you don’t bother creating a new variable name like <code class="calibre9">c</code>. The shorthand <code class="calibre9">[counter]</code> capture list creates a <code class="calibre9">counter</code> local variable that shadows the original <code class="calibre9">counter</code>:
</p><pre class="code-block">counter <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
g <span class="hljs-operator">=</span> {[counter] <span class="hljs-keyword">in</span> <span class="hljs-built_in">print</span>(counter)}
counter <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
g()</pre>
<p class="calibre1">The <code class="calibre9">g()</code> closure also prints 0 in this case because <code class="calibre9">counter</code> is a shadowed copy.
</p>
<p class="calibre1">When dealing with objects, remember that “constant” has a different meaning for reference types. A capture list will cause the closure to capture and store the current <i class="calibre2">reference</i> stored inside the captured variable with reference types. Changes made to the object through this reference will still be visible outside of the closure. Ready to break some reference cycles again? Good! This time, you’ll use &mdash; you guessed it &mdash; a capture list.
</p>
<h3 class="segment-title2">Unowned self</h3>

<p class="calibre1">The closure that determines the tutorial’s description captures a strong reference of <code class="calibre9">self</code> and creates a reference cycle. Since the closure doesn’t exist after releasing the <code class="calibre9">tutorial</code> object from memory, <code class="calibre9">self</code> will never be <code class="calibre9">nil</code>, so you can change the strong reference to an unowned one using a capture list.
</p><pre class="code-block"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> description: () -&gt; <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> {
  [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
  <span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.title)</span> by <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.author.name)</span>"</span>
}</pre>
<p class="calibre1">Huzzah. No more reference cycle! All the <code class="calibre9">deinit</code> methods work as before and output the following to the console:
</p><pre class="code-block">Memory management by Cosmin
Goodbye editor Ray!
Goodbye author Cosmin!
Goodbye tutorial Memory management!</pre>
<h3 class="segment-title2">Weak self</h3>

<p class="calibre1">There are certain times when you can’t capture <code class="calibre9">self</code> as an unowned reference, because it might become <code class="calibre9">nil</code>. Consider the following example:
</p><pre class="code-block"><span class="hljs-keyword">let</span> tutorialDescription: () -&gt; <span class="hljs-built_in">String</span>
<span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> author <span class="hljs-operator">=</span> <span class="hljs-built_in">Author</span>(name: <span class="hljs-string">"Cosmin"</span>)
  <span class="hljs-keyword">let</span> tutorial <span class="hljs-operator">=</span> <span class="hljs-built_in">Tutorial</span>(title: <span class="hljs-string">"Memory management"</span>, 
                          author: author)
  tutorialDescription <span class="hljs-operator">=</span> tutorial.description
}
<span class="hljs-built_in">print</span>(tutorialDescription())</pre>
<p class="calibre1">The above code crashes your playground because you deallocate <code class="calibre9">tutorial</code> and <code class="calibre9">author</code> at the end of <code class="calibre9">do</code>. Change <code class="calibre9">unowned</code> for <code class="calibre9">self</code> to <code class="calibre9">weak</code> in the capture list of <code class="calibre9">description</code> to fix this:
</p><pre class="code-block"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> description: () -&gt; <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> {
  [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
  <span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.title)</span> by <span class="hljs-subst">\(<span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.author.name)</span>"</span>
}</pre>
<p class="calibre1">This code produces the following curious output:
</p><pre class="code-block">nil by nil</pre>
<p class="calibre1"><code class="calibre9">[weak self]</code> means that the closure will not extend the lifetime of <code class="calibre9">self</code>. If the underlying object representing <code class="calibre9">self</code> goes away, it gets set to <code class="calibre9">nil</code>.  The code doesn’t crash anymore but does generate a warning which you can fix.
</p>
<h3 class="segment-title2">The weak-strong pattern</h3>

<p class="calibre1">The <em class="calibre5">weak</em><em class="calibre5">-</em><em class="calibre5">strong pattern</em> (sometimes affectionately called the weak-strong-dance) also does not extend the lifetime of <code class="calibre9">self</code> but converts the weak reference to a strong one after it enters the closure:
</p><pre class="code-block"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> description: () -&gt; <span class="hljs-built_in">String</span> <span class="hljs-operator">=</span> {
    [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"The tutorial is no longer available."</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.title)</span> by <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.author.name)</span>"</span>
}</pre>
<p class="calibre1"><code class="calibre9">guard</code> makes <code class="calibre9">self</code> strong if it isn’t <code class="calibre9">nil</code>, so it’s guaranteed to live until the end of the closure. You print a suitable message if <code class="calibre9">self</code> is <code class="calibre9">nil</code> this time, and the previous warning is gone.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your memory management knowledge. It’s best to try and solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Break the cycle</h3>

<p class="calibre1">Break the strong reference cycle in the following code:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Person</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> email: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> car: <span class="hljs-built_in">Car</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">email</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.email <span class="hljs-operator">=</span> email
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye <span class="hljs-subst">\(name)</span>!"</span>)
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Car</span> {
  <span class="hljs-keyword">let</span> id: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> type: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> owner: <span class="hljs-built_in">Person</span>?

 <span class="hljs-keyword">init</span>(<span class="hljs-built_in">id</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">type</span>: <span class="hljs-built_in">String</span>) {
   <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id
   <span class="hljs-keyword">self</span>.type <span class="hljs-operator">=</span> type
 }

 <span class="hljs-keyword">deinit</span> {
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye <span class="hljs-subst">\(type)</span>!"</span>)
 }
}

<span class="hljs-keyword">var</span> owner: <span class="hljs-built_in">Person</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Person</span>(name: <span class="hljs-string">"Cosmin"</span>, 
                            email: <span class="hljs-string">"cosmin@whatever.com"</span>)
<span class="hljs-keyword">var</span> car: <span class="hljs-built_in">Car</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Car</span>(id: <span class="hljs-number">10</span>, type: <span class="hljs-string">"BMW"</span>)

owner<span class="hljs-operator">?</span>.car <span class="hljs-operator">=</span> car
car<span class="hljs-operator">?</span>.owner <span class="hljs-operator">=</span> owner

owner <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
car <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<h3 class="segment-title2">Challenge 2: Break another cycle</h3>

<p class="calibre1">Break the strong reference cycle in the following code:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Customer</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> email: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> account: <span class="hljs-built_in">Account</span>?

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">email</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.email <span class="hljs-operator">=</span> email
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye <span class="hljs-subst">\(name)</span>!"</span>)
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Account</span> {
  <span class="hljs-keyword">let</span> number: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> type: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> customer: <span class="hljs-built_in">Customer</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">number</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">customer</span>: <span class="hljs-built_in">Customer</span>) {
    <span class="hljs-keyword">self</span>.number <span class="hljs-operator">=</span> number
    <span class="hljs-keyword">self</span>.type <span class="hljs-operator">=</span> type
    <span class="hljs-keyword">self</span>.customer <span class="hljs-operator">=</span> customer
  }

  <span class="hljs-keyword">deinit</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye <span class="hljs-subst">\(type)</span> account number <span class="hljs-subst">\(number)</span>!"</span>)
  }
}

<span class="hljs-keyword">var</span> customer: <span class="hljs-built_in">Customer</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Customer</span>(name: <span class="hljs-string">"George"</span>, 
                                   email: <span class="hljs-string">"george@whatever.com"</span>)
<span class="hljs-keyword">var</span> account: <span class="hljs-built_in">Account</span>? <span class="hljs-operator">=</span> <span class="hljs-built_in">Account</span>(number: <span class="hljs-number">10</span>, type: <span class="hljs-string">"PayPal"</span>, 
                                customer: customer<span class="hljs-operator">!</span>)

customer<span class="hljs-operator">?</span>.account <span class="hljs-operator">=</span> account

account <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
customer <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span></pre>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Use a <em class="calibre5">weak reference</em> to break a strong reference cycle if a reference may become <code class="calibre9">nil</code> at some point in its lifecycle.
</p></li>

<li class="calibre4">
<p class="calibre1">Use an <em class="calibre5">unowned reference</em> to break a strong reference cycle when you know a reference <em class="calibre5">always</em> has a value and will <em class="calibre5">never</em> be <code class="calibre9">nil</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">You <em class="calibre5">must</em> use <code class="calibre9">self</code> inside a closure’s body of a reference type. This requirement is a way the Swift compiler hints that you need to be careful not to make a circular reference.
</p></li>

<li class="calibre4">
<p class="calibre1">An <em class="calibre5">escaping closure</em> is a closure parameter that can be stored and called after the function returns.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Capture lists</em> define how you capture values and references in closures.
</p></li>

<li class="calibre4">
<p class="calibre1">The <em class="calibre5">weak</em><em class="calibre5">-</em><em class="calibre5">strong pattern</em> converts a weak reference to a strong one.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-3">


<h1 class="segment-chapter">Chapter 25: Value Types &amp; Reference Types</h1>

<p class="calibre1">Swift supports two kinds of types: value types and reference types. Structs and enums are value types, while classes and functions are reference types, and they differ in behavior. The behavior you’ve come to expect from value types is the result of <em class="calibre5">value semantics</em>. When a type supports value semantics, you can reason about a variable’s value by looking only at that variable since interactions with other variables cannot affect it.
</p>
<p class="calibre1">Value semantics <i class="calibre2">guarantees the independence of variables</i>, which rules out a large class of bugs. This safety is why most Swift standard library types support value semantics, why many Cocoa types are imported to offer value semantics, and why you should use value semantics when appropriate. Value semantics are not always the proper choice, and they can require some subtle handling to support correctly.
</p>
<p class="calibre1">This chapter will define value semantics, show how to test for it, and explain when it’s suitable. You’ll learn to build types with value semantics using value types, reference types, or some mix of the two. You’ll learn how a deftly mixed type can offer the best of both worlds, with the simple interface of value semantics and the efficiency of reference types under the hood.
</p>
<h2 class="segment-chapter1">Value types vs. reference types</h2>

<p class="calibre1">Value and reference types differ in their <em class="calibre5">assignment behavior</em>, which is just a name for what Swift does whenever you assign a value to a variable. Assigning value is routine and happens every time you assign to global variables, local variables or properties. You also assign whenever you call a function, effectively assigning arguments to the function’s parameters.
</p>
<h3 class="segment-title2">Reference types</h3>

<p class="calibre1">Reference types use <em class="calibre5">assign</em><em class="calibre5">-</em><em class="calibre5">by</em><em class="calibre5">-</em><em class="calibre5">reference</em>. When a variable is of a reference type, assigning an instance to the variable sets that variable to refer to that instance. If another variable was already referring to that instance, then both variables post-assignment refer to the <i class="calibre2">same</i> instance, like so:
</p><div class="image2"><img src="images/000019.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Since both variables point to the same instance, you can use one variable to change that instance and see the change’s effect on the other.
</p>
<p class="calibre1">Suppose you’re running a paint shop, selling paint to landscape artists, painters and builders. You’re building an inventory app to keep track of your paint.
</p>
<p class="calibre1">Start with a simple color and paint abstraction:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Color</span>: <span class="hljs-number">CustomStringConvertible</span> {
  <span class="hljs-keyword">var</span> red, green, blue: <span class="hljs-built_in">Double</span>
  
  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"r: <span class="hljs-subst">\(red)</span> g: <span class="hljs-subst">\(green)</span> b: <span class="hljs-subst">\(blue)</span>"</span>
  }
}

<span class="hljs-comment">// Preset colors</span>
<span class="hljs-keyword">extension</span> <span class="hljs-number">Color</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> black <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>(red: <span class="hljs-number">0</span>, green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">0</span>)
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> white <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>(red: <span class="hljs-number">1</span>, green: <span class="hljs-number">1</span>, blue: <span class="hljs-number">1</span>)
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> blue  <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>(red: <span class="hljs-number">0</span>, green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">1</span>)
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> green <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>(red: <span class="hljs-number">0</span>, green: <span class="hljs-number">1</span>, blue: <span class="hljs-number">0</span>)
  <span class="hljs-comment">// more ...</span>
}

<span class="hljs-comment">// Paint bucket abstraction</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Bucket</span> {
  <span class="hljs-keyword">var</span> color: <span class="hljs-built_in">Color</span>
  <span class="hljs-keyword">var</span> isRefilled <span class="hljs-operator">=</span> <span class="hljs-keyword">false</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">color</span>: <span class="hljs-built_in">Color</span>) {
    <span class="hljs-keyword">self</span>.color <span class="hljs-operator">=</span> color
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">refill</span>() {
    isRefilled <span class="hljs-operator">=</span> <span class="hljs-keyword">true</span>
  }
}</pre>
<p class="calibre1">Landscape artists like painting the sky, so you have a bucket of blue paint in the shop with the label “azure” on the side. Housepainters also like that color, but they call it “wall blue”. On the other side of that same bucket, you have another label that says “wall blue“.
</p>
<p class="calibre1">The code in your inventory app reflects this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> azurePaint <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: .blue)
<span class="hljs-keyword">let</span> wallBluePaint <span class="hljs-operator">=</span> azurePaint
wallBluePaint.isRefilled <span class="hljs-comment">// =&gt; false, initially</span>
azurePaint.refill()
wallBluePaint.isRefilled <span class="hljs-comment">// =&gt; true, unsurprisingly!</span></pre>
<p class="calibre1">When you call <code class="calibre9">azurePaint.refill()</code>, you also refill <code class="calibre9">wallBluePaint</code> because the two variables refer to the same instance.
</p>
<p class="calibre1">The two variables now depend on each other. The value of any variable is simply the value of the instance it references, and these two variables refer to the same instance. Changing one might change the other, as the two variables are two names for the same bucket.
</p>
<h3 class="segment-title2">Value types</h3>

<p class="calibre1">Value types, however, use <em class="calibre5">assign</em><em class="calibre5">-</em><em class="calibre5">by</em><em class="calibre5">-</em><em class="calibre5">copy</em>. Assigning an instance to a variable of a value type <i class="calibre2">copies</i> the instance and sets the variable to hold that new instance. So after every assignment, a variable contains an instance which it owns all to itself.
</p>
<p class="calibre1">Here’s how this looks:
</p><div class="image2"><img src="images/000032.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">In the example above, <code class="calibre9">Color</code> is a value type, so assigning a value to <code class="calibre9">wallBlue</code> creates a copy of the instance held by <code class="calibre9">azure</code>.
</p>
<p class="calibre1">With this system, each variable is independent, so you never need to worry that another variable might change it. For instance, suppose the painters’ tastes change, and they decide that walls look better in a darker shade of blue. If you call a method <code class="calibre9">wallBlue.darken()</code> to change the color of <code class="calibre9">wallBlue</code>, there is no effect on what is meant by <code class="calibre9">azure</code>.
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Color</span> {
  <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-number">darken</span>() {
    red <span class="hljs-operator">*=</span> <span class="hljs-number">0.9</span>; green <span class="hljs-operator">*=</span> <span class="hljs-number">0.9</span>; blue <span class="hljs-operator">*=</span> <span class="hljs-number">0.9</span>
  }
}

<span class="hljs-keyword">var</span> azure <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>.blue
<span class="hljs-keyword">var</span> wallBlue <span class="hljs-operator">=</span> azure
azure  <span class="hljs-comment">// r: 0.0 g: 0.0 b: 1.0</span>
wallBlue.darken()
azure  <span class="hljs-comment">// r: 0.0 g: 0.0 b: 1.0 (unaffected)</span></pre>
<p class="calibre1">To continue the metaphor, instead of having different names for the same bucket of paint, where the bucket’s contents can change, these value-type variables are more like names printed on color sample swatches. Each name is independently associated with just one color.
</p>
<h2 class="segment-chapter1">Defining value semantics</h2>

<p class="calibre1">What’s nice about primitive value types like <code class="calibre9">Color</code> or <code class="calibre9">Int</code> is not the assign-by-copy behavior itself, but rather the guarantee this behavior creates.
</p>
<p class="calibre1">The guarantee is that the <i class="calibre2">only</i> way to affect a variable’s value is through that variable itself. If a type promises that, then the type supports value semantics.
</p>
<p class="calibre1">To test if a type supports value semantics, consider it in a snippet like the following:
</p><pre class="code-block"><span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-built_in">MysteryType</span>()
<span class="hljs-keyword">var</span> y <span class="hljs-operator">=</span> x
exposeValue(x) <span class="hljs-comment">// =&gt; initial value derived from x</span>
<span class="hljs-comment">// {code here which uses only y}</span>
exposeValue(x) <span class="hljs-comment">// =&gt; final value derived from x</span>
<span class="hljs-comment">// Q: are the initial and final values different?</span></pre>
<p class="calibre1">If the code that “uses only <code class="calibre9">y</code>” can affect the value of <code class="calibre9">x</code>, then <code class="calibre9">MysteryType</code> does not support value semantics.
</p>
<p class="calibre1">One benefit of value semantics is that they aid <em class="calibre5">local reasoning</em>. To determine how a variable got its value, you only need to consider the history of interactions with that variable. The world of value semantics is a simple one where variables have values not affected by other variables.
</p>
<h3 class="segment-title2">When to prefer value semantics</h3>

<p class="calibre1">When should you design a type to support value semantics? This choice depends on what your type is supposed to model.
</p>
<p class="calibre1">Value semantics are appropriate for representing inert, descriptive data &mdash; numbers, strings, and physical quantities like angle, length, or color; mathematical objects, like vectors and matrices; pure binary data; and lastly, collections of such values, and large, rich structures made from such values, like media.
</p>
<p class="calibre1">Reference semantics are suitable for representing distinct items in your program or the world. For example, specific objects or memory buffers that change over time and coordinate with other objects work well with reference semantics. Similarly, a particular person or physical object can be represented this way easily in the real world.
</p>
<p class="calibre1">The underlying logic here is that the referenceable items are all <i class="calibre2">objects</i>, meaning they all have distinct identities. Two identical twins could be alike in all physical attributes, but they are still distinct <i class="calibre2">people</i>. Two buffers could hold equal byte patterns, but they are still distinct <i class="calibre2">buffers</i>.
</p>
<p class="calibre1">But the items on the value semantics list are all <i class="calibre2">values</i>. They lack identity, so it is meaningless to talk about two things being equal but distinct. If we agree <code class="calibre9">x</code> equals five, there is no further question about which five it equals. Five is five.
</p>
<p class="calibre1">A typical pattern is to see a model type like <code class="calibre9">Person</code> defined as a reference type to reflect an object with identity. The type then uses other types with value semantics to store various descriptive values like <code class="calibre9">age</code>, <code class="calibre9">hairColor</code>, etc.
</p>
<p class="calibre1">When a program must represent many distinct items (like <code class="calibre9">Person</code>s), or when different parts of a program need to coordinate around the same item (like the <code class="calibre9">UIScreen</code> or the <code class="calibre9">UIApplication</code> instance of a UIKit app), reference types are the natural tool for representing those items.
</p>
<p class="calibre1">Reference types are used throughout UIKit, an Objective-C, object-oriented framework, because distinct objects communicate and interact with one another. You have <code class="calibre9">UIView</code> instances for representing regions on the screen, <code class="calibre9">UIScreen</code> for the screen itself, <code class="calibre9">NSNotificationCenter</code> for objects providing framework services, and so on.
</p>
<p class="calibre1">By contrast, SwiftUI is a declarative and more value-based framework.  In this world, a <code class="calibre9">View</code>-conforming value type provides a lightweight, immutable description of a piece of the user interface computed from the current state. If the state changes, the interface is recomputed from scratch.
</p>
<h2 class="segment-chapter1">Implementing value semantics</h2>

<p class="calibre1">Now assume you do want value semantics. If you’re defining a type, how do you enforce it? The approach depends on the details of the type. In this section, you will consider the various cases one by one.
</p>
<h3 class="segment-title2">Case 1: Primitive value types</h3>

<p class="calibre1">Primitive value types like <code class="calibre9">Int</code> support value semantics automatically. This support is because assign-by-copy ensures each variable holds its own instance &mdash; so no other variable can affect the instance &mdash; and because the instance itself is structurally independent. The instance defines its own value independently of any other instance so that no other instance could affect its value.
</p>
<p class="calibre1">The intuition here is that a copied bit pattern with no external references or dependencies represents an <code class="calibre9">Int</code>.
</p>
<h3 class="segment-title2">Case 2: Composite value types</h3>

<p class="calibre1">Composite value types other than <code class="calibre9">class</code>, like a tuple, <code class="calibre9">struct</code> or <code class="calibre9">enum</code>, support value semantics if all the stored components support value semantics.
</p>
<p class="calibre1">You can prove this rule by looking at how Swift does the instance copying. When Swift copies the instance of a <code class="calibre9">struct</code>, it creates a copy instance as if it’s directly assigning all the stored properties of the original instance into the copy instance’s properties. This assignment is direct in that it does not invoke any property observers.
</p>
<p class="calibre1">When you assign a struct value type, the assigned-to variable will hold a copy of the instance.  Since each property has value semantics, the copy instance’s properties will be the only variables that can modify <i class="calibre2">their</i> instances. So from this, you can see the assigned-to variable is the only way to modify its instance or any other dependency. Therefore, this is the only way to alter its own value. Proof!
</p>
<p class="calibre1">Tuples act as ad hoc structs with no user-definable methods or protocol conformances, so the same proof logic applies.
</p>
<p class="calibre1">The proof is analogous if the type is an enumeration: the instance copy is the same enumeration case. It is as if that member’s associated values are directly assigned from the existing instance’s associated values.
</p>
<p class="calibre1">Incidentally, since an <code class="calibre9">Array&lt;Element&gt;</code> provides the same semantics as a <code class="calibre9">struct</code> with a property of type <code class="calibre9">Element</code>, this case also tells you whether arrays support value semantics. They do, but only if their element type does.
</p>
<h3 class="segment-title2">Case 3: Reference types</h3>

<p class="calibre1">Reference types can also have value semantics.
</p>
<p class="calibre1">To see how, recall that a type has value semantics if the only way to affect a variable’s value is through that variable. In general, you can change the value of a reference type in only two ways: first, by changing the value directly; second, by assigning it to a new variable and modifying that.
</p>
<p class="calibre1">The first approach is allowed by value semantics. But the second way &mdash; modifying the instance through a newly assigned variable &mdash; must be prevented to preserve value semantics.
</p>
<p class="calibre1">One solution is straightforward: define the reference type to be <i class="calibre2">immutable</i>. In other words, build it, so it’s impossible to change the instance’s value after initialization. To achieve this, you must ensure that all its stored properties are constant and only use types with value semantics.
</p>
<p class="calibre1">Many of the basic UIKit utility types adopt this pattern. For instance, consider this code handling a <code class="calibre9">UIImage</code>:
</p><pre class="code-block"><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-built_in">UIImage</span>(named:<span class="hljs-string">"smile.jpg"</span>)
<span class="hljs-keyword">var</span> b <span class="hljs-operator">=</span> a
computeValue(b) <span class="hljs-comment">// =&gt; something</span>
doSomething(a)
computeValue(b) <span class="hljs-comment">// =&gt; same thing!</span></pre>
<p class="calibre1">Because <code class="calibre9">UIImage</code> is immutable, there is no possible function <code class="calibre9">doSomething(a)</code> that will cause <code class="calibre9">computeValue(b)</code> to change the value it returns. It doesn’t matter if <code class="calibre9">b</code> is a copy of <code class="calibre9">a</code>.
</p>
<p class="calibre1">The <code class="calibre9">UIImage</code> type has dozens of properties (<code class="calibre9">scale</code>, <code class="calibre9">capInsets</code>, <code class="calibre9">renderingMode</code>, etc.), but since they are all read-only, you can’t modify an instance. Therefore, there’s no way for one variable to affect another. But if one of its properties were <i class="calibre2">not</i> constant, then setting that property would mutate the instance and spoil the invariant &mdash; such structural sharing of a common instance would not be safe.
</p>
<p class="calibre1"><code class="calibre9">UIImage</code>, along with many of the Cocoa types, is defined as immutable for this reason because an immutable reference type has value semantics.
</p>
<h3 class="segment-title2">Case 4: value types containing mutable reference types</h3>

<p class="calibre1">The last case is mixed types: value types that contain mutable reference types. This case is the subtlest but perhaps the most valuable. It can allow providing the simple programming model of value semantics with the efficiency benefits of reference types. But it can easily fail to do so.
</p>
<p class="calibre1">To see how it can fail, look again at the instance copying rule:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">When a mixed-type instance is copied, all of its properties are directly assigned.
</p></li>

<li class="calibre4">
<p class="calibre1">But since any reference-type property is assigned by reference to the copy, the instances of the copy property and the original property will refer to the <i class="calibre2">same</i> shared instance.
</p></li>
</ol>

<p class="calibre1">The instance and its copy are distinct, but their values depend on each other because of structural sharing, affecting both instances.
</p>
<p class="calibre1">An example and a diagram will explain this best. Returning to your paint shop, imagine you want a type to define a plan for a painting project, a plan that specifies the bucket that provides the main color and also specifies the accent color:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> { <span class="hljs-comment">// a value type, containing ...</span>
  <span class="hljs-comment">// a value type</span>
  <span class="hljs-keyword">var</span> accent <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>.white
  <span class="hljs-comment">// a mutable reference type</span>
  <span class="hljs-keyword">var</span> bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: .blue)
}</pre>
<p class="calibre1">You might want to define your plan for a piece of artwork by starting with a house painting plan and then modifying it. Since <code class="calibre9">PaintingPlan</code> is a struct &mdash; a value type &mdash; you might hope to do this by assigning a new variable and then modifying that variable.
</p>
<p class="calibre1">Unfortunately, since it’s a <code class="calibre9">struct</code> containing a reference type, the assignment does not create a genuinely independent copy.
</p>
<p class="calibre1">When you change the house plan color, you change the art plan’s color since they share the same bucket.
</p><pre class="code-block"><span class="hljs-keyword">let</span> artPlan <span class="hljs-operator">=</span> <span class="hljs-built_in">PaintingPlan</span>()
<span class="hljs-keyword">let</span> housePlan <span class="hljs-operator">=</span> artPlan
artPlan.bucket.color <span class="hljs-comment">// =&gt; blue</span>
<span class="hljs-comment">// for house-painting only we fill the bucket with green paint</span>
housePlan.bucket.color <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>.green
artPlan.bucket.color <span class="hljs-comment">// =&gt; green. oops!</span></pre>
<p class="calibre1">This surprising behavior is due to the implicit structural sharing of the paint bucket instance:
</p><div class="image2"><img src="images/000045.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Because of this structural sharing, <code class="calibre9">PaintingPlan</code> is a value type but lacks value semantics. Nor does it have pure reference semantics, and it is a bit of a mess.
</p>
<p class="calibre1">You should beware of casual discussions of value semantics which give the impression that all value types have value semantics or that having value semantics is <i class="calibre2">synonymous</i> with being a value type. As this example shows, this is not the case.
</p>
<h4 class="segment-title2">Copy-on-write to the rescue</h4>

<p class="calibre1">What’s the fix? The first step lies in recognizing that value semantics are defined relative to an access level. Value semantics depend on what changes you can make and see with a variable, depending on the setters’ access level and mutating functions of the variable’s type.
</p>
<p class="calibre1">So a type may provide value semantics to all client code &mdash; for example, which can access <code class="calibre9">internal</code> or <code class="calibre9">public</code> members &mdash; while not providing value semantics to code that can access its <code class="calibre9">private</code> members.
</p>
<p class="calibre1">So the trick to preserving value semantics in a mixed type is to define the type such that its <i class="calibre2">users</i> can never see the effects of mutation on the contained reference-type property. This example makes the mutable reference type <code class="calibre9">private</code> and provides an interface that controls reads and writes:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> { <span class="hljs-comment">// a value type, containing ...</span>
  <span class="hljs-comment">// a value type</span>
  <span class="hljs-keyword">var</span> accent <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>.white
  <span class="hljs-comment">// a private reference type, for "deep storage"</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>()

  <span class="hljs-comment">// a pseudo-value type, using the deep storage</span>
  <span class="hljs-keyword">var</span> bucketColor: <span class="hljs-built_in">Color</span> {
    <span class="hljs-keyword">get</span> {
      bucket.color
    }
    <span class="hljs-keyword">set</span> {
      bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: newValue)
    }
  }
}</pre>
<p class="calibre1">To code that can access private members, this struct contains the mutable reference-type property <code class="calibre9">bucket</code>, spoiling value semantics. But to a client with <code class="calibre9">internal</code> access or higher, the type behaves like a struct with value semantics, with two properties, <code class="calibre9">accentColor</code> and <code class="calibre9">bucketColor</code>.
</p>
<p class="calibre1">Reading <code class="calibre9">bucketColor</code> simply invokes the computed property getter, which reads from the private reference-type property <code class="calibre9">bucket</code>, which acts as the <em class="calibre5">backing storage</em>. Apple sometimes also calls this <em class="calibre5">indirect storage</em> or <em class="calibre5">deep storage</em>. Assigning to <code class="calibre9">bucketColor</code> invokes the computed property setter, designed to preserve the independence of <code class="calibre9">PaintingPlan</code> values. Whenever a user modifies <code class="calibre9">bucketColor</code>, the setter creates a distinct new instance of indirect storage, a new <code class="calibre9">Bucket</code>, to back it.
</p>
<p class="calibre1">The effect is that assigning a value of <code class="calibre9">PaintingPlan</code> does not immediately copy the backing storage at the moment of assignment, as with a simple value type. Instances will share their backing storage for a while. But every instance appears as if it always had its own backing store since it privately creates its own unique backing store as soon as one is needed.
</p>
<p class="calibre1">This mechanism is called the <em class="calibre5">copy</em><em class="calibre5">-</em><em class="calibre5">on</em><em class="calibre5">-</em><em class="calibre5">write</em> (COW) pattern because the system only copies the backing store when writing to the variable.
</p>
<p class="calibre1">But what’s the point of that? The point is performance. Suppose the backing store is enormous. When you only read from variables, the instances can all share the same backing store, using less storage and sparing the computational cost of copying it.
</p>
<p class="calibre1">But once you use a variable to mutate an instance &mdash; to write to it &mdash; only then does the system do the work of copying the backing store to ensure the modification does not affect other variables. This lazy approach minimizes immediate storage and compute costs, deferring them only until they are needed.
</p>
<p class="calibre1">Suppose the backing store is large enough to deserve this optimization. In that case, it is almost certainly worth applying a further optimization that performs in-place mutation of the backing store if it is not shared elsewhere. This additional optimization is cheaper than creating a new store and throwing away the old one.
</p>
<p class="calibre1">For this to work, your value type needs a way to tell if it uniquely refers to a given backing store. The standard library function <code class="calibre9">isKnownUniquelyReferenced</code> provides just the thing for that:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> { <span class="hljs-comment">// a value type, containing ...</span>
  <span class="hljs-comment">// ... as above ...</span>

  <span class="hljs-comment">// a computed property facade over deep storage</span>
  <span class="hljs-comment">// with copy-on-write and in-place mutation when possible</span>
  <span class="hljs-keyword">var</span> bucketColor: <span class="hljs-built_in">Color</span> {
    <span class="hljs-keyword">get</span> {
      bucket.color
    }
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>bucket) {
        bucket.color <span class="hljs-operator">=</span> bucketColor
      } <span class="hljs-keyword">else</span> {
        bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: newValue)
      }
    }
  }
}</pre>
<p class="calibre1">The Swift standard library uses this technique extensively.
</p>
<p class="calibre1">Many of the Swift value types are not primitive value types but are mixed types that only seem like primitive value types because they provide value semantics, relying on efficient COW implementations. The Swift language itself uses COW under the hood, sometimes deferring the copying of instances until the compiler can deduce that it is needed because of a mutation.
</p>
<h2 class="segment-chapter1">Recipes for value semantics</h2>

<p class="calibre1">To summarize, here is the recipe for determining if a type has value semantics or for defining your own such type:
</p>
<p class="calibre1">For a reference type (a <code class="calibre9">class</code>):
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The type must be <i class="calibre2">immutable</i>, so the requirement is that all its properties are constant and must be of types that have value semantics.
</p></li>
</ul>

<p class="calibre1">For a value type (a <code class="calibre9">struct</code> or <code class="calibre9">enum</code>):
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A primitive value type like <code class="calibre9">Int</code> always has value semantics.
</p></li>

<li class="calibre4">
<p class="calibre1">If you define a <code class="calibre9">struct</code> type with properties, that type will have value semantics if all of its properties have value semantics.
</p></li>

<li class="calibre4">
<p class="calibre1">Similarly, if you define an <code class="calibre9">enum</code> type with associated values, that type will have value semantics if all its associated values have value semantics.
</p></li>
</ul>

<p class="calibre1">For COW value types &mdash;<code class="calibre9">struct</code> or <code class="calibre9">enum</code>:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Choose the “value-semantics access level”, that is, the access level that’ll expose an interface that preserves value semantics.
</p></li>

<li class="calibre4">
<p class="calibre1">Make a note of all mutable reference-type properties, as these are the ones that spoil automatic value semantics. Set their access level below the value-semantics level.
</p></li>

<li class="calibre4">
<p class="calibre1">Define setters and mutating functions at and above the value-semantics access level so that they never actually modify a shared instance of those reference-type properties but instead assign a copy of the instance to the reference-type property.
</p></li>
</ol>

<h4 class="segment-title2">Sidebar: Sendable</h4>

<p class="calibre1">While the benefits of value semantics may seem subtle, the recipe above is fairly simple at the end of the day. In fact, the recipe is so simple that you might wonder: couldn’t the compiler lend a hand?
</p>
<p class="calibre1">For instance, wouldn’t it be nice if the compiler let you somehow <i class="calibre2">mark</i> a type as having value semantics? For instance, by letting you declare that a type is <code class="calibre9">ValueSemantic</code>? And if the compiler knew that primitive types like <code class="calibre9">Int</code> and <code class="calibre9">String</code> are all intrinsically <code class="calibre9">ValueSemantic</code>?
</p>
<p class="calibre1">And that <code class="calibre9">struct</code>s, <code class="calibre9">enum</code>s, and tuples can only be <code class="calibre9">ValueSemantic</code> when all of their members or associated values are also <code class="calibre9">ValueSemantic</code>? And that <code class="calibre9">class</code> types can only be <code class="calibre9">ValueSemantic</code> when they contain only immutable stored properties that are also <code class="calibre9">ValueSemantic</code>? This is, after all, the essence of the recipe.
</p>
<p class="calibre1">If the compiler knew all that, it could validate the types you declare as <code class="calibre9">ValueSemantic</code>. It could even <i class="calibre2">generate</i> those declarations, automatically detecting that certain types are <code class="calibre9">ValueSemantic</code>.
</p>
<p class="calibre1">In fact, as of Swift 5.5, the compiler does this &ndash; but <code class="calibre9">ValueSemantic</code>is the new protocol <code class="calibre9">Sendable</code>, which is a <em class="calibre5">marker protocol</em>. Why finally introduce _ direct_ compiler support for a feature, value semantics, which has long been deeply embedded in the language and libraries <i class="calibre2">implicitly</i>? And why call it <code class="calibre9">Sendable</code>?
</p>
<p class="calibre1">Recall that a key benefit of value semantics is that it makes types immune from side effects, aiding local reasoning. This property is invaluable in concurrent programming since it ensures you can pass a value from one concurrency domain to another completely, eliminating the risk that the value will be mutated from two concurrent domains. This guarantee is the motivation for <code class="calibre9">Sendable</code>.
</p>
<p class="calibre1"><code class="calibre9">Sendable</code> is arriving in Swift as one of a set of carefully integrated features to support concurrent programming. It’s called “Sendable” to indicate that a value is safe to send from one domain to another. When the compiler sees code that tries to pass a non-<code class="calibre9">Sendable</code> value across domains, it raises an error at compile-time, preventing the sort of concurrency bug which is notoriously hard to understand at runtime. You’ll learn more about Swift’s concurrency features in Chapter 29, “Concurrency”.
</p>
<p class="calibre1">So can we treat <code class="calibre9">Sendable</code> as a synonym for having value semantics? Not quite, because <code class="calibre9">Sendable</code> is designed primarily with concurrency in mind. For instance, there is no facility to specify an access level. Also, Swift documentation has not yet been updated to specify which standard types are <code class="calibre9">Sendable</code> and it is not trivial to check this programmatically. But it is worth watching this new feature closely to see how much we can lean on it as an explicit, compiler-enforced way to keep track of value semantics, an essential aspect of a type that used to be visible only to those with a discerning eye.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Here are some challenges to test your knowledge of value types, reference types, and value semantics before moving on. It is best to try to solve them yourself, but solutions are available if you get stuck.
</p>
<p class="calibre1">These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Image with value semantics</h3>

<p class="calibre1">Build a new type, <code class="calibre9">Image</code>, that represents a simple image. It should also provide mutating functions that apply modifications to the image. Use copy-on-write to economize memory use when a user defines a large array of these identical images and doesn’t mutate any of them.
</p>
<p class="calibre1">To get started, assume you’re using the following Pixels class for the raw storage:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-number">Pixels</span> {
  <span class="hljs-keyword">let</span> storageBuffer: <span class="hljs-built_in">UnsafeMutableBufferPointer</span>&lt;<span class="hljs-built_in">UInt8</span>&gt;

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">size</span>: <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">value</span>: <span class="hljs-built_in">UInt8</span>) {
    <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> <span class="hljs-built_in">UnsafeMutablePointer</span>&lt;<span class="hljs-built_in">UInt8</span>&gt;.allocate(capacity: size)
    storageBuffer <span class="hljs-operator">=</span> <span class="hljs-built_in">UnsafeMutableBufferPointer</span>&lt;<span class="hljs-built_in">UInt8</span>&gt;(start: p, count: size)
    storageBuffer.initialize(from: <span class="hljs-built_in">repeatElement</span>(value, count: size))
  }

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">pixels</span>: <span class="hljs-built_in">Pixels</span>) {
    <span class="hljs-keyword">let</span> otherStorage <span class="hljs-operator">=</span> pixels.storageBuffer
    <span class="hljs-keyword">let</span> p  <span class="hljs-operator">=</span> <span class="hljs-built_in">UnsafeMutablePointer</span>&lt;<span class="hljs-built_in">UInt8</span>&gt;.allocate(capacity: otherStorage.count)
    storageBuffer <span class="hljs-operator">=</span> <span class="hljs-built_in">UnsafeMutableBufferPointer</span>&lt;<span class="hljs-built_in">UInt8</span>&gt;(start: p, count: otherStorage.count)
    storageBuffer.initialize(from: otherStorage)
  }
  
  <span class="hljs-keyword">subscript</span>(<span class="hljs-built_in">offset</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">UInt8</span> {
    <span class="hljs-keyword">get</span> {
      storageBuffer[offset]
    }
    <span class="hljs-keyword">set</span> {
      storageBuffer[offset] <span class="hljs-operator">=</span> newValue
    }
  }
  
  <span class="hljs-keyword">deinit</span> {
    storageBuffer.baseAddress<span class="hljs-operator">!</span>.deallocate(capacity: <span class="hljs-keyword">self</span>.storageBuffer.count)
  }
}</pre>
<p class="calibre1">Your image should be able to set and get individual pixel values and set all values at once. Typical usage:
</p><pre class="code-block"><span class="hljs-keyword">var</span> image1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Image</span>(width: <span class="hljs-number">4</span>, height: <span class="hljs-number">4</span>, value: <span class="hljs-number">0</span>)

<span class="hljs-comment">// test setting and getting</span>
image1[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 0 </span>
image1[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
image1[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 100</span>
image1[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] <span class="hljs-comment">// -&gt; 0</span>

<span class="hljs-comment">// copy</span>
<span class="hljs-keyword">var</span> image2 <span class="hljs-operator">=</span> image1
image2[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 100</span>
image1[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
image1[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 2</span>
image2[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 100 because of copy-on-write</span>

<span class="hljs-keyword">var</span> image3 <span class="hljs-operator">=</span> image2
image3.clear(with: <span class="hljs-number">255</span>)
image3[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 255</span>
image2[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-comment">// -&gt; 100 thanks again, copy-on-write</span></pre>
<h3 class="segment-title2">Challenge 2: Enhancing <code class="calibre12">UIImage</code></h3>

<p class="calibre1">Pretend you’re Apple and want to modify <code class="calibre9">UIImage</code> to replace it with a value type with the mutating functions described above. Could you do make it backward compatible with code that uses the existing <code class="calibre9">UIImage</code> API?
</p>
<h3 class="segment-title2">Challenge 3: Determining if a type has value semantics</h3>

<p class="calibre1">Consider the test snippet used to determine if a type has value semantics. How do you define an automatic means to test if a type supports value semantics? If I handed you a type, could you know for sure if it offers value semantics? What if you could not see its implementation? Could the compiler be expected to know?
</p>
<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Value types and reference types differ in their <i class="calibre2">assignment behavior</i>. Value types use assign-by-copy; reference types use assign-by-reference. This behavior describes whether a variable copies or refers to the instance assigned to it.
</p></li>

<li class="calibre4">
<p class="calibre1">This assignment behavior affects not only variables but also function calls.
</p></li>

<li class="calibre4">
<p class="calibre1">Value types help you implement types with <i class="calibre2">value semantics</i>. A type has value semantics if assigning to a variable seems to create a completely independent instance. When this is the case, the only way to affect a variable’s value is through the variable itself. You can then simply think about variables as if instances and references did not exist.
</p></li>

<li class="calibre4">
<p class="calibre1">Primitive value types and immutable reference types have value semantics automatically. Value types that contain reference types, such as mixed types, will only have value semantics if they are engineered that way. For instance, they might only share immutable properties or privately copy shared components on mutation.
</p></li>

<li class="calibre4">
<p class="calibre1">Structural sharing is when distinct instances refer to a common backing instance that contributes to their value. This sharing economizes storage since multiple instances can depend on one large shared resource. But suppose one instance can modify the shared backing instance. In that case, it can indirectly change the value of other instances so that the distinct instances are not fully independent, undermining value semantics.
</p></li>
</ul>

<p class="calibre1">Copy-on-write is the optimization pattern where a type relies on structural sharing and preserves value semantics by copying its backing instance only when it is mutated. This sharing allows the efficiency of a reference type in the read-only case while deferring the cost of instance copying in the read-write case.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Reference types also have value semantics if you define them as entirely <i class="calibre2">immutable</i>, meaning that they cannot be modified after initialization. To do this, all of the type’s stored properties need to be read-only with value semantics.
</p></li>
</ul>

<h2 class="segment-chapter1">Where to go from here?</h2>

<p class="calibre1">The best place to explore advanced implementations of value semantic types is in the Swift standard library, which relies extensively on these optimizations.
</p>
<p class="calibre1">Apple and many practitioners in the wider community have written about value types and value-oriented programming more generally. Here are some relevant videos available online:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">WWDC 2016, session 207: What’s New in Foundation for Swift <a href="https://developer.apple.com/videos/play/wwdc2016/207/" class="calibre6">https://developer.apple.com/videos/play/wwdc2016/207/</a>. Apple.
</p></li>

<li class="calibre4">
<p class="calibre1">WWDC 2015, session 414: Building Better Apps with Value Types <a href="https://developer.apple.com/videos/play/wwdc2015/414/" class="calibre6">https://developer.apple.com/videos/play/wwdc2015/414/</a>. Apple.
</p></li>

<li class="calibre4">
<p class="calibre1">Controlling Complexity in Swift <a href="http://bit.ly/control-complexity" class="calibre6">http://bit.ly/control-complexity</a>. Andy Matuschak.
</p></li>

<li class="calibre4">
<p class="calibre1">Value of Values <a href="https://www.infoq.com/presentations/Value-Values" class="calibre6">https://www.infoq.com/presentations/Value-Values</a>. Rich Hickey.
</p></li>

<li class="calibre4">
<p class="calibre1">Value Semantics versus Value Types <a href="http://bit.ly/swift-value-semantics-not-types" class="calibre6">http://bit.ly/swift-value-semantics-not-types</a>. Your humble author.
</p></li>

<li class="calibre4">
<p class="calibre1">Episode 71: “Polymorphic interfaces”, in Swift by Sundell <a href="https://www.swiftbysundell.com/podcast/71/" class="calibre6">https://www.swiftbysundell.com/podcast/71/</a>. Dave Abrahams, a former member of the Swift core team.
</p></li>
</ul>

<p class="calibre1">These talks offer a perspective that is complementary to the one in this chapter. However, only the last two resources focus on the distinctions between value types, as defined by assignment behavior, and value semantics, defined by the independence of variable values. Dave’s discussion of value semantics, which starts around the 54-minute mark of the interview, is particularly helpful for seeing the historical roots in functional programming and C++ assignment behaviors and dispelling the widespread misunderstanding that “copy-on-write” is a kind of semantics rather than a performance optimization.
</p></div>

<div class="segment-title" id="calibre_link-18">


<h1 class="segment-chapter">Chapter 26: Property Wrappers</h1>

<p class="calibre1">Back in Chapter 11, “Properties”, you learned about <em class="calibre5">property observers</em> and how you can use them to affect the behavior of properties in a type. Property wrappers take that idea to the next level by letting you name and reuse the custom logic. They do this by moving the custom logic to an auxiliary type, which you may define.
</p>
<p class="calibre1">If you’ve worked with SwiftUI, you’ve run into property wrappers (and their telltale @-based, $-happy syntax) already. SwiftUI uses them extensively because they allow virtually unlimited customization of property semantics, which SwiftUI needs to do its view update and data synchronization magic behind the scenes.
</p>
<p class="calibre1">The Swift core team worked hard to make property wrappers a general-purpose language feature. They’re already being used outside the Apple ecosystem &mdash; for example, on the Vapor project. Property wrappers, in this context, let you define a data model and map it to a database like PostgreSQL.
</p>
<p class="calibre1">To learn the ins and outs of property wrappers, you’ll continue with some abstractions from the last chapter. You’ll begin with a simple example and then see an implementation for the copy-on-write pattern. Finally, you’ll wrap up with another example that will show you some things to watch out for when using this language feature.
</p>
<h2 class="segment-chapter1">Basic example</h2>

<p class="calibre1">To start with a simple use case for property wrappers, think back to the <code class="calibre9">Color</code> type from the last chapter. It looked like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Color</span> {
  <span class="hljs-keyword">var</span> red: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">var</span> green: <span class="hljs-built_in">Double</span>  
  <span class="hljs-keyword">var</span> blue: <span class="hljs-built_in">Double</span>
}</pre>
<p class="calibre1">There was an implicit assumption that the values <code class="calibre9">red</code>, <code class="calibre9">green</code> and <code class="calibre9">blue</code> fall between zero and one. You could have stated that requirement as a comment, but it’s much better to enlist the compiler’s help. To do that, create a property wrapper, like this:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>                                           <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">ZeroToOne</span> {                                         <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">clamped</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">input</span>: <span class="hljs-built_in">Double</span>) -&gt; <span class="hljs-built_in">Double</span> { <span class="hljs-comment">// 3</span>
    <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(input, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
  }

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">Double</span>) {
    value <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span>.clamped(wrappedValue)                     <span class="hljs-comment">// 4</span>
  }

  <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">Double</span> {                               <span class="hljs-comment">// 5</span>
    <span class="hljs-keyword">get</span> { value }
    <span class="hljs-keyword">set</span> { value <span class="hljs-operator">=</span>  <span class="hljs-keyword">Self</span>.clamped(newValue) }
  }
}</pre>
<p class="calibre1">What’s so special here? Here’s what’s going on:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The attribute <code class="calibre9">@propertyWrapper</code> says that this type can be used as a property wrapper. As such, it <i class="calibre2">must</i> vend a property called <code class="calibre9">wrappedValue</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">In every other aspect, it’s just a standard type. In this case, it’s a struct with a private variable <code class="calibre9">value</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">The private static <code class="calibre9">clamped(_:)</code> helper method does a min/max dance to keep values between zero and one.
</p></li>

<li class="calibre4">
<p class="calibre1">A wrapped value initializer is required for property wrapper types.
</p></li>

<li class="calibre4">
<p class="calibre1">The <code class="calibre9">wrappedValue</code> vends the clamped value.
</p></li>
</ol>

<p class="calibre1">Now, you can use the property wrapper to add behavior to the color properties:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Color</span> {
  <span class="hljs-number">@ZeroToOne</span> <span class="hljs-keyword">var</span> red: <span class="hljs-built_in">Double</span>
  <span class="hljs-number">@ZeroToOne</span> <span class="hljs-keyword">var</span> green: <span class="hljs-built_in">Double</span>
  <span class="hljs-number">@ZeroToOne</span> <span class="hljs-keyword">var</span> blue: <span class="hljs-built_in">Double</span>
}</pre>
<p class="calibre1">That’s all it takes to guarantee the values are always locked between zero and one. Try it out with this:
</p><pre class="code-block"><span class="hljs-keyword">var</span> superRed <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>(red: <span class="hljs-number">2</span>, green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(superRed) 
<span class="hljs-comment">// r: 1, g: 0, b: 0</span>

superRed.blue <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">2</span>
<span class="hljs-built_in">print</span>(superRed) 
<span class="hljs-comment">// r: 1, g: 0, b: 0</span></pre>
<p class="calibre1">No matter how hard you try, you can never get it to go outside the zero-to-one bound.
</p>
<p class="calibre1">Beginning in Swift 5.5, you can use property wrappers with function arguments, too. Try this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printValue</span>(<span class="hljs-number">@ZeroToOne</span> <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Double</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The wrapped value is"</span>, value)
}

printValue(<span class="hljs-number">3.14</span>)</pre>
<p class="calibre1">Here, the wrapped value printed is <code class="calibre9">1.0</code>. <code class="calibre9">@ZeroToOne</code> adds clamping behavior to passed values. Pretty cool.
</p>
<h3 class="segment-title2">Projecting values with $</h3>

<p class="calibre1">In the above example, you clamp the wrapped value between zero and one &mdash; but you potentially lose the original value. To remedy this, you can use another feature of property wrappers. In addition to <code class="calibre9">wrappedValue</code>, property wrappers vend another type called <code class="calibre9">projectedValue</code>. You can use this to offer direct access to the unclamped value like this:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">ZeroToOneV2</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">Double</span>) {
    value <span class="hljs-operator">=</span> wrappedValue
  }

  <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">get</span> { <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(value, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>) }
    <span class="hljs-keyword">set</span> { value <span class="hljs-operator">=</span> newValue }
  }

  <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-built_in">Double</span> { value }
}</pre>
<p class="calibre1">In this version, the initializer and setter assign the value without clamping it. Instead, the <code class="calibre9">wrappedValue</code> getter does the clamping. This lets you use the projected value, which you access with <code class="calibre9">$</code>, to get the raw value.
</p>
<p class="calibre1">Test it out with this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printValueV2</span>(<span class="hljs-number">@ZeroToOneV2</span> <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Double</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The wrapped value is"</span>, value)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The projected value is"</span>, <span class="hljs-variable">$value</span>)
}

printValueV2(<span class="hljs-number">3.14</span>)</pre>
<p class="calibre1">Not surprisingly, this prints out <code class="calibre9">1.0</code> for the wrapped value and <code class="calibre9">3.14</code> for the projected value. The wrapped value, <code class="calibre9">value</code>, and projected value, <code class="calibre9">$value</code>, are both <code class="calibre9">Double</code>s in this example. However, as you’ll see later on, this doesn’t have to be the case.
</p>
<h3 class="segment-title2">Adding parameters</h3>

<p class="calibre1">The example clamps between zero and one, but you could imagine wanting to clamp between zero and 100 &mdash; or any other number greater than zero. You can do that with another parameter: <code class="calibre9">upper</code>. Try this definition:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">ZeroTo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span>
  <span class="hljs-keyword">let</span> upper: <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">Double</span>, <span class="hljs-built_in">upper</span>: <span class="hljs-built_in">Double</span>) {
    value <span class="hljs-operator">=</span> wrappedValue
    <span class="hljs-keyword">self</span>.upper <span class="hljs-operator">=</span> upper
  }

  <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">get</span> { <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(value, <span class="hljs-number">0</span>), upper) }
    <span class="hljs-keyword">set</span> { value <span class="hljs-operator">=</span> newValue }
  }

  <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-built_in">Double</span> { value }
}</pre>
<p class="calibre1">This version adds an upper bound that you must specify. Try it out in the playground:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">printValueV3</span>(<span class="hljs-number">@ZeroTo</span>(upper: <span class="hljs-number">10</span>) <span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">Double</span>) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The wrapped value is"</span>, value)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"The projected value is"</span>, <span class="hljs-variable">$value</span>)
}
printValueV3(<span class="hljs-number">42</span>)</pre>
<p class="calibre1">To specify the <code class="calibre9">upper</code> parameter, you write the property wrapper like this: <code class="calibre9">@ZeroTo(upper: 10)</code>. This example will print <code class="calibre9">10</code> for the wrapped value and <code class="calibre9">42</code> as the projected value, respectively.
</p>
<h3 class="segment-title2">Going generic</h3>

<p class="calibre1">In the example, you used a <code class="calibre9">Double</code> for the wrapped value. The property wrapper can also be generic with respect to the wrapped value. Try this:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">ZeroTo</span>&lt;<span class="hljs-number">Value</span>: <span class="hljs-number">Numeric</span> &amp; <span class="hljs-number">Comparable</span>&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Value</span>
  <span class="hljs-keyword">let</span> upper: <span class="hljs-built_in">Value</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">Value</span>, <span class="hljs-built_in">upper</span>: <span class="hljs-built_in">Value</span>) {
    value <span class="hljs-operator">=</span> wrappedValue
    <span class="hljs-keyword">self</span>.upper <span class="hljs-operator">=</span> upper
  }

  <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">Value</span> {
    <span class="hljs-keyword">get</span> { <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(value, <span class="hljs-number">0</span>), upper) }
    <span class="hljs-keyword">set</span> { value <span class="hljs-operator">=</span> newValue }
  }

  <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-built_in">Value</span> { value }
}</pre>
<p class="calibre1">Instead of <code class="calibre9">Double</code>, this version uses the generic placeholder <code class="calibre9">Value</code> everywhere. You can use it just like you did before, except this time, you can use it with <code class="calibre9">Double</code>, <code class="calibre9">Float</code>, <code class="calibre9">Float16</code>, <code class="calibre9">Int</code> and so on.  The compiler infers the <code class="calibre9">Value</code> type from the wrapped type you use, and this type only needs to fulfill the requirement that it’s <code class="calibre9">Numeric</code> and <code class="calibre9">Comparable</code>.
</p>
<h2 class="segment-chapter1">Implementing CopyOnWrite</h2>

<p class="calibre1">Now that you have the basic mechanics of property wrappers under your belt, it’s time to look at some more detailed examples.
</p>
<p class="calibre1">As the discussion from the last chapter shows, the copy-on-write pattern is verbose. You need to define the private, stored reference-type property for the backing storage (the <code class="calibre9">bucket</code>) <i class="calibre2">and</i> the visible, computed property that preserves value semantics (the <code class="calibre9">bucketColor</code>). Then, in the getter and setter, you also need to define the copy-on-write logic.
</p>
<p class="calibre1">As you might have expected, this is also an example of a pattern you can simplify by using <em class="calibre5">property wrappers</em>.
</p>
<p class="calibre1">Recall that, in the previous chapter, you defined <code class="calibre9">PaintingPlan</code> with a computed property <code class="calibre9">bucketColor</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> { <span class="hljs-comment">// a value type, containing ...</span>
  <span class="hljs-comment">// ... </span>

  <span class="hljs-comment">// a computed property facade over deep storage</span>
  <span class="hljs-comment">// with copy-on-write and in-place mutation when possible</span>
  <span class="hljs-keyword">var</span> bucketColor: <span class="hljs-built_in">Color</span> {
    <span class="hljs-keyword">get</span> {
      bucket.color
    }
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>bucket) {
        bucket.color <span class="hljs-operator">=</span> bucketColor
      } <span class="hljs-keyword">else</span> {
        bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: newValue)
      }
    }
  }
}</pre>
<p class="calibre1">With a <code class="calibre9">CopyOnWriteColor</code> property wrapper, you can replace the above code with this simpler code:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> {
  <span class="hljs-number">@CopyOnWriteColor</span> <span class="hljs-keyword">var</span> bucketColor <span class="hljs-operator">=</span> .blue
}</pre>
<p class="calibre1">Just as before, this handy syntax lets you create dozens of copy-on-write properties. But how does it work?
</p>
<h3 class="segment-title2">Compiler expansion</h3>

<p class="calibre1">The compiler automatically expands <code class="calibre9">@CopyOnWriteColor var bucketColor = .blue</code> into the following:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _bucketColor <span class="hljs-operator">=</span> <span class="hljs-built_in">CopyOnWriteColor</span>(wrappedValue: .blue)

<span class="hljs-keyword">var</span> bucketColor: <span class="hljs-built_in">Color</span> {
  <span class="hljs-keyword">get</span> { _bucketColor.wrappedValue }
  <span class="hljs-keyword">set</span> { _bucketColor.wrappedValue <span class="hljs-operator">=</span> newValue }
}</pre>
<p class="calibre1">This substitution reproduces parts of the original version of your code, including the internal computed property <code class="calibre9">bucketColor</code> and the private storage property <code class="calibre9">_bucketColor</code>.
</p>
<p class="calibre1">But where did all the tricky logic go? It now lives in a <em class="calibre5">dedicated custom property wrapper type</em>, <code class="calibre9">CopyOnWriteColor</code>, which enables the custom <code class="calibre9">@CopyOnWriteColor</code>. <code class="calibre9">CopyOnWriteColor</code> has the same type as the private <code class="calibre9">_bucketColor</code>, which serves as the actual underlying stored property.
</p>
<p class="calibre1">Here’s the definition of <code class="calibre9">CopyOnWriteColor</code>:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">CopyOnWriteColor</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> bucket: <span class="hljs-built_in">Bucket</span>

  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">Color</span>) {
    <span class="hljs-keyword">self</span>.bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color: wrappedValue)
  }

  <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">Color</span> {
    <span class="hljs-keyword">get</span> {
      bucket.color
    }
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>bucket) {
        bucket.color <span class="hljs-operator">=</span> newValue
      } <span class="hljs-keyword">else</span> {
        bucket <span class="hljs-operator">=</span> <span class="hljs-built_in">Bucket</span>(color:newValue)
      }
    }
  }
}</pre>
<p class="calibre1">In <code class="calibre9">PaintingPlan</code>, assigning an initial value of <code class="calibre9">.blue</code> to <code class="calibre9">bucketColor</code> initializes an instance of the property wrapper <code class="calibre9">CopyOnWriteColor</code>, which defines its own <code class="calibre9">bucket</code>.
</p>
<p class="calibre1">Then, when you read or write <code class="calibre9">bucketColor</code>, you call the getters and setters of the computed property <code class="calibre9">wrappedValue</code> in <code class="calibre9">CopyOnWriteColor</code>. These getters and setters implement the same copy-on-write logic as your original implementation.
</p>
<p class="calibre1">It’s a bit opaque because of the two levels of delegation: first through the property wrapper and then through its computed property. But, at its core, this is just plain old code reuse. You write the tricky copy-on-write logic just once, then refer to it whenever you use the custom attribute. It’s easy to write a more elaborate painting plan:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">PaintingPlan</span> {
  <span class="hljs-keyword">var</span> accent <span class="hljs-operator">=</span> <span class="hljs-built_in">Color</span>.white

  <span class="hljs-number">@CopyOnWriteColor</span> <span class="hljs-keyword">var</span> bucketColor <span class="hljs-operator">=</span> .blue
  <span class="hljs-number">@CopyOnWriteColor</span> <span class="hljs-keyword">var</span> bucketColorForDoor <span class="hljs-operator">=</span> .blue
  <span class="hljs-number">@CopyOnWriteColor</span> <span class="hljs-keyword">var</span> bucketColorForWalls <span class="hljs-operator">=</span> .blue
  <span class="hljs-comment">// ...</span>
}</pre>
<p class="calibre1">As you saw earlier, property wrappers can be generic, making them even more reusable. You’ll explore generic property wrappers again for copy-on-write in a challenge later in the chapter.
</p>
<h2 class="segment-chapter1">Wrappers, projections and other confusables</h2>

<p class="calibre1">When you think about property wrappers as shorthand that the compiler automatically expands, it’s clear that there’s nothing magical about them &mdash; but if you aren’t careful, thinking about them only in this way can tempt you to create unintuitive ones. To work with them day-to-day, you only need to focus on a few key terms: <em class="calibre5">property wrapper</em>, <em class="calibre5">wrapped value</em> and <em class="calibre5">projected value</em>.
</p>
<p class="calibre1">The secret to these terms is not to take them literally because the names are misleading. To make their functions clearer, here’s a short set of working definitions:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">A <em class="calibre5">property wrapper</em>: Defines and presents a property via its <code class="calibre9">wrappedValue</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">A <em class="calibre5">wrapped value</em>: Simply the value a property wrapper presents as <code class="calibre9">wrappedValue</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">A <em class="calibre5">projected value</em>: An arbitrary value exposed by a property wrapper via <code class="calibre9">$</code> syntax. It might not have any relationship at all with the wrapped value.
</p></li>
</ol>

<p class="calibre1">So how do these terms apply to the painting plan example?
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">@CopyOnWriteColor</code> creates a <code class="calibre9">CopyOnWriteColor</code> instance. That instance <i class="calibre2">is</i> the property wrapper.
</p></li>

<li class="calibre4">
<p class="calibre1">A client interacts with the instance via its <code class="calibre9">wrappedValue</code> property. This <i class="calibre2">is</i> the wrapped value.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">CopyOnWriteColor</code> doesn’t offer a projected value at all.
</p></li>
</ul>

<p class="calibre1">Note that the type of <code class="calibre9">wrappedValue</code> matches the type of the stored property <code class="calibre9">bucketColor</code> (<code class="calibre9">Color</code>). This property would exist even if you didn’t apply the wrapper. However, once you apply the property, it is <i class="calibre2">not</i> the case that the original stored property still exists “underneath the wrapper” in any sense. In other words, the wrapping is purely <em class="calibre5">conceptual</em>, not physical.
</p>
<h2 class="segment-chapter1">Projected values are handles</h2>

<p class="calibre1">A projected value is nothing more than an additional handle that a property wrapper can offer. As you saw earlier, it’s defined by <code class="calibre9">projectedValue</code> and exposed as <code class="calibre9">$name</code>, where “name” is the name of the wrapped property.
</p>
<p class="calibre1">Projected values don’t need to have the same type as the projected value. To illustrate projected values further, you’ll create a new example that uses property wrappers to transform values.
</p>
<p class="calibre1">Suppose you are reading in a text file, formatted as comma-separated values (CSV). Every row contains key dates about a product order, such as when the order was placed, shipped and delivered. You load these dates into a struct.
</p>
<p class="calibre1">You also want to validate that the dates are written in your preferred date format: <code class="calibre9">yyyy-mm-dd</code>. For instance, you’d write Swift’s birthday, June 2, 2014, as <code class="calibre9">"2014-06-02"</code>.
</p>
<p class="calibre1">You could enforce this validation by applying a <code class="calibre9">@ValidatedDate</code> annotation, as follows:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Order</span> {
  <span class="hljs-number">@ValidatedDate</span> <span class="hljs-keyword">var</span> orderPlacedDate: <span class="hljs-built_in">String</span>
  <span class="hljs-number">@ValidatedDate</span> <span class="hljs-keyword">var</span> shippingDate: <span class="hljs-built_in">String</span>
  <span class="hljs-number">@ValidatedDate</span> <span class="hljs-keyword">var</span> deliveredDate: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">To achieve this, you define this property wrapper:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-number">ValidatedDate</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storage: <span class="hljs-built_in">Date</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>
  <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> formatter <span class="hljs-operator">=</span> <span class="hljs-built_in">DateFormatter</span>()

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-built_in">wrappedValue</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.formatter.dateFormat <span class="hljs-operator">=</span> <span class="hljs-string">"yyyy-mm-dd"</span>
    <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">set</span> {
      <span class="hljs-keyword">self</span>.storage <span class="hljs-operator">=</span> formatter.date(from: newValue)
    }
    <span class="hljs-keyword">get</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.storage { 
        <span class="hljs-keyword">return</span> formatter.string(from: date) 
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"invalid"</span>
      }
    }
  }
}</pre>
<p class="calibre1">The property wrapper encapsulates the conversion logic. Whenever you store a date string like <code class="calibre9">"2014-06-02"</code> in <code class="calibre9">orderPlacedDate</code>, you convert that string and store it as a <code class="calibre9">Date</code> in the wrapper’s <code class="calibre9">storage</code>. Whenever you read the property, you convert it back to a string. If you try to store an invalid string, <code class="calibre9">wrappedValue</code> will return <code class="calibre9">"invalid"</code>.
</p>
<p class="calibre1">But what if, for instance, you wanted to change the date format you’re using? For that, you need a way to get at the property wrapper itself, not just its <code class="calibre9">wrappedValue</code>. <code class="calibre9">projectedValue</code> does just that.
</p>
<p class="calibre1">You can make the projected value anything, including the date formatter object:
</p><pre class="code-block"><span class="hljs-keyword">@propertyWrapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-number">ValidatedDate</span> {
  <span class="hljs-comment">// ... as above ...</span>

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-built_in">DateFormatter</span> {
    <span class="hljs-keyword">get</span> { formatter }
    <span class="hljs-keyword">set</span> { formatter <span class="hljs-operator">=</span> newValue }
  }
}</pre>
<p class="calibre1">Updating the wrapper’s <code class="calibre9">projectedValue</code> updates the underlying <code class="calibre9">DateFormatter</code> to use a new date format.
</p>
<p class="calibre1">You access the projected value with a <code class="calibre9">$</code>. Just as a reference to the wrapped property <code class="calibre9">orderPlaceDate</code> really accesses the wrapper’s <code class="calibre9">wrappedValue</code>, a reference to <code class="calibre9">$orderPlacedDate</code> really accesses the wrapper’s <code class="calibre9">projectedValue</code>.
</p>
<p class="calibre1">This example shows the syntax in action:
</p><pre class="code-block"><span class="hljs-keyword">var</span> o <span class="hljs-operator">=</span> <span class="hljs-built_in">Order</span>()
<span class="hljs-comment">// store a valid date string</span>
o.orderPlacedDate <span class="hljs-operator">=</span> <span class="hljs-string">"2014-06-02"</span>
o.orderPlacedDate <span class="hljs-comment">// =&gt; 2014-06-02</span>

<span class="hljs-comment">// update the date format using the projected value</span>
<span class="hljs-keyword">let</span> otherFormatter <span class="hljs-operator">=</span> <span class="hljs-built_in">DateFormatter</span>()
otherFormatter.dateFormat <span class="hljs-operator">=</span> <span class="hljs-string">"mm/dd/yyyy"</span>
order.<span class="hljs-variable">$orderPlacedDate</span> <span class="hljs-operator">=</span> otherFormatter

<span class="hljs-comment">// read the string in the new format</span>
order.orderPlacedDate <span class="hljs-comment">// =&gt; "06/02/2014"</span></pre>
<p class="calibre1">As this example shows, you can use a property wrapper’s projected value for anything. The lesson here is that you must study the property wrapper’s documentation to understand the meaning of <code class="calibre9">$name</code> in any particular case. A <code class="calibre9">$</code> could mean anything.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<h3 class="segment-title2">Challenge 1: Create a generic property wrapper for CopyOnWrite</h3>

<p class="calibre1">Consider the property wrapper <code class="calibre9">CopyOnWriteColor</code>, which you defined earlier in this chapter. It lets you wrap any variable of type <code class="calibre9">Color</code>. It manages the sharing of an underlying storage type, <code class="calibre9">Bucket</code>, which owns a single <code class="calibre9">Color</code> instance. Thanks to structural sharing, multiple <code class="calibre9">CopyOnWriteColor</code> instances might share the same <code class="calibre9">Bucket</code> instance &mdash; thus sharing its <code class="calibre9">Color</code> instance and saving memory.
</p>
<p class="calibre1">To implement the copy-on-write logic, what matters about <code class="calibre9">Bucket</code> is not its domain semantics, like <code class="calibre9">isRefilled</code>, but just that it’s a reference type. You only used it as a <i class="calibre2">box</i> for <code class="calibre9">Color</code>.
</p>
<p class="calibre1">Since property wrappers can be generic, try your hand at defining a <em class="calibre5">generic</em> copy-on-write property wrapper type, <code class="calibre9">CopyOnWrite</code>. Instead of being able to wrap only <code class="calibre9">Color</code> values, it should be generic over any value semantic that it wraps. Instead of using a dedicated storage type like <code class="calibre9">Bucket</code>, it should provide its own box type to act as storage.
</p>
<p class="calibre1">Your challenge: Write the definition for this generic type, <code class="calibre9">CopyOnWrite</code>, and use it in an example to verify that the wrapped properties preserve the value semantics of the original type.
</p>
<p class="calibre1">To get you started, here’s a suitable definition of a box type:
</p><pre class="code-block"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-number">StorageBox</span>&lt;<span class="hljs-number">StoredValue</span>&gt; {

  <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">StoredValue</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">value</span>: <span class="hljs-built_in">StoredValue</span>) {
    <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value
  }
}</pre>
<h3 class="segment-title2">Challenge 2: Implement @ValueSemantic</h3>

<p class="calibre1">Using <code class="calibre9">StorageBox</code> from the previous challenge and the following protocol, <code class="calibre9">DeepCopyable</code>, as a constraint, write the definition for a generic property wrapper <code class="calibre9">@ValueSemantic</code>. Then use it in an example to verify that wrapped properties have value semantics even when wrapping an underlying type that doesn’t. Example: <code class="calibre9">NSMutableString</code> is an example of a non-value semantic type.  Make it conform to <code class="calibre9">DeepCopyable</code> and test it with <code class="calibre9">@ValueSemantic</code>.
</p>
<p class="calibre1">Hints:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">If the <code class="calibre9">DeepCopyable</code> conforming type is a reference type or otherwise doesn’t have value semantics, making a deep copy ensures properties don’t share any storage and changes to one don’t affect the other.
</p></li>

<li class="calibre4">
<p class="calibre1">Note that if the conforming type already has value semantics, it meets these requirements, so it’s enough to return <code class="calibre9">self</code>. In this case, however, there’s no point in using <code class="calibre9">@ValueSemantic</code>.
</p></li>
</ul>
<pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">DeepCopyable</span> {

  <span class="hljs-comment">/* Returns a deep copy of the current instance.

     If `x` is a deep copy of `y`, then:
        - The instance `x` should have the same value as `y` 
          (for some sensible definition of value &ndash; not just 
          memory location or pointer equality!)
        - It should be impossible to do any operation on `x` 
          that will modify the value of the instance `y`.

    Note: A value semantic type implementing this protocol can just 
          return `self` since that fulfills the above requirement.
  */</span>

  <span class="hljs-keyword">func</span> <span class="hljs-number">deepCopy</span>() -&gt; <span class="hljs-keyword">Self</span>
}</pre>
<h2 class="segment-chapter1">Key points</h2>

<p class="calibre1">Property wrappers have a lot of flexibility and power, but you also need to use them with care. Here are some things to remember:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Unusual SwiftUI syntax that uses <code class="calibre9">@</code> and <code class="calibre9">$</code> characters is not unique to SwiftUI. It’s an advanced application of <em class="calibre5">property wrappers</em>, a language feature that anyone can use.
</p></li>

<li class="calibre4">
<p class="calibre1">A property wrapper lets you apply <em class="calibre5">custom logic</em> to define the behavior of reading and writing a property such as <code class="calibre9">@MyWrapper var myproperty</code>. It lets you define this logic so you can reuse it easily over many properties.
</p></li>

<li class="calibre4">
<p class="calibre1">A property wrapper’s <code class="calibre9">wrappedValue</code> defines the external interface to the value, which is exposed as the wrapped property itself, as in <code class="calibre9">myproperty</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">A property wrapper can have a <em class="calibre5">projectedValue</em>, which provides a handle for other interactions with the property wrapper. For example, it’s exposed via the <em class="calibre5">$</em> syntax, as in <code class="calibre9">$myproperty</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Property wrapping is <em class="calibre5">conceptual</em>. It’s doesn’t use the common object-oriented programming pattern where one object acts as an adapter by physically wrapping another actual object. Consequently, there isn’t necessarily a stored property or value that exists untouched “underneath” the wrapper.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-20">


<h1 class="segment-chapter">Chapter 27: Protocol-Oriented Programming</h1>

<p class="calibre1">Apple declared Swift to be the first <i class="calibre2">protocol</i><i class="calibre2">-</i><i class="calibre2">oriented programming language</i>. This declaration was made possible by the introduction of <em class="calibre5">protocol extensions</em>.
</p>
<p class="calibre1">Although protocols have been in Swift since the very beginning, this announcement and the protocol-heavy standard library changes Apple made affect how you think about your types. Extending protocols is the key to an entirely new style of programming!
</p>
<p class="calibre1">In brief, <em class="calibre5">protocol</em><em class="calibre5">-</em><em class="calibre5">oriented programming</em> emphasizes coding to protocols instead of specific classes, structs or enums. It does this by breaking the old rules of protocols and allowing you to write <i class="calibre2">implementations</i> for protocols on the protocols themselves.
</p>
<p class="calibre1">This chapter introduces you to the power of protocol extensions and protocol-oriented programming. Along the way, you’ll learn how to use default implementations, type constraints, mixins and traits to simplify your code vastly.
</p>
<h2 class="segment-chapter1">Introducing protocol extensions</h2>

<p class="calibre1">You’ve seen extensions in previous chapters. They let you add additional methods and computed properties to a type:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">String</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">shout</span>() {
    <span class="hljs-built_in">print</span>(uppercased())
  }
}

<span class="hljs-string">"Swift is pretty cool"</span>.shout()</pre>
<p class="calibre1">Here, you’re extending the <code class="calibre9">String</code> type itself to add a new method. You can extend any type, including ones that you didn’t write yourself, and you can have any number of extensions on a type.
</p>
<p class="calibre1">You can define a <i class="calibre2">protocol</i> extension using the following syntax:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> gamesPlayed: <span class="hljs-built_in">Int</span> {
    wins <span class="hljs-operator">+</span> losses
  }
}</pre>
<p class="calibre1">Like the way you extend a class, struct or enum, you use the keyword <code class="calibre9">extension</code> followed by the name of the protocol you are extending. Within the extension’s braces, you can define additional members on the protocol.
</p>
<p class="calibre1">Compared to the protocol itself, the most significant difference in the definition of a protocol extension is that the extension includes the actual <i class="calibre2">implementation</i> of the member. The example above defines a new computed property named <code class="calibre9">gamesPlayed</code> that combines <code class="calibre9">wins</code> and <code class="calibre9">losses</code> to return the total number of games played.
</p>
<p class="calibre1">Although you haven’t written code for a concrete type adopting the protocol, you can use the protocol members within its extension. That’s because the compiler knows that any type conforming to <code class="calibre9">TeamRecord</code> will have all the members required by <code class="calibre9">TeamRecord</code>.
</p>
<p class="calibre1">Now you can write a simple type that adopts <code class="calibre9">TeamRecord</code> and use <code class="calibre9">gamesPlayed</code> without reimplementing it.
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">BaseballRecord</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)
  }
}

<span class="hljs-keyword">let</span> sanFranciscoSwifts <span class="hljs-operator">=</span> <span class="hljs-built_in">BaseballRecord</span>(wins: <span class="hljs-number">10</span>, losses: <span class="hljs-number">5</span>)
sanFranciscoSwifts.gamesPlayed <span class="hljs-comment">// 15</span></pre>
<p class="calibre1">Since <code class="calibre9">BaseballRecord</code> conforms to <code class="calibre9">TeamRecord</code>, you have access to <code class="calibre9">gamesPlayed</code>, defined in the protocol extension.
</p>
<p class="calibre1">You can see how useful protocol extensions can be to define “free” behavior on a protocol &mdash; but this is only the beginning. Next, you’ll learn how protocol extensions can provide implementations for members of the protocol itself.
</p>
<h2 class="segment-chapter1">Default implementations</h2>

<p class="calibre1">A protocol defines a contract for any type that adopts it. If a protocol defines a method or a property, any type that adopts the protocol must implement that method or property. Consider another example of a <code class="calibre9">TeamRecord</code> type:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">BasketballRecord</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> seasonLength <span class="hljs-operator">=</span> <span class="hljs-number">82</span>

  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)
  }
}</pre>
<p class="calibre1">Both <code class="calibre9">BasketballRecord</code> and <code class="calibre9">BaseballRecord</code> have identical implementations of <code class="calibre9">winningPercentage</code>. You can imagine that most of the <code class="calibre9">TeamRecord</code> types will implement this property the same way. That could lead to a lot of repetitive code.
</p>
<p class="calibre1">Fortunately, Swift has a shortcut:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)
  }
}</pre>
<p class="calibre1">While this is much like the protocol extension you defined in the previous example, it differs in that <code class="calibre9">winningPercentage</code> is a member of the <code class="calibre9">TeamRecord</code> protocol itself, whereas <code class="calibre9">gamesPlayed</code> isn’t. Implementing a member of a protocol in an extension creates a <em class="calibre5">default implementation</em> for that member.
</p>
<p class="calibre1">You’ve already seen default arguments to functions, and this is similar: If you don’t implement <code class="calibre9">winningPercentage</code> in your type, it will use the default implementation provided by the protocol extension.
</p>
<p class="calibre1">In other words, you no longer need to explicitly implement <code class="calibre9">winningPercentage</code> on types that adopt <code class="calibre9">TeamRecord</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">BasketballRecord</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">let</span> seasonLength <span class="hljs-operator">=</span> <span class="hljs-number">82</span>
}

<span class="hljs-keyword">let</span> minneapolisFunctors <span class="hljs-operator">=</span> <span class="hljs-built_in">BasketballRecord</span>(wins: <span class="hljs-number">60</span>, losses: <span class="hljs-number">22</span>)
minneapolisFunctors.winningPercentage</pre>
<p class="calibre1">Default implementations let you add a capability to a protocol while significantly reducing repeated or “boilerplate” code.
</p>
<p class="calibre1">A default implementation doesn’t prevent a type from implementing a protocol member on its own. Some team records may require a slightly different formula for the winning percentage, such as a sport that includes ties as a possible outcome:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">HockeyRecord</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span>

  <span class="hljs-comment">// Hockey record introduces ties, and has</span>
  <span class="hljs-comment">// its own implementation of winningPercentage</span>
  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> ties)
  }
}</pre>
<p class="calibre1">With this change, if you call <code class="calibre9">winningPercentage</code> on a <code class="calibre9">TeamRecord</code> that’s a <code class="calibre9">HockeyRecord</code> value type, it will calculate the winning percentage as a function of wins, losses and ties. If you call <code class="calibre9">winningPercentage</code> on another type that doesn’t have its own implementation, it will fall back to the default implementation:
</p><pre class="code-block"><span class="hljs-keyword">let</span> chicagoOptionals <span class="hljs-operator">=</span> <span class="hljs-built_in">BasketballRecord</span>(wins: <span class="hljs-number">10</span>, losses: <span class="hljs-number">6</span>)
<span class="hljs-keyword">let</span> phoenixStridables <span class="hljs-operator">=</span> <span class="hljs-built_in">HockeyRecord</span>(wins: <span class="hljs-number">8</span>, losses: <span class="hljs-number">7</span>, ties: <span class="hljs-number">1</span>)

chicagoOptionals.winningPercentage <span class="hljs-comment">// 10 / (10 + 6) == 0.625</span>
phoenixStridables.winningPercentage <span class="hljs-comment">// 8 / (8 + 7 + 1) == 0.5</span></pre>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a default implementation on <code class="calibre9">CustomStringConvertible</code> that will simply remind you to implement <code class="calibre9">description</code> by returning <code class="calibre9">Remember to implement CustomStringConvertible!</code>.
</p>
<p class="calibre1">Once you have your default implementation, you can write code like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">MyStruct</span>: <span class="hljs-number">CustomStringConvertible</span> {}
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">MyStruct</span>())
<span class="hljs-comment">// should print "Remember to implement CustomStringConvertible!"</span></pre>
<h2 class="segment-chapter1">Understanding protocol extension dispatch</h2>

<p class="calibre1">There’s a critical pitfall to keep in mind when defining protocol extensions. Interfaces part of the formal protocol declaration are <em class="calibre5">customization points</em> that adopting types can override. If a type <i class="calibre2">defines</i> a method or property in a protocol extension, without <i class="calibre2">declaring</i> it in the protocol itself, <em class="calibre5">static dispatch</em> comes into play. Static dispatch means the compiler chooses the method or property used at compile-time based on what it knows about the type.  The compiler doesn’t account for dynamic runtime information.
</p>
<p class="calibre1">Suppose you defined a protocol similar to <code class="calibre9">TeamRecord</code> called <code class="calibre9">WinLoss</code>:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">WinLoss</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">…and declared the following extension:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">WinLoss</span> {
  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)
  }
}</pre>
<p class="calibre1">…which is adopted by the following type:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">CricketRecord</span>: <span class="hljs-number">WinLoss</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> draws: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> draws)
  }
}</pre>
<p class="calibre1">Observe what happens when you use the <code class="calibre9">winningPercentage</code> property:
</p><pre class="code-block"><span class="hljs-keyword">let</span> miamiTuples <span class="hljs-operator">=</span> <span class="hljs-built_in">CricketRecord</span>(wins: <span class="hljs-number">8</span>, losses: <span class="hljs-number">7</span>, draws: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> winLoss: <span class="hljs-built_in">WinLoss</span> <span class="hljs-operator">=</span> miamiTuples

miamiTuples.winningPercentage <span class="hljs-comment">// 0.5</span>
winLoss.winningPercentage <span class="hljs-comment">// 0.53 !!!</span></pre>
<p class="calibre1">Even though <code class="calibre9">miamiTuples</code> and <code class="calibre9">winLoss</code> contain the same instance, you see different results. This result is because static dispatch chooses an implementation based on the compile-time type: <code class="calibre9">CricketRecord</code> for <code class="calibre9">miamiTuples</code> and <code class="calibre9">WinLoss</code> for <code class="calibre9">winLoss</code>.
</p>
<p class="calibre1">If you declare <code class="calibre9">winningPercentage</code> as part of the formal <code class="calibre9">WinLoss</code> protocol, the implementation in the extension becomes the default implementation that you can override. In this case, the compiler uses <em class="calibre5">dynamic dispatch</em>, which considers underlying runtime types to call the appropriate method or property.
</p>
<p class="calibre1">You’ve seen dynamic dispatch in action in Chapter 14, “Advanced Classes”, as the dispatch method used for overridden properties and methods in class hierarchies.
</p>
<h2 class="segment-chapter1">Type constraints</h2>

<p class="calibre1">For the protocol extensions on <code class="calibre9">TeamRecord</code>, you were able to use members of the <code class="calibre9">TeamRecord</code> protocol, such as <code class="calibre9">wins</code> and <code class="calibre9">losses</code>, within the implementations of <code class="calibre9">winningPercentage</code> and <code class="calibre9">gamesPlayed</code>. Much like in a struct, class, or enum extension, you write code as if you were writing inside the type you’re extending.
</p>
<p class="calibre1">When you write extensions on protocols, there’s an additional dimension to consider: The adopting type could also be any number of <i class="calibre2">other</i> types. In other words, when a type adopts <code class="calibre9">TeamRecord</code>, it could very well also adopt <code class="calibre9">Comparable</code>, <code class="calibre9">CustomStringConvertible</code>, or even another protocol you wrote yourself!
</p>
<p class="calibre1">Swift lets you write extensions for certain adopting types. Using a <em class="calibre5">type constraint</em> on a protocol extension, you’re able to use methods and properties from that type.
</p>
<p class="calibre1">Take the following example of a type constraint:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">PostSeasonEligible</span> {
  <span class="hljs-keyword">var</span> minimumWinsForPlayoffs: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">TeamRecord</span> <span class="hljs-number">where</span> <span class="hljs-number">Self</span>: <span class="hljs-number">PostSeasonEligible</span> {
  <span class="hljs-keyword">var</span> isPlayoffEligible: <span class="hljs-built_in">Bool</span> { 
    wins <span class="hljs-operator">&gt;</span> minimumWinsForPlayoffs
  }
}</pre>
<p class="calibre1">You have a new protocol, <code class="calibre9">PostSeasonEligible</code>, that defines a <code class="calibre9">minimumWinsForPlayoffs</code> property. The magic happens in the extension of <code class="calibre9">TeamRecord</code>, which has a type constraint on <code class="calibre9">Self: PostSeasonEligible</code> that will apply the extension to all adopters of <code class="calibre9">TeamRecord</code> that <i class="calibre2">also</i> adopt <code class="calibre9">PostSeasonEligible</code>.
</p>
<p class="calibre1">Applying the type constraint to the <code class="calibre9">TeamRecord</code> extension means that within the extension, <code class="calibre9">self</code> is known to be both a <code class="calibre9">TeamRecord</code> and <code class="calibre9">PostSeasonEligible</code>. That means you can use properties and methods defined on both of those types. You can also use type constraints to create default implementations on specific type combinations.
</p>
<p class="calibre1">Consider the case of <code class="calibre9">HockeyRecord</code>, which introduced <code class="calibre9">ties</code> in its record along with another implementation of <code class="calibre9">winningPercentage</code>:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">HockeyRecord</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> ties)
  }
}</pre>
<p class="calibre1">Ties are allowed in more games than hockey, so you could make that a protocol instead of coupling it to one specific sport:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Tieable</span> {
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">With type constraints, you can also make a default implementation for <code class="calibre9">winningPercentage</code>, specifically for types that are both a <code class="calibre9">TeamRecord</code> and <code class="calibre9">Tieable</code>:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">TeamRecord</span> <span class="hljs-number">where</span> <span class="hljs-number">Self</span>: <span class="hljs-number">Tieable</span> {
  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> ties)
  }
}</pre>
<p class="calibre1">Now, any type that is both a <code class="calibre9">TeamRecord</code> and <code class="calibre9">Tieable</code> won’t need to  implement a <code class="calibre9">winningPercentage</code> that factors in ties:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">RugbyRecord</span>: <span class="hljs-number">TeamRecord</span>, <span class="hljs-number">Tieable</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span>
}

<span class="hljs-keyword">let</span> rugbyRecord <span class="hljs-operator">=</span> <span class="hljs-built_in">RugbyRecord</span>(wins: <span class="hljs-number">8</span>, losses: <span class="hljs-number">7</span>, ties: <span class="hljs-number">1</span>)
rugbyRecord.winningPercentage <span class="hljs-comment">// 0.5</span></pre>
<p class="calibre1">Using a combination of protocol extensions and <i class="calibre2">constrained</i> protocol extensions, you can provide default implementations that make sense for particular cases.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Write a default implementation on <code class="calibre9">CustomStringConvertible</code> that will print the win/loss record in <code class="calibre9">Wins - Losses</code> format for any <code class="calibre9">TeamRecord</code> type. For instance, if a team is 10 and 5, it should return <code class="calibre9">10 - 5</code>.
</p>
<h2 class="segment-chapter1">Protocol-oriented benefits</h2>

<p class="calibre1">What exactly are the benefits of protocol-oriented programming?
</p>
<h3 class="segment-title2">Programming to Interfaces, not Implementations</h3>

<p class="calibre1">By focusing on protocols instead of implementations, you can apply code contracts to any type &mdash; even those that don’t support inheritance. Suppose you were to implement <code class="calibre9">TeamRecord</code> as a base class.
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">TeamRecordBase</span> {
  <span class="hljs-keyword">var</span> wins <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">var</span> losses <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

  <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)
  }
}

<span class="hljs-comment">// Does not compile: inheritance is only possible with classes.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-number">BaseballRecord</span>: <span class="hljs-number">TeamRecordBase</span> {

}</pre>
<p class="calibre1">At this point, you’d be stuck working with classes as long as you were working with team records. If you wanted to add ties to the mix, you’d either have to add ties to your subclass:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">HockeyRecord</span>: <span class="hljs-number">TeamRecordBase</span> {
  <span class="hljs-keyword">var</span> ties <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> ties)
  }
}</pre>
<p class="calibre1">Or you’d have to create yet <i class="calibre2">another</i> base class and thus deepen your class hierarchy:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">TieableRecordBase</span>: <span class="hljs-number">TeamRecordBase</span> {
  <span class="hljs-keyword">var</span> ties <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
    <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses <span class="hljs-operator">+</span> ties)
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">HockeyRecord</span>: <span class="hljs-number">TieableRecordBase</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-number">CricketRecord</span>: <span class="hljs-number">TieableRecordBase</span> {
}</pre>
<p class="calibre1">Likewise, if you wanted to work with any records that have wins, losses and ties, then you’d generally code against the lowest-common-denominator base class:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">TieableRecordBase</span> {
  <span class="hljs-keyword">var</span> totalPoints: <span class="hljs-built_in">Int</span> {
    (<span class="hljs-number">2</span> <span class="hljs-operator">*</span> wins) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> ties)
  }
}</pre>
<p class="calibre1">This practice forces you to “code to implementation, not interface.” If you wanted to compare two teams’ records, all you care about is wins and losses. With classes, though, you’d need to operate on the specific base class that happens to define <code class="calibre9">wins</code> and <code class="calibre9">losses</code>.
</p>
<p class="calibre1">I’m sure you don’t want to hear what would happen if you suddenly needed to support divisional wins and losses on some sports! :] With protocols, you don’t need to worry about the specific type or even whether it is a class or a struct; all you care about is the existence of specific common properties and methods.
</p>
<h3 class="segment-title2">Traits, mixins and multiple inheritance</h3>

<p class="calibre1">Speaking of supporting one-off features such as a divisional win or loss, one of the real benefits of protocols is that they allow a form of multiple inheritance.
</p>
<p class="calibre1">When creating a type, you can use protocols to decorate it with all the unique characteristics you want:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">TieableRecord</span> {
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">DivisionalRecord</span> {
  <span class="hljs-keyword">var</span> divisionalWins: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> divisionalLosses: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">ScoreableRecord</span> {
  <span class="hljs-keyword">var</span> totalPoints: <span class="hljs-built_in">Int</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">ScoreableRecord</span> <span class="hljs-number">where</span> <span class="hljs-number">Self</span>: <span class="hljs-number">TieableRecord</span>, <span class="hljs-number">Self</span>: <span class="hljs-number">TeamRecord</span> {
  <span class="hljs-keyword">var</span> totalPoints: <span class="hljs-built_in">Int</span> {
    (<span class="hljs-number">2</span> <span class="hljs-operator">*</span> wins) <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">*</span> ties)
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">NewHockeyRecord</span>: <span class="hljs-number">TeamRecord</span>, <span class="hljs-number">TieableRecord</span>,
       <span class="hljs-number">DivisionalRecord</span>, <span class="hljs-number">CustomStringConvertible</span>, <span class="hljs-number">Equatable</span> {
  <span class="hljs-keyword">var</span> wins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> losses: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> ties: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> divisionalWins: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">var</span> divisionalLosses: <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"<span class="hljs-subst">\(wins)</span> - <span class="hljs-subst">\(losses)</span> - <span class="hljs-subst">\(ties)</span>"</span>
  }
}</pre>
<p class="calibre1"><code class="calibre9">NewHockeyRecord</code> is a <code class="calibre9">TeamRecord</code> and a <code class="calibre9">TieableRecord</code>, tracks divisional wins and losses, works with <code class="calibre9">==</code>, and defines its own <code class="calibre9">CustomStringConvertible</code> description!
</p>
<p class="calibre1">Using protocols in this way is described as using <em class="calibre5">traits</em> or <em class="calibre5">mixins</em>. These terms reflect that you can use protocols and protocol extensions to add or mix different behaviors or traits to a type.
</p>
<h3 class="segment-title2">Simplicity</h3>

<p class="calibre1">When you write a computed property to calculate the winning percentage, you only need wins, losses and ties. When you write code to print a person’s full name, you only need a first and last name.
</p>
<p class="calibre1">If you were to write code to do these tasks inside of a more complex object, it could be easy to make the mistake of coupling it with unrelated code:
</p><pre class="code-block"><span class="hljs-keyword">var</span> winningPercentage: <span class="hljs-built_in">Double</span> {
  <span class="hljs-keyword">var</span> percent <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>(wins) <span class="hljs-operator">/</span> <span class="hljs-built_in">Double</span>(wins <span class="hljs-operator">+</span> losses)

  <span class="hljs-comment">// Oh no! Not relevant!</span>
  above500 <span class="hljs-operator">=</span> percent <span class="hljs-operator">&gt;</span> <span class="hljs-number">0.5</span>

  <span class="hljs-keyword">return</span> percent
}</pre>
<p class="calibre1">That <code class="calibre9">above500</code> property might be needed for some reason in cricket, but not in hockey. However, that makes the function very specific to a particular sport.
</p>
<p class="calibre1">You saw how simple the protocol extension version of this function was: It handled one calculation, and that was it. It let you leverage a default implementation kept in one place.
</p>
<p class="calibre1">You don’t need to know that the type adopting a protocol is a <code class="calibre9">HockeyRecord</code>, or a <code class="calibre9">StudentAthlete</code>, or a class, struct or enum. Because the code inside your protocol extension operates only on the protocol itself, <i class="calibre2">any</i> type that conforms to that protocol will be able to leverage this code.
</p>
<p class="calibre1">You’ll repeatedly discover in your coding life that simpler code is less buggy code.
</p>
<h2 class="segment-chapter1">Why Swift is a protocol-oriented language</h2>

<p class="calibre1">You’ve learned about the capabilities of protocols and protocol extensions, but you may be wondering: What exactly does it mean that Swift is a <i class="calibre2">protocol</i><i class="calibre2">-</i><i class="calibre2">oriented</i> language?
</p>
<p class="calibre1">Protocol extensions significantly affect your ability to write expressive and decoupled code &mdash; and the Swift language itself uses protocol extensions extensively.
</p>
<p class="calibre1">To begin with, you can contrast protocol-oriented programming with object-oriented programming. The latter focuses on the idea of <i class="calibre2">mutable objects</i> and how objects interact. Because of this, the class is at the center of any object-oriented language.
</p>
<p class="calibre1">Though classes are a part of Swift, you’ll find they are an <i class="calibre2">extremely</i> small part of the standard library. Instead, the Swift standard library is value types (or types with value semantics) that conform to protocols. You can see the significance in many of Swift’s core types, such as <code class="calibre9">Int</code> and <code class="calibre9">Array</code>. Consider the definition of <code class="calibre9">Array</code>:
</p><pre class="code-block"><span class="hljs-comment">// From the Swift standard library</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-number">Array</span>&lt;<span class="hljs-number">Element</span>&gt; : <span class="hljs-number">RandomAccessCollection</span>, <span class="hljs-number">MutableCollection</span> {
  <span class="hljs-comment">// ...</span>
}</pre>
<p class="calibre1">The fact that <code class="calibre9">Array</code> is a struct means it’s a value type, of course, but it also means that it can’t be subclassed, nor can it be a superclass. Instead of inheriting behaviors from common base classes, <code class="calibre9">Array</code> adopts protocols to define many of its more common capabilities.
</p>
<p class="calibre1"><code class="calibre9">Array</code> is a <code class="calibre9">MutableCollection</code>, which is also a <code class="calibre9">Collection</code>. Thanks to protocol extensions, <code class="calibre9">Array</code> will get numerous properties and methods common to every <code class="calibre9">Collection</code>, such as <code class="calibre9">first</code>, <code class="calibre9">count</code> or <code class="calibre9">isEmpty</code> &mdash; only by being a <code class="calibre9">Collection</code>.
</p>
<p class="calibre1">Thanks to many protocol extensions with generic constraints, you can <code class="calibre9">split()</code> an <code class="calibre9">Array</code> or find the <code class="calibre9">index(of:)</code> an element, assuming the type of that element conforms to <code class="calibre9">Equatable</code>.
</p>
<p class="calibre1">These implementations are all defined within protocol extensions in the Swift standard library. By implementing them in protocol extensions, these behaviors can be treated as mixins and do not need to be explicitly reimplemented on each adopting type.
</p>
<p class="calibre1">This decoration of defined behaviors lets <code class="calibre9">Array</code> and <code class="calibre9">Dictionary</code> &mdash; yet another <code class="calibre9">Collection</code> &mdash; be similar in some respects and different in others. Had Swift used subclassing, <code class="calibre9">Dictionary</code> and <code class="calibre9">Array</code> would either share one common base class or none at all. With protocols and protocol-oriented programming, you can treat them both as a <code class="calibre9">Collection</code>.
</p>
<p class="calibre1">With a design centered around protocols rather than specific classes, structs or enums, your code is instantly more portable and decoupled &mdash; methods now apply to a range of types instead of a particular type. Your code is also more cohesive because it operates only on the properties and methods within the protocol you’re extending and its type constraints. And it ignores the internal details of any type that conforms to it.
</p>
<p class="calibre1">Understanding protocol-oriented programming is a powerful skill that will help you become a better Swift developer and give you new ways to think about how to design your code.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: More neutral-minded Swift developers will call Swift a “multi-paradigm” language. You’ve already seen inheritance and object-oriented techniques and now protocol-oriented programming; Swift easily handles both!
</p></div>

<p class="calibre1">Protocols and protocol-oriented programming are at the foundation of the Swift language. The generics system, for example, uses protocols to specify with precision the type requirements of a generic type in use. If you have <i class="calibre2">m</i> data structures and <i class="calibre2">n</i> algorithms that operate on those data structures, in some languages, you need <i class="calibre2">m</i> * <i class="calibre2">n</i> blocks of code to implement them. With Swift, using protocols, you only need to write <i class="calibre2">m</i> + <i class="calibre2">n</i> blocks with no repetition. Protocol-oriented programming gives you all of the advantages of typical object-oriented programming while dodging most of the pitfalls.
</p>
<p class="calibre1">Next time you face a programming task, start with value types. See if you can figure out common elements across types. These become candidates for protocols and are often deeply connected with the problem domain of concern. Thinking in this way may lead you to a more flexible and extensible solution. Just as Neo can see the red dress in “The Matrix”, the more you get into this habit, the easier it will be to see protocol abstractions.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Before moving on, here are some challenges to test your knowledge of protocol-oriented programming. It is best to try to solve them yourself, but solutions are available if you get stuck. These came with the download or are available at the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Protocol extension practice</h3>

<p class="calibre1">Suppose you own a retail store. You have food items, clothes and electronics. Begin with an <code class="calibre9">Item</code> protocol:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Item</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> clearance: <span class="hljs-built_in">Bool</span> { <span class="hljs-keyword">get</span> }
  <span class="hljs-keyword">var</span> msrp: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> } <span class="hljs-comment">// Manufacturer’s Suggested Retail Price</span>
  <span class="hljs-keyword">var</span> totalPrice: <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">Fulfill the following requirements using what you’ve learned about protocol-oriented programming. In other words, minimize the code in your classes, structs or enums.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Clothes do not have a sales tax, but all other items have 7.5% sales tax.
</p></li>

<li class="calibre4">
<p class="calibre1">When food items are discounted 50% on clearance, clothes are discounted 25%, and electronics are discounted 5%.
</p></li>

<li class="calibre4">
<p class="calibre1">Items should implement <code class="calibre9">CustomStringConvertible</code> and return <code class="calibre9">name</code>. Food items should also print their expiration dates.
</p></li>
</ul>

<h3 class="segment-title2">Challenge 2: Doubling values</h3>

<p class="calibre1">Write a protocol extension on <code class="calibre9">Sequence</code> named <code class="calibre9">double()</code> that only applies to sequences of numeric elements. Make it return an array where each element is twice the element in the sequence. Test your implementation on an array of <code class="calibre9">Int</code> and an array of <code class="calibre9">Double</code>, then see if you can try it on an array of <code class="calibre9">String</code>.
</p>
<p class="calibre1">Hints:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Numeric values implement the protocol <code class="calibre9">Numeric</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Your method signature should be <code class="calibre9">double() -&gt; [Element]</code>. The type <code class="calibre9">[Element]</code> is an array of whatever type the <code class="calibre9">Sequence</code> holds, such as <code class="calibre9">String</code> or <code class="calibre9">Int</code>.
</p></li>
</ul>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1"><em class="calibre5">Protocol extensions</em> let you write implementation code for protocols and even write default implementations on methods required by a protocol.
</p></li>

<li class="calibre4">
<p class="calibre1">Protocol extensions are the primary driver for <em class="calibre5">protocol</em><em class="calibre5">-</em><em class="calibre5">oriented programming</em> and let you write code that will work on any type that conforms to a protocol.
</p></li>

<li class="calibre4">
<p class="calibre1">Interfaces part of the formal protocol declaration are <em class="calibre5">customization points</em> that adopting types can override.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Type constraints</em> on protocol extensions provide additional context and let you write more specialized implementations.
</p></li>

<li class="calibre4">
<p class="calibre1">You can decorate a type with <em class="calibre5">traits</em> and <em class="calibre5">mixins</em> to extend behavior without requiring inheritance.
</p></li>

<li class="calibre4">
<p class="calibre1">Protocols, when used well, promote code reuse and encapsulation.
</p></li>

<li class="calibre4">
<p class="calibre1">Start with value types and find the fundamental protocols.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-25">


<h1 class="segment-chapter">Chapter 28: Advanced Protocols &amp; Generics</h1>

<p class="calibre1">This chapter covers more advanced uses of protocols and generics. Expanding on what you’ve learned in previous chapters, you’ll make protocols with constraints to <code class="calibre9">Self</code>, other associated types.
</p>
<p class="calibre1">Later in the chapter, you’ll discover some issues with protocols, and you’ll address them using <em class="calibre5">type erasure</em> and <em class="calibre5">opaque return types</em>.
</p>
<h2 class="segment-chapter1">Existential protocols</h2>

<p class="calibre1">In this chapter, you’ll see some fancy words that may sound unrelated to Swift, yet type system experts use these terms. It’ll be best for you to know this terminology and realize it isn’t a big deal.
</p>
<p class="calibre1"><em class="calibre5">Existential type</em> is one such term. Fortunately, it’s a name for something you already know and have used; it’s merely a concrete type accessed through a protocol.
</p>
<p class="calibre1">Example time. Put this into a playground:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
}
<span class="hljs-keyword">struct</span> <span class="hljs-number">Cat</span>: <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">In this code, the <code class="calibre9">Pet</code> protocol says that pets must have a name. Then you created a concrete type <code class="calibre9">Cat</code> which conforms to <code class="calibre9">Pet</code>. Now create a <code class="calibre9">Cat</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">var</span> somePet: <span class="hljs-built_in">Pet</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Cat</span>(name: <span class="hljs-string">"Whiskers"</span>)</pre>
<p class="calibre1">Here, you defined the variable <code class="calibre9">somePet</code> with a type of <code class="calibre9">Pet</code> instead of the concrete type <code class="calibre9">Cat</code>. Here <code class="calibre9">Pet</code> is an <em class="calibre5">existential type</em> &mdash; it’s an abstract concept, a protocol, that refers to a concrete type, such as a struct, that <i class="calibre2">exists</i>.
</p>
<p class="calibre1">To keep things simple, we’ll call it a <em class="calibre5">protocol type</em> from now on. These protocol types look a lot like abstract base classes in object-oriented programming, but you can apply them to enums and structs as well.
</p>
<h2 class="segment-chapter1">Non-existential protocols</h2>

<p class="calibre1">If a protocol has associated types, you cannot use it as an existential type. For example, if you change <code class="calibre9">Pet</code> like so:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">Food</span>
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">Suddenly, you can no longer instantiate Whiskers.
</p><div class="image2"><img src="images/000091.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Despite this shortcoming, associated types are super useful. Consider this example from Chapter 16, “Protocols”:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">WeightType</span>
  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">WeightType</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">This protocol defines having a weight without fixing <code class="calibre9">weight</code> to one specific type. You can create a class (or a struct) that sets the <code class="calibre9">WeightType</code> as an <code class="calibre9">Int</code> or a <code class="calibre9">Double</code> or <i class="calibre2">anything you want</i>. For example:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Truck</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-comment">// This heavy thing only needs integer accuracy</span>
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Int</span> {
    <span class="hljs-number">100</span>
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">Flower</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-comment">// This light thing needs decimal places</span>
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Double</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Double</span> {
    <span class="hljs-number">0.0025</span>
  }
}</pre>
<p class="calibre1">The emphasis here is on the <i class="calibre2">anything you want</i> part. Nothing is stopping you from defining <code class="calibre9">WeightType</code> as a string or even something else entirely. :]
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">StringWeightThing</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"That doesn't make sense"</span>
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-number">CatWeightThing</span>: <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">typealias</span> <span class="hljs-built_in">WeightType</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Cat</span>

  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">Cat</span> {
    <span class="hljs-built_in">Cat</span>(name: <span class="hljs-string">"What is this cat doing here?"</span>)
  }
}</pre>
<h3 class="segment-title2">Constraining the protocol to a specific type</h3>

<p class="calibre1">When you first thought about creating this protocol, you wanted it to define a weight through a number, and it worked perfectly when used that way. It simply made sense!
</p>
<p class="calibre1">But that’s when you were using your own protocol. If you wanted to write generic code around it, and the generic system knows nothing about <code class="calibre9">WeightType</code> capabilities, you can’t do any computation with it.
</p>
<p class="calibre1">In this case, you want to add a constraint that requires <code class="calibre9">WeightCalculatable</code> to be <code class="calibre9">Numeric</code>:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">WeightType</span>: <span class="hljs-built_in">Numeric</span>
  <span class="hljs-keyword">var</span> weight: <span class="hljs-built_in">WeightType</span> { <span class="hljs-keyword">get</span> }
}</pre>
<p class="calibre1">This change will make strings and cats invalid weight types:
</p><div class="image3"><img src="images/000103.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">You can now write generic short-hand functions that use <code class="calibre9">WeightCalculatable</code> in computations instead of accessing its underlying <code class="calibre9">weight</code> property. Why not start making good use of that? Write this:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">WeightCalculatable</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-number">+</span> (<span class="hljs-built_in">left</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-built_in">right</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">WeightType</span> {
    left.weight <span class="hljs-operator">+</span> right.weight
  }
}

<span class="hljs-keyword">var</span> heavyTruck1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Truck</span>()
<span class="hljs-keyword">var</span> heavyTruck1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Truck</span>()
heavy1 <span class="hljs-operator">+</span> heavy2 <span class="hljs-comment">// 200</span>

<span class="hljs-keyword">var</span> lightFlower1 <span class="hljs-operator">=</span> <span class="hljs-built_in">Flower</span>()
heavyTruck1 <span class="hljs-operator">+</span> lightFlower1 <span class="hljs-comment">// the compiler detects your coding error</span></pre>
<p class="calibre1">Anything that conforms to <code class="calibre9">WeightCalculatable</code> must have a <code class="calibre9">WeightType</code> that represents a number. You can add the numeric capabilities directly into the protocol.
</p>
<p class="calibre1">Also, notice that when you tried to add two different weight types, it didn’t work. That’s because the <em class="calibre5">+</em> operator has two parameters of the same type: <code class="calibre9">Self</code>. The protocol ensures that only the same conforming types add to produce a <code class="calibre9">WeightType</code> result.
</p>
<h3 class="segment-title2">Expressing relationships between types</h3>

<p class="calibre1">Next, look at how you can use type constraints to express relationships between types.
</p>
<p class="calibre1">Suppose you want to model a production factory. Enter this code to get started:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Product</span> {}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">ProductionLine</span>  {
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; <span class="hljs-built_in">Product</span>
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">Factory</span> {
  <span class="hljs-keyword">var</span> productionLines: [<span class="hljs-built_in">ProductionLine</span>] {<span class="hljs-keyword">get</span>}
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">Factory</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; [<span class="hljs-built_in">Product</span>] {
    <span class="hljs-keyword">var</span> items: [<span class="hljs-built_in">Product</span>] <span class="hljs-operator">=</span> []
    productionLines.forEach { items.append(<span class="hljs-variable">$0</span>.produce()) }
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Finished Production"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-------------------"</span>)
    <span class="hljs-keyword">return</span> items
  }
}</pre>
<p class="calibre1">Here, you define protocols for <code class="calibre9">Product</code>, the <code class="calibre9">ProductionLine</code> that produces products, and <code class="calibre9">Factory</code>, which has production lines. You also extend <code class="calibre9">Factory</code> with <code class="calibre9">produce()</code>, which makes one product for every factory production line.
</p>
<p class="calibre1">Next, define some concrete types:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Car</span>: <span class="hljs-number">Product</span> {
  <span class="hljs-keyword">init</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Producing one awesome Car 🚔"</span>)
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">CarProductionLine</span>: <span class="hljs-number">ProductionLine</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; <span class="hljs-built_in">Product</span> {
    <span class="hljs-built_in">Car</span>()
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">CarFactory</span>: <span class="hljs-number">Factory</span> {
  <span class="hljs-keyword">var</span> productionLines: [<span class="hljs-built_in">ProductionLine</span>] <span class="hljs-operator">=</span> []
}</pre>
<p class="calibre1">You now have concrete types for the <code class="calibre9">Product</code>, <code class="calibre9">ProductionLine</code>, and <code class="calibre9">Factory</code>. You can now start the manufacturing process:
</p><pre class="code-block"><span class="hljs-keyword">var</span> carFactory <span class="hljs-operator">=</span> <span class="hljs-built_in">CarFactory</span>()
carFactory.productionLines <span class="hljs-operator">=</span> [<span class="hljs-built_in">CarProductionLine</span>(), <span class="hljs-built_in">CarProductionLine</span>()]
carFactory.produce()</pre>
<p class="calibre1">With this code, you created a factory, gave it two production lines and told it to start production one time. So far, so good! Now try this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Chocolate</span>: <span class="hljs-number">Product</span> {
  <span class="hljs-keyword">init</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Producing one chocolate bar 🍫"</span>)
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">ChocolateProductionLine</span>: <span class="hljs-number">ProductionLine</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; <span class="hljs-built_in">Product</span> {
    <span class="hljs-built_in">Chocolate</span>()
  }
}

<span class="hljs-keyword">var</span> oddCarFactory <span class="hljs-operator">=</span> <span class="hljs-built_in">CarFactory</span>()
oddCarFactory.productionLines <span class="hljs-operator">=</span> [<span class="hljs-built_in">CarProductionLine</span>(), <span class="hljs-built_in">ChocolateProductionLine</span>()]
oddCarFactory.produce()</pre>
<p class="calibre1">What’s chocolate doing in the car factory? How does this make sense?
</p>
<p class="calibre1">The car factory has no problem with a mix of car and chocolate production lines since they all conform to <code class="calibre9">ProductionLine</code>.
</p>
<p class="calibre1">But the FDA would never approve of chocolate produced in the same factory that makes cars. How can you specify that each factory should only produce one type of product?
</p>
<p class="calibre1">First, start fresh with a new set of protocols, this time using associated types:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Product</span> {
  <span class="hljs-keyword">init</span>()
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">ProductionLine</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">ProductType</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; <span class="hljs-built_in">ProductType</span>
}

<span class="hljs-keyword">protocol</span> <span class="hljs-number">Factory</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">ProductType</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; [<span class="hljs-built_in">ProductType</span>]
}</pre>
<p class="calibre1"><code class="calibre9">Product</code> now includes <code class="calibre9">init()</code>, so the production line can create new products without having to know the concrete type of that product.
</p>
<p class="calibre1">Your <code class="calibre9">Car</code> and <code class="calibre9">Chocolate</code> types remain the same:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Car</span>: <span class="hljs-number">Product</span> {
  <span class="hljs-keyword">init</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Producing one awesome Car 🚔"</span>)
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">Chocolate</span>: <span class="hljs-number">Product</span>{
  <span class="hljs-keyword">init</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Producing one Chocolate bar 🍫"</span>)
  }
}</pre>
<p class="calibre1">Instead of creating specific production lines and factories for cars and chocolates, you can create a single, generic production line and factory:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">GenericProductionLine</span>&lt;<span class="hljs-number">P</span>: <span class="hljs-number">Product</span>&gt;: <span class="hljs-number">ProductionLine</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; <span class="hljs-built_in">P</span> {
    <span class="hljs-built_in">P</span>()
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">GenericFactory</span>&lt;<span class="hljs-number">P</span>: <span class="hljs-number">Product</span>&gt;: <span class="hljs-number">Factory</span> {
  <span class="hljs-keyword">var</span> productionLines: [<span class="hljs-built_in">GenericProductionLine</span>&lt;<span class="hljs-built_in">P</span>&gt;] <span class="hljs-operator">=</span> []

  <span class="hljs-keyword">func</span> <span class="hljs-number">produce</span>() -&gt; [<span class="hljs-built_in">P</span>] {
    <span class="hljs-keyword">var</span> newItems: [<span class="hljs-built_in">P</span>] <span class="hljs-operator">=</span> []
    productionLines.forEach { newItems.append(<span class="hljs-variable">$0</span>.produce()) }
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Finished Production"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-------------------"</span>)
    <span class="hljs-keyword">return</span> newItems
  }
}</pre>
<p class="calibre1">Note how you use the generic type <code class="calibre9">P</code> to ensure the production line produces the same <code class="calibre9">ProductType</code> as the factory. You also constrain <code class="calibre9">P</code> to <code class="calibre9">Product</code> so that it must have a default initializer.
</p>
<p class="calibre1">You can now create a car factory as follows:
</p><pre class="code-block"><span class="hljs-keyword">var</span> carFactory <span class="hljs-operator">=</span> <span class="hljs-built_in">GenericFactory</span>&lt;<span class="hljs-built_in">Car</span>&gt;()
carFactory.productionLines <span class="hljs-operator">=</span> [<span class="hljs-built_in">GenericProductionLine</span>&lt;<span class="hljs-built_in">Car</span>&gt;(), <span class="hljs-built_in">GenericProductionLine</span>&lt;<span class="hljs-built_in">Car</span>&gt;()]
carFactory.produce()</pre>
<p class="calibre1">To create a chocolate factory, simply change <code class="calibre9">&lt;Car&gt;</code> to <code class="calibre9">&lt;Chocolate&gt;</code>.
</p>
<h3 class="segment-title2">Mini-exercise</h3>

<p class="calibre1">Here’s a little challenge for you. Try to see if you can do the following two things:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Instead of supplying the factory with production lines through the property <code class="calibre9">productionLines</code>, the factory can increase its production lines.
</p></li>

<li class="calibre4">
<p class="calibre1">Instead of the factory creating the products and doing nothing with them, the factory should store the items in a warehouse instead.
</p></li>
</ol>

<h2 class="segment-chapter1">Type erasure</h2>

<p class="calibre1">Type erasure is a technique for erasing type information that is not important. The type <code class="calibre9">Any</code> is the ultimate type erasure. It expunges all type information. As a consequence, it is lengthy and error-prone to use. As an example, consider the following collection types:
</p><pre class="code-block"><span class="hljs-keyword">let</span> array <span class="hljs-operator">=</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span>)
<span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Set</span>(<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span>)
<span class="hljs-keyword">let</span> reversedArray <span class="hljs-operator">=</span> array.reversed()</pre>
<p class="calibre1">Each of these has a particular type. For example, <code class="calibre9">reversedArray</code> is of type <code class="calibre9">ReversedArray&lt;Array&lt;Int&gt;&gt;</code>.  You can loop over it as you would normally because it conforms to the <code class="calibre9">Sequence</code> protocol.  It is this <code class="calibre9">Sequence</code> protocol that matters. You can write:
</p><pre class="code-block"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> reversedArray {
 <span class="hljs-built_in">print</span>(e)
}</pre>
<p class="calibre1">But what happens if you need to spell out the types explicitly? For example, you usually specify the exact type when you return a type or pass it as a parameter.  Suppose you wanted to make a collection like this:
</p><div class="image3"><img src="images/000113.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">These three variables are collections of different types, and you can’t group them up together in a homogeneous element array.
</p>
<p class="calibre1">You could get around this like so:
</p><pre class="code-block"><span class="hljs-keyword">let</span> arrayCollections <span class="hljs-operator">=</span> [array, <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">set</span>), <span class="hljs-built_in">Array</span>(reversedArray)]</pre>
<p class="calibre1">Here <code class="calibre9">arrayCollections</code> is of type <code class="calibre9">[[Int]]</code>.  This approach is often a good solution thanks to the ability of <code class="calibre9">Array</code> to initialize from a sequence of elements and infer the element type automatically.  However, it is <em class="calibre5">O(N)</em> in time and space because it makes a copy of all the elements.
</p>
<p class="calibre1">This easy solution might not be tenable if the collections are gigantic. Fortunately, Swift provides a type-erased type for collections called <code class="calibre9">AnyCollection</code>, and it throws away type-specific information while keeping all the collection goodness.  Create it with this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> collections <span class="hljs-operator">=</span> [<span class="hljs-built_in">AnyCollection</span>(array),
                   <span class="hljs-built_in">AnyCollection</span>(<span class="hljs-keyword">set</span>),
                   <span class="hljs-built_in">AnyCollection</span>(array.reversed())]</pre>
<p class="calibre1">Creating this collection is <em class="calibre5">O(1)</em> because it wraps the original type instead of copying it.
</p>
<p class="calibre1">Now you can do computations like sum up all of the elements:
</p><pre class="code-block"><span class="hljs-keyword">let</span> total <span class="hljs-operator">=</span> collections.flatMap { <span class="hljs-variable">$0</span> }.reduce(<span class="hljs-number">0</span>, <span class="hljs-operator">+</span>) <span class="hljs-comment">// 165</span></pre>
<p class="calibre1">There are several type-erased types in not only the Swift standard libraries but other libraries as well.  For example, <code class="calibre9">AnyIterator</code>, <code class="calibre9">AnySequence</code>,  <code class="calibre9">AnyCollection</code>, <code class="calibre9">AnyHashable</code> are part of the Swift standard library.  <code class="calibre9">AnyPublisher</code> is part of the Combine framework, and <code class="calibre9">AnyView</code> is part of SwiftUI.
</p>
<p class="calibre1">The downside with these <code class="calibre9">Any</code> types is that it requires creating a whole new type that wraps the original. The process is straightforward but requires a lot of boilerplate code to achieve.
</p>
<h2 class="segment-chapter1">Making a type erasure</h2>

<p class="calibre1">Suppose you have the following <code class="calibre9">Pet</code> protocol:
</p><pre class="code-block"><span class="hljs-keyword">protocol</span> <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">associatedtype</span> <span class="hljs-built_in">Food</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">eat</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">food</span>: <span class="hljs-built_in">Food</span>)
}</pre>
<p class="calibre1">And you have these conforming types:
</p><pre class="code-block"><span class="hljs-keyword">enum</span> <span class="hljs-number">PetFood</span> { <span class="hljs-keyword">case</span> dry, wet }

<span class="hljs-keyword">struct</span> <span class="hljs-number">Cat</span>: <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">eat</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">food</span>: <span class="hljs-built_in">PetFood</span>) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Eating cat food."</span>)
  }
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">Dog</span>: <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">eat</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">food</span>: <span class="hljs-built_in">PetFood</span>) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Eating dog food."</span>)
  }
}</pre>
<p class="calibre1">If you try to create a list of pets using an existential protocol, the compiler won’t let you:
</p><pre class="code-block"><span class="hljs-keyword">let</span> pets: [<span class="hljs-built_in">Pet</span>] <span class="hljs-operator">=</span> [<span class="hljs-built_in">Dog</span>(), <span class="hljs-built_in">Cat</span>()] <span class="hljs-comment">// ERROR: Pet can only be used as a generic constraint </span></pre>
<p class="calibre1">Your goal is to construct a list of <code class="calibre9">AnyPet</code> so that you can list dogs and cats together. For that, you need to make an <code class="calibre9">AnyPet</code> type erasure:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">AnyPet</span>&lt;<span class="hljs-number">Food</span>&gt;: <span class="hljs-number">Pet</span> {                  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _eat: (<span class="hljs-built_in">Food</span>) -&gt; <span class="hljs-built_in">Void</span>          <span class="hljs-comment">// 2</span>

  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">init</span>&lt;<span class="hljs-built_in">SomePet</span>: <span class="hljs-built_in">Pet</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-built_in">pet</span>: <span class="hljs-built_in">SomePet</span>) <span class="hljs-keyword">where</span> <span class="hljs-built_in">SomePet</span>.<span class="hljs-built_in">Food</span> <span class="hljs-operator">==</span> <span class="hljs-built_in">Food</span> {
    _eat <span class="hljs-operator">=</span> pet.eat(<span class="hljs-keyword">_</span>:)
  }

  <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">eat</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">food</span>: <span class="hljs-built_in">Food</span>) {
    _eat(food)
  }
}</pre>
<p class="calibre1">This code is the basic formula of a type erasure. Here is what is going on:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The type eraser is a generic concrete type abstracted by the associated type of the generic protocol, and it conforms to the generic protocol.
</p></li>

<li class="calibre4">
<p class="calibre1">For each protocol method, it stores a closure to the method of the type it wraps.
</p></li>

<li class="calibre4">
<p class="calibre1">A generic initializer takes as input the type it is wrapping.  It constrains its associated type to be the same as the type it is wrapping.
</p></li>

<li class="calibre4">
<p class="calibre1">To implement the protocol, it forwards calls to the type it is wrapping.
</p></li>
</ol>

<p class="calibre1">Now you can use the <code class="calibre9">AnyPet</code> type erasure to make an array of dogs and cats like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> pets <span class="hljs-operator">=</span> [<span class="hljs-built_in">AnyPet</span>(<span class="hljs-built_in">Dog</span>()), <span class="hljs-built_in">AnyPet</span>(<span class="hljs-built_in">Cat</span>())]</pre>
<p class="calibre1">The compiler infers the array type to be <code class="calibre9">AnyPet&lt;PetFood&gt;</code>.
</p>
<h3 class="segment-title2">Implement eraseToAnyPet</h3>

<p class="calibre1">A relatively new convention is to add an <code class="calibre9">eraseToAny***()</code> method to make type erasure more convenient. For example, in Apple’s Combine framework, there’s a type-erased type called <code class="calibre9">AnyPublisher</code> and you call the method <code class="calibre9">eraseToAnyPublisher()</code> to get one.
</p>
<p class="calibre1">In the <code class="calibre9">Pet</code> case, adding such an extension would look like this:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Pet</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-number">eraseToAnyPet</span>() -&gt; <span class="hljs-built_in">AnyPet</span>&lt;<span class="hljs-built_in">Food</span>&gt; {
    .<span class="hljs-keyword">init</span>(<span class="hljs-keyword">self</span>)
  }
}</pre>
<p class="calibre1">The compiler infers <code class="calibre9">.init</code> to be type <code class="calibre9">AnyPet&lt;Food&gt;</code>. Using it looks like this:
</p><pre class="code-block"><span class="hljs-keyword">let</span> morePets <span class="hljs-operator">=</span> [<span class="hljs-built_in">Dog</span>().eraseToAnyPet(),
                <span class="hljs-built_in">Cat</span>().eraseToAnyPet()]</pre>
<p class="calibre1">As before, the compiler infers <code class="calibre9">Food</code> in <code class="calibre9">AnyPet&lt;Food&gt;</code> as <code class="calibre9">PetFood</code> for you.
</p>
<h2 class="segment-chapter1">Opaque return types</h2>

<p class="calibre1">The goal of type erasure is to hide unimportant details about concrete types but still communicate the type’s functionality using a protocol. The <code class="calibre9">Any***</code> wrapper type that you create conforms to the protocol so that you can take advantage of it.
</p>
<p class="calibre1">Swift provides a related language feature called <em class="calibre5">opaque return types</em>.  It has the advantage that you don’t need to create an <code class="calibre9">Any***</code> wrapper type.  Opaque return types work by making the compiler keeping track of the concrete return type but only letting the function caller use a protocol interface that the supports. This bookkeeping on the compiler’s part enables you to use protocols with associated types that you could otherwise only use as generic constraints.
</p>
<p class="calibre1">Here is a trivial example:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">makeValue</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">FixedWidthInteger</span> {
  <span class="hljs-number">42</span>
}</pre>
<p class="calibre1">The magic here is <code class="calibre9">some FixedWidthInteger</code>.  (All of the different integer types in Swift adopt the <code class="calibre9">FixedWidthInteger</code> protocol.) With this return type, the only thing you know is that it’s a kind of integer.
</p>
<p class="calibre1">Using the protocol, though, you can do useful things such as addition:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Two makeValues summed"</span>, makeValue() <span class="hljs-operator">+</span> makeValue())</pre>
<p class="calibre1"><code class="calibre9">+</code> works because it is defined for <code class="calibre9">FixedWidthInteger</code> types.
</p>
<p class="calibre1">But importantly, the <code class="calibre9">makeValue</code> function returns a distinct, compiler-known type with a known size (in this case, an Int) that will not change from call to call.
</p>
<p class="calibre1">The compiler will enforce this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">makeValueRandomly</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">FixedWidthInteger</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">Bool</span>.random() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int</span>(<span class="hljs-number">42</span>)
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int8</span>(<span class="hljs-number">24</span>) <span class="hljs-comment">// Compiler error.  All paths must return same type.</span>
  }
}</pre>
<p class="calibre1">To fix the compile error change the type to be the same:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">makeValueRandomly</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">FixedWidthInteger</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">Bool</span>.random() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int</span>(<span class="hljs-number">42</span>)
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Int</span>(<span class="hljs-number">24</span>)
  }
}</pre>
<p class="calibre1">Incidentally,  <code class="calibre9">FixedWidthInteger</code> has associated types; you can’t use it as an existential type.  For example, this is not allowed:
</p><pre class="code-block"><span class="hljs-keyword">let</span> v: <span class="hljs-built_in">FixedWidthInteger</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span> <span class="hljs-comment">// compiler error</span>
<span class="hljs-keyword">let</span> v <span class="hljs-operator">=</span> makeValue() <span class="hljs-comment">// works</span></pre>
<p class="calibre1">You can also return a value as an object that implements a composition of protocols. Use a more primative numeric protocol <code class="calibre9">Numeric</code> that works for both integer and floating-point numbers:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">makeEquatableNumericInt</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">Numeric</span> &amp; <span class="hljs-built_in">Equatable</span> { <span class="hljs-number">1</span> }
<span class="hljs-keyword">func</span> <span class="hljs-number">makeEquatableNumericDouble</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-built_in">Numeric</span> &amp; <span class="hljs-built_in">Equatable</span> { <span class="hljs-number">1.0</span> }

<span class="hljs-keyword">let</span> value1 <span class="hljs-operator">=</span> makeEquatableNumericInt()
<span class="hljs-keyword">let</span> value2 <span class="hljs-operator">=</span> makeEquatableNumericInt()

<span class="hljs-built_in">print</span>(value1 <span class="hljs-operator">==</span> value2) <span class="hljs-comment">// prints true</span>
<span class="hljs-built_in">print</span>(value1 <span class="hljs-operator">+</span> value2) <span class="hljs-comment">// prints 2</span>
<span class="hljs-built_in">print</span>(value1 <span class="hljs-operator">&gt;</span> value2) <span class="hljs-comment">// error</span></pre>
<p class="calibre1">The first two print statements compile and run as expected, thanks to the protocol conformances. But the third print needs conformance to <code class="calibre9">Comparable</code>. Although the actual type is a <code class="calibre9">Comparable</code>  integer, this information is not exposed.
</p>
<p class="calibre1">Also, even though it would seem from the outside that the types are the same,  <code class="calibre9">some Numeric &amp; Equatable</code>, the compiler knows the concrete types <code class="calibre9">Int</code> and <code class="calibre9">Double</code> are not as in this example:
</p><pre class="code-block"><span class="hljs-comment">// Compiler error, types don't match up</span>
makeEquatableNumericInt() <span class="hljs-operator">==</span> makeEquatableNumericDouble()</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: Opaque return types constitute a major feature of <em class="calibre5">SwiftUI</em>, whose <code class="calibre9">View</code> protocol returns a <code class="calibre9">body</code> of <code class="calibre9">some View</code>.  It is not essential to know the exact type of the returned view and maintain that every time a button moves. This maintenance would be infeasibly error-prone. The concrete type under the hood means that SwiftUI can find differences between views lightning-fast, translating to excellent user experiences and a simple programming model.
</p></div>

<p class="calibre1">Why not use <code class="calibre9">some Collection</code> instead of <code class="calibre9">AnyCollection</code>? Currently, Swift opaque return types in Swift have a few limitations. First, as the name suggests, you can’t use them as function parameters, only return types. Second, you cannot constrain associated types. So, for example, it is currently impossible to specify, <code class="calibre9">some Collection&lt;Int&gt;</code>. These limitations are why you still need types like <code class="calibre9">AnyCollection</code>, which locks in the <code class="calibre9">Element</code> type.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Congratulations on making it this far! But before you come to the end of this chapter, here are some challenges to test your knowledge of advanced protocols and generics. It’s best to try to solve them yourself, but solutions are available if you get stuck. You can find the solutions with the download or the printed book’s source code link listed in the introduction.
</p>
<h3 class="segment-title2">Challenge 1: Robot vehicle builder</h3>

<p class="calibre1">Using protocols, define a robot that makes vehicle toys.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Each robot can assemble a different number of pieces per minute. For example, Robot-A can assemble ten pieces per minute, while Robot-B can assemble five.
</p></li>

<li class="calibre4">
<p class="calibre1">Each robot type is only able to build a single type of toy.
</p></li>

<li class="calibre4">
<p class="calibre1">Each toy type has a price value.
</p></li>
</ul>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Each toy type has a different number of pieces. You tell the robot how long it should operate, and it will provide the finished toys.
</p></li>

<li class="calibre4">
<p class="calibre1">Add a method to tell the robot how many toys to build. It will build them and say how much time it needed.
</p></li>
</ul>

<h3 class="segment-title2">Challenge 2: Toy train builder</h3>

<p class="calibre1">Declare a function that constructs robots that make toy trains.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">A train has 75 Pieces.
</p></li>

<li class="calibre4">
<p class="calibre1">A train robot can assemble 500 pieces per minute.
</p></li>

<li class="calibre4">
<p class="calibre1">Use an opaque return type to hide the type of robot you return.
</p></li>
</ul>

<h3 class="segment-title2">Challenge 3: Monster truck toy</h3>

<p class="calibre1">Create a monster truck toy that has 120 pieces and a robot to make this toy. The robot is less sophisticated and can only assemble 200 pieces per minute. Next, change the <code class="calibre9">makeToyBuilder()</code> function to return this new robot.
</p>
<h3 class="segment-title2">Challenge 4: Shop robot</h3>

<p class="calibre1">Define a shop that uses a robot to make the toy that this shop will sell.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">This shop should have two inventories: a display and a warehouse.
</p></li>

<li class="calibre4">
<p class="calibre1">There’s a limit to the number of items on display, but there’s no limit on the warehouse’s size.
</p></li>

<li class="calibre4">
<p class="calibre1">In the morning of every day, the warehouse fills its display.
</p></li>

<li class="calibre4">
<p class="calibre1">Each customer buys an average of 1.5 toys.
</p></li>

<li class="calibre4">
<p class="calibre1">If the shop needs the robot, rent the robot and operate it for the duration required.
</p></li>

<li class="calibre4">
<p class="calibre1">To reduce the operations’ running costs, the robot is set to only work when the warehouse contents are less than the display’s size. The robot should produce enough toys so that the inventory is twice the size of the display.
</p></li>

<li class="calibre4">
<p class="calibre1">The shop has a <code class="calibre9">startDay(numberOfVisitors: Int)</code> method. This method will first fill the display from the inventory, then sell items from the display based on the number of customers and finally produce new toys, if needed.
</p></li>
</ul>

<h2 class="segment-chapter1">Key points</h2>

<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">You can use protocols as existential and as generic constraints.
</p></li>

<li class="calibre4">
<p class="calibre1">Existentials let you use a type, like a base class, polymorphically.
</p></li>

<li class="calibre4">
<p class="calibre1">Generic constraints express the capabilities required by a type, but you can’t use them polymorphically.
</p></li>

<li class="calibre4">
<p class="calibre1">Associated types make protocols generic. They provide greater generality and can be type-checked.
</p></li>

<li class="calibre4">
<p class="calibre1">Type erasure is a way to hide concrete details while preserving important type information.
</p></li>

<li class="calibre4">
<p class="calibre1">Opaque return types let you return only protocol information from a concrete type.
</p></li>

<li class="calibre4">
<p class="calibre1">The more generic you write your code, the more places you can potentially reuse it.
</p></li>
</ul>

<p class="calibre1">And that’s a wrap! Generics will help you make your code less coupled and less dependent on specific types. Protocols, extensions, and associated types will allow you to write composable and reusable types that can be used together in various contexts to solve a broader range of problems.
</p></div>

<div class="segment-title" id="calibre_link-42">


<h1 class="segment-chapter">Chapter 29: Concurrency</h1>

<p class="calibre1">The code you’ve written in the previous chapters of this book is all <em class="calibre5">synchronous</em>, meaning that it executes statement-by-statement, one step at a time, on what’s known as the <em class="calibre5">main thread</em>. Synchronous code is the most straightforward code to write and reason about, but it comes with a cost. Operations that take time to complete, such as reading from a network or database, stop your program and wait for the operation to finish. For an interactive program such as a mobile app, this is a poor user experience because the app feels slow and unresponsive.
</p>
<p class="calibre1">By executing these operations <em class="calibre5">asynchronously</em>, your program is free to work on other tasks while it waits for the blocking operation to complete. Working asynchronously introduces <em class="calibre5">concurrency</em> into your code. Your program will work on multiple tasks simultaneously.
</p>
<p class="calibre1">Swift has always been capable of using concurrency libraries, such as Apple’s C-language-based Grand Central Dispatch. Still, more recently, the core team has introduced a suite of language-level features, making concurrency more efficient, safer and less error-prone than ever before.
</p>
<p class="calibre1">This chapter gets you started in this new world of concurrency. You’ll learn essential concepts, including:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">How to create unstructured and structured tasks.
</p></li>

<li class="calibre4">
<p class="calibre1">How to perform cooperative task cancellation.
</p></li>

<li class="calibre4">
<p class="calibre1">How to use the <code class="calibre9">async</code> / <code class="calibre9">await</code> pattern.
</p></li>

<li class="calibre4">
<p class="calibre1">How to create and use <code class="calibre9">actor</code> and <code class="calibre9">Sendable</code> types.
</p></li>
</ul>

<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You may have heard of multithreaded programming. Concurrency in Swift is built on top of threads, but you don’t need to manipulate them directly. In Swift-concurrency-speak, the term <em class="calibre5">main actor</em> is used in place of <em class="calibre5">main thread</em>. Actors are responsible for maintaining the consistency of objects you run concurrently in your program.
</p></div>

<h2 class="segment-chapter1">Basic tasks</h2>

<p class="calibre1">You’ll start with something super simple: creating an unstructured task, which is an object that encapsulates some concurrent work. You can do that in an iOS Playground like this:
</p><pre class="code-block"><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on a task"</span>)
}
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on the main actor"</span>)</pre>
<p class="calibre1">The <code class="calibre9">Task</code> type takes a trailing closure with some work &mdash; printing a message in this case &mdash; to do simultaneously with the main actor. Running this playground prints:
</p><pre class="code-block">Doing some work on a task
Doing some work on the main actor</pre>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: The import to SwiftUI pulls in the private _Concurrency framework that defines <code class="calibre9">Task</code>. Importing UIKit will also work. (The leading underbar on _Concurrency indicates the name may change in a future release, so importing SwiftUI or UIKit is more future-proof than importing _Concurrency directly.)
</p></div>

<h3 class="segment-title2">Changing the order</h3>

<p class="calibre1">In the example above, the code executed in the order the statements in the playground occurred. To see how that can change, replace the <code class="calibre9">Task</code> with some real work, like this:
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on a task"</span>)
  <span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">100</span>).reduce(<span class="hljs-number">0</span>, <span class="hljs-operator">+</span>)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"1 + 2 + 3 ... 100 = <span class="hljs-subst">\(sum)</span>"</span>)
}

<span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on the main actor"</span>)</pre>
<p class="calibre1">The details of the computation aren’t important; just know that it finds the sum of numbers from 1 to 100. When you print now, you can see that the order of the statements has changed:
</p><pre class="code-block">Doing some work on a task
Doing some work on the main actor
1 + 2 + 3 ... 100 = 5050</pre>
<p class="calibre1">And herein lies the fundamental challenge with concurrent programming: The order of events can change depending on the input size, processing power or how the operating system scheduler decides to schedule tasks to work on.
</p>
<p class="calibre1">The new features in the Swift language shine in addressing this challenge, adding compiler support and API support to make things as easy to reason about as possible.
</p>
<h3 class="segment-title2">Canceling a task</h3>

<p class="calibre1">Next, you’ll practice canceling a task. To do this, replace the code with the following:
</p><pre class="code-block"><span class="hljs-keyword">let</span> task <span class="hljs-operator">=</span> <span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on a task"</span>)
  <span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">100</span>).reduce(<span class="hljs-number">0</span>, <span class="hljs-operator">+</span>)
  <span class="hljs-keyword">try</span> <span class="hljs-built_in">Task</span>.checkCancellation()
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"1 + 2 + 3 ... 100 = <span class="hljs-subst">\(sum)</span>"</span>)
}

<span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing some work on the main actor"</span>)
task.cancel()</pre>
<p class="calibre1">This code creates a named variable, <code class="calibre9">task</code>, for the <code class="calibre9">Task</code> and then calls <code class="calibre9">cancel()</code> to cancel it.  Also, notice another critical change to the task itself: the <code class="calibre9">try Task.checkCancellation()</code> statement. This code checks a Boolean flag, <code class="calibre9">Task.isCancelled</code>, and throws an error, causing the task to unwind if a cancellation occurs. It does so in this case, and the output is:
</p><pre class="code-block">Doing some work on a task
Doing some work on the main actor</pre>
<p class="calibre1">The cancellation works as expected, and the sum doesn’t print. The key observation in this example is that it requires some extra work on your part &mdash; you need to use <code class="calibre9">checkCancellation()</code> to instruct the program when and how cancellation should happen. This requirement is a concurrency design pattern is known as <em class="calibre5">cooperative cancellation</em>.
</p>
<h3 class="segment-title2">Suspending a task</h3>

<p class="calibre1">Suppose you want to print the message <em class="calibre5">Hello</em>, wait for a second, and then print <em class="calibre5">Goodbye</em>. You’d add this to your playground:
</p><pre class="code-block"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
<span class="hljs-built_in">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye"</span>)</pre>
<p class="calibre1">It turns out modern computers don’t like to sleep much, so you need to specify a billion nanoseconds to tell <code class="calibre9">Task.sleep(nanoseconds:)</code> to sleep for just one second. :] Even with that, you get a bunch of errors:
</p><div class="image1"><img src="images/000010.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">The error message points out two problems:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">Task.sleep</code> is an <em class="calibre5">async</em> function. An async function can <em class="calibre5">suspend</em> and <em class="calibre5">resume</em> execution, and you can’t do that on the main actor.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">Task.sleep</code> can throw an error, which it needs to do to support cancellation, so you need to use <code class="calibre9">try</code>, <code class="calibre9">try?</code> or <code class="calibre9">try!</code>.
</p></li>
</ol>

<p class="calibre1">Attempt to fix the problem by replacing the code above with this:
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
  <span class="hljs-keyword">try</span> <span class="hljs-built_in">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye"</span>)
}</pre>
<p class="calibre1">The <code class="calibre9">Task</code> provides an async context. The <code class="calibre9">try</code> recognizes the function can fail.
</p>
<p class="calibre1">Adding <code class="calibre9">try</code> mostly fixes the problem, but now you get this:
</p><div class="image1"><img src="images/000023.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">Clicking the <em class="calibre5">Fix</em> button will give you this code, which will work!
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
  <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye"</span>)
}</pre>
<p class="calibre1">Just as the <code class="calibre9">try</code> flags indicate that a function can fail, marking it with <code class="calibre9">await</code> recognizes that it can suspend and later resume execution, which is what sleep does.
</p>
<h3 class="segment-title2">Wrapping it in a function</h3>

<p class="calibre1">Suppose you want to put that functionality into, well, a function. You might start like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">helloPauseGoodbye</span>() {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
  <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye"</span>)
}</pre>
<p class="calibre1">This code will produce these errors:
</p><div class="image1"><img src="images/000037.png" alt="" title="" class="calibre7" /></div>
<p class="calibre1">One of those errors should look familiar to you: Functions that <code class="calibre9">try</code> need to either handle the error or be marked with <code class="calibre9">throws</code>. You can fix the other error by pressing the <em class="calibre5">Fix</em> button.
</p>
<p class="calibre1">The final fixed code looks like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">helloPauseGoodbye</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)
  <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Task</span>.sleep(nanoseconds: <span class="hljs-number">1_000_000_000</span>)
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Goodbye"</span>)
}

<span class="hljs-built_in">Task</span> {
  <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> helloPauseGoodbye()
}</pre>
<p class="calibre1">The function is marked <code class="calibre9">async</code> and <code class="calibre9">throws</code>. This declaration means that it <em class="calibre5">might</em> throw an error, and it <em class="calibre5">might</em> suspend its execution. So, to call this function, you must first mark it with <em class="calibre5">try</em>, and then mark it <em class="calibre5">async</em> at the call site. Also, you cannot <code class="calibre9">await</code> a function from the main actor, so you need to contain this in either a <code class="calibre9">Task</code> or another async function.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: You might have noticed that there’s a lot of similarity between throwing functions and async functions. With both of them, you need to mark them explicitly in the declaration (<code class="calibre9">async throws</code>) and at the call site(<code class="calibre9">try await</code>). That’s not an accident! To keep things consistent, you always mark functions with <code class="calibre9">async throws</code>, in that order. The call site is <code class="calibre9">try await</code>, in that (opposite) order. Don’t worry if you forget the order; type it in, and the compiler fix-it will help you out.
</p></div>

<div class="note">
<p class="calibre10">Of course, it’s possible to have asynchronous functions that don’t throw and throwing functions that are synchronous.
</p></div>

<h3 class="segment-title2">The structure of Tasks</h3>

<p class="calibre1">You might have heard that Swift implements <em class="calibre5">structured concurrency</em>. That’s because tasks organize themselves into a tree-like structure with parent and child tasks.
</p>
<p class="calibre1">Giving concurrency and tasks a structure lets you reason better about operations like ordering and cancellation. It lets the system efficiently allocate operating system threads to handle the list of tasks at hand.
</p>
<p class="calibre1">Comment out <code class="calibre9">Task.cancel()</code> and run your playground now; you’ll see something like this:
</p><pre class="code-block">Doing some work on a task
Doing some work on the main actor
Hello
Hello
1 + 2 + 3 ... 100 = 5050
Goodbye
Goodbye</pre>
<p class="calibre1">This mixed output might seem weird, but it’s because you didn’t give your tasks any structure when you created them &mdash; everything’s just running at once. Later, you’ll see how to structure tasks.
</p>
<h2 class="segment-chapter1">Decoding an API &mdash; learning domains</h2>

<p class="calibre1">So far, you’ve just seen contrived printing examples. To get more practice, you’ll asynchronously download and decode all of the “learning domains” at <a href="https://www.raywenderlich.com" class="calibre6">raywenderlich.com</a> using the website’s API. This activity will involve:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Asynchronously fetching data from a URL.
</p></li>

<li class="calibre4">
<p class="calibre1">Decoding the data from JSON into lovely types.
</p></li>
</ol>

<p class="calibre1">The function will look like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">fetchDomains</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-built_in">Domain</span>] {
  [] <span class="hljs-comment">// Fill in the implementation later</span>
}</pre>
<p class="calibre1">Take a moment to appreciate the clarity of this function declaration. It tells you that it’s a potentially long process that can suspend and could also fail. On success, it returns a list of <code class="calibre9">Domain</code> values.
</p>
<p class="calibre1">Here’s how the API returns the learning domains:
</p><pre class="code-block"><span class="hljs-operator">{</span>
  <span class="hljs-built_in">"data"</span><span class="hljs-operator">:</span><span class="hljs-operator">[</span>
    <span class="hljs-operator">{</span>
      <span class="hljs-built_in">"id"</span><span class="hljs-operator">:</span><span class="hljs-string">"1"</span><span class="hljs-operator">,</span>
      <span class="hljs-built_in">"type"</span><span class="hljs-operator">:</span><span class="hljs-string">"domains"</span><span class="hljs-operator">,</span>
      <span class="hljs-built_in">"attributes"</span><span class="hljs-operator">:</span><span class="hljs-operator">{</span>
        <span class="hljs-built_in">"name"</span><span class="hljs-operator">:</span><span class="hljs-string">"iOS \u0026 Swift"</span><span class="hljs-operator">,</span>
        <span class="hljs-built_in">"slug"</span><span class="hljs-operator">:</span><span class="hljs-string">"ios"</span><span class="hljs-operator">,</span>
        <span class="hljs-built_in">"description"</span><span class="hljs-operator">:</span><span class="hljs-string">"Learn iOS development with SwiftUI and UIKit"</span><span class="hljs-operator">,</span>
        <span class="hljs-built_in">"level"</span><span class="hljs-operator">:</span><span class="hljs-string">"production"</span><span class="hljs-operator">,</span>
        <span class="hljs-built_in">"ordinal"</span><span class="hljs-operator">:</span><span class="hljs-number">1</span>
      <span class="hljs-operator">}</span>
    <span class="hljs-operator">}</span>
  <span class="hljs-operator">]</span>
<span class="hljs-operator">}</span></pre>
<p class="calibre1">As you see, the JSON hierarchy has three nested levels. Each domain in <code class="calibre9">data</code> has certain attributes. You model the whole thing like this:
</p><pre class="code-block"><span class="hljs-keyword">struct</span> <span class="hljs-number">Domains</span>: <span class="hljs-number">Decodable</span> {
  <span class="hljs-keyword">let</span> data: [<span class="hljs-built_in">Domain</span>]
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">Domain</span>: <span class="hljs-number">Decodable</span> {
  <span class="hljs-keyword">let</span> attributes: <span class="hljs-built_in">Attributes</span>
}

<span class="hljs-keyword">struct</span> <span class="hljs-number">Attributes</span>: <span class="hljs-number">Decodable</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> description: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> level: <span class="hljs-built_in">String</span>
}</pre>
<p class="calibre1">These types store only the attributes that you care about. The types are <code class="calibre9">Decodable</code> because their properties are <code class="calibre9">Decodable</code>.
</p>
<p class="calibre1">Now, it’s time to download domains from the server!
</p>
<h2 class="segment-chapter1">Async/await in action</h2>

<p class="calibre1">Swift’s concurrency features make asynchronous code nearly as easy to read and write as synchronous code. Here’s how you implement <code class="calibre9">fetchDomains</code>:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">fetchDomains</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-built_in">Domain</span>] {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-built_in">URL</span>(string: <span class="hljs-string">"https://api.raywenderlich.com/api/domains"</span>)<span class="hljs-operator">!</span>
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">let</span> (data, <span class="hljs-keyword">_</span>) <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">URLSession</span>.shared.data(from: url)
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> <span class="hljs-built_in">JSONDecoder</span>().decode(<span class="hljs-built_in">Domains</span>.<span class="hljs-keyword">self</span>, from: data).data
}</pre>
<p class="calibre1">In this code, you:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Create a URL to download from. You can use force unwrapping here because this URL string isn’t external, untrusted input, and you can guarantee that it’s well-formed.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <code class="calibre9">URLSession.shared.data(from:)</code> to receive the data and response from the server. This method is asynchronous, so you must mark its call with <code class="calibre9"><em class="calibre13">await</em></code>. This suspension point frees up your program to do other things while waiting for the call to complete. The call also throws errors, so you must mark it with <code class="calibre9">try</code>. In addition to data, this method returns a response type, but you can ignore it with <code class="calibre9">\_</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Decode the received data and grab the list of domains stored in the <code class="calibre9">data</code> property.
</p></li>
</ol>

<p class="calibre1">To test the download function, add this code to the playground and run it:
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">do</span> {  <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">let</span> domains <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> fetchDomains() <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">for</span> domain <span class="hljs-keyword">in</span> domains {                <span class="hljs-comment">// 4</span>
      <span class="hljs-keyword">let</span> attr <span class="hljs-operator">=</span> domain.attributes
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(attr.name)</span>: <span class="hljs-subst">\(attr.description)</span> - <span class="hljs-subst">\(attr.level)</span>"</span>)
    }
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_in">print</span>(error)
  }
}</pre>
<p class="calibre1">This code exercises your function by doing the following:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">Creating a <code class="calibre9">Task</code> context you can <code class="calibre9">await</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Creating a block to try and catch errors.
</p></li>

<li class="calibre4">
<p class="calibre1">Performing the actual download. <code class="calibre9">await</code> recognizes that the task can suspend here while other things are happening.
</p></li>

<li class="calibre4">
<p class="calibre1">Printing out the list of learning domains.
</p></li>
</ol>

<p class="calibre1">Swift’s concurrency features make downloading data asynchronously a breeze.
</p>
<h2 class="segment-chapter1">Asynchronous sequences</h2>

<p class="calibre1">Another powerful abstraction that Swift concurrency gives you is the <em class="calibre5">asynchronous sequence</em>. Getting each element may cause the task to suspend.
</p>
<p class="calibre1">Here’s an example that uses an asynchronous sequence:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">findTitle</span>(<span class="hljs-built_in">url</span>: <span class="hljs-built_in">URL</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-built_in">String</span>? {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> line <span class="hljs-keyword">in</span> url.lines {
    <span class="hljs-keyword">if</span> line.contains(<span class="hljs-string">"&lt;title&gt;"</span>) {
      <span class="hljs-keyword">return</span> line.trimmingCharacters(in: .whitespaces)
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
}</pre>
<p class="calibre1">The type <code class="calibre9">URL</code> has a convenience property called <code class="calibre9">lines</code> that returns an asynchronous sequence of strings for each file line. You can loop over this string with the <code class="calibre9">for try await</code> line in <code class="calibre9">url.lines</code>. It can stop loading and return the answer as soon as it hits a line with <code class="calibre9">&lt;title&gt;</code> in it.
</p>
<p class="calibre1">To test it, add the following to your playground and run it:
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> title <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> findTitle(url: <span class="hljs-built_in">URL</span>(string: 
                                     <span class="hljs-string">"https://www.raywenderlich.com"</span>)<span class="hljs-operator">!</span>) {
    <span class="hljs-built_in">print</span>(title)
  }
}</pre>
<p class="calibre1">This code will print:
</p><pre class="code-block">&lt;title&gt;raywenderlich.com | High quality programming tutorials: iOS, Android, Swift, Kotlin, Flutter, Server Side Swift, Unity, and more!&lt;/title&gt;</pre>
<h2 class="segment-chapter1">Ordering your concurrency</h2>

<p class="calibre1">In the previous examples, you just made a new unstructured <code class="calibre9">Task</code> block whenever you needed an asynchronous context that can suspend and resume. Suppose you want to get the titles of two web pages.
</p>
<p class="calibre1">You can write a function like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">findTitlesSerial</span>(<span class="hljs-built_in">first</span>: <span class="hljs-built_in">URL</span>, <span class="hljs-built_in">second</span>: <span class="hljs-built_in">URL</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; (<span class="hljs-built_in">String</span>?, 
                                                                <span class="hljs-built_in">String</span>?) {
  <span class="hljs-keyword">let</span> title1 <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> findTitle(url: first)
  <span class="hljs-keyword">let</span> title2 <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> findTitle(url: second)
  <span class="hljs-keyword">return</span> (title1, title2)
}</pre>
<p class="calibre1">This async function:
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">Attempts to find the first title, then suspends.
</p></li>

<li class="calibre4">
<p class="calibre1">Attempts to find the second title, then suspends.
</p></li>

<li class="calibre4">
<p class="calibre1">Serially returns the result.
</p></li>
</ul>

<p class="calibre1">Since the second title doesn’t depend on the first, processing them in parallel is faster.
</p>
<p class="calibre1">To do this, you might create two new, unstructured tasks for each find. While this would work, it’s a lot of bookkeeping, especially if you want to support cancellation. You’d need to write code to inform other tasks when one gets canceled.
</p>
<p class="calibre1">A better way is to use <em class="calibre5">asynchronous bindings</em>, like this:
</p><pre class="code-block"><span class="hljs-keyword">func</span> <span class="hljs-number">findTitlesParallel</span>(<span class="hljs-built_in">first</span>: <span class="hljs-built_in">URL</span>, <span class="hljs-built_in">second</span>: <span class="hljs-built_in">URL</span>) <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; (<span class="hljs-built_in">String</span>?, 
                                                                  <span class="hljs-built_in">String</span>?) {
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">let</span> title1 <span class="hljs-operator">=</span> findTitle(url: first)   <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">let</span> title2 <span class="hljs-operator">=</span> findTitle(url: second)  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">let</span> titles <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> [title1, title2]    <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">return</span> (titles[<span class="hljs-number">0</span>], titles[<span class="hljs-number">1</span>])              <span class="hljs-comment">// 4</span>
}</pre>
<p class="calibre1">Here’s what’s happening:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The declaration <code class="calibre9">async let</code> spins up a new child task that finds the first title.
</p></li>

<li class="calibre4">
<p class="calibre1">The declaration <code class="calibre9">async let</code> spins up another child task in parallel that finds the second title.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">try await</code> takes a sequence of asynchronous tasks and waits for them to finish.
</p></li>

<li class="calibre4">
<p class="calibre1">The results are returned as a tuple.
</p></li>
</ol>

<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: As of Xcode 13.0, <code class="calibre9">findTitlesParallel(first:second:)</code> doesn’t compile in a playground. Instead, you’ll need a project that targets iOS 15 to test it.
</p></div>

<p class="calibre1">The nice thing about making structured tasks this way is that it’s easier to reason about the lifetime and cancellation of tasks. For example, if the parent task that <code class="calibre9">findTitlesParallel(first:second:)</code> is running in gets marked as canceled, the child tasks are automatically marked canceled.
</p>
<h2 class="segment-chapter1">Asynchronous properties and subscripts</h2>

<p class="calibre1">Just as you saw with <code class="calibre9">throws</code> in Chapter 22, “Error Handling”, you can mark <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">only</em> computed properties with <code class="calibre9">async</code>. For example:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Domains</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> domains: [<span class="hljs-built_in">Domain</span>] {
    <span class="hljs-keyword">get</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> {
      <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> fetchDomains()
    }
  }
}</pre>
<p class="calibre1">You can test it with:
</p><pre class="code-block"><span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">dump</span>(<span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Domains</span>.domains)
}</pre>
<p class="calibre1">Similarly, you can also create asynchronous <em class="calibre5">read</em><em class="calibre5">-</em><em class="calibre5">only</em> subscripts:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Domains</span> {
  <span class="hljs-keyword">enum</span> <span class="hljs-number">Error</span>: <span class="hljs-number">Swift</span>.<span class="hljs-number">Error</span> { <span class="hljs-keyword">case</span> outOfRange }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-keyword">_</span> <span class="hljs-built_in">index</span>: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">get</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> {
      <span class="hljs-keyword">let</span> domains <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">Self</span>.domains
      <span class="hljs-keyword">guard</span> domains.indices.contains(index) <span class="hljs-keyword">else</span> { 
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>.outOfRange 
      }
      <span class="hljs-keyword">return</span> domains[index].attributes.name
    }
  }
}

<span class="hljs-built_in">Task</span> {
  <span class="hljs-built_in">dump</span>(<span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Domains</span>[<span class="hljs-number">4</span>])  <span class="hljs-comment">// "Unity", as of this writing</span>
}</pre>
<p class="calibre1">The subscript above is both asynchronous and throwable, since it uses the previously created computed property to determine the result value.
</p>
<h2 class="segment-chapter1">Introducing actors</h2>

<p class="calibre1">So far, you’ve seen how to introduce concurrency into your code. However, concurrency isn’t without its risks. In particular, concurrent code can access and mutate the same state simultaneously, causing unpredictable results.
</p>
<p class="calibre1">The classic example of this is a bank account where two people at different ATMs withdrawal the entire balance from the same bank account at precisely the same time. If the code isn’t written carefully, both withdrawals will succeed, which is not good news for the bank. Swift concurrency includes the special types <em class="calibre5">actor</em> and <em class="calibre5">Sendable</em> to deal with this issue of consistency.
</p>
<p class="calibre1">First, consider the following <code class="calibre9">Playlist</code>:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">class</span> <span class="hljs-number">Playlist</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> songs: [<span class="hljs-built_in">String</span>]
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">author</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">songs</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
    <span class="hljs-keyword">self</span>.author <span class="hljs-operator">=</span> author
    <span class="hljs-keyword">self</span>.songs <span class="hljs-operator">=</span> songs
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">add</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>) {
    songs.append(song)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">remove</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>songs.isEmpty, <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> songs.firstIndex(of: song) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>
    }
    songs.remove(at: index)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">move</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">playlist</span>: <span class="hljs-built_in">Playlist</span>) {
    playlist.remove(song: song)
    add(song: song)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">move</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">to</span> <span class="hljs-built_in">playlist</span>: <span class="hljs-built_in">Playlist</span>) {
    playlist.add(song: song)
    remove(song: song)
  }
}</pre>
<p class="calibre1">This class has four methods that change the state of <code class="calibre9">songs</code>. These methods are <i class="calibre2">not</i> safe to use concurrently. If you made them concurrent, you’d have multiple tasks changing the playlist simultaneously, resulting in an unpredictable and inconsistent state. You can solve this problem by converting the class to an <em class="calibre5">actor</em>. Like classes, actors are reference types that represent a shared mutable state. Importantly, actors prevent concurrent access to their state. They allow only one method to access their state at any given time.
</p>
<h3 class="segment-title2">Converting a class to an actor</h3>

<p class="calibre1">Here’s how you convert <code class="calibre9">Playlist</code> to an actor:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">actor</span> <span class="hljs-number">Playlist</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> songs: [<span class="hljs-built_in">String</span>]
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">author</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">songs</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
    <span class="hljs-keyword">self</span>.author <span class="hljs-operator">=</span> author
    <span class="hljs-keyword">self</span>.songs <span class="hljs-operator">=</span> songs
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">add</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>) {
    songs.append(song)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">remove</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>songs.isEmpty, <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> songs.firstIndex(of: song) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>
    }
    songs.remove(at: index)
  }
  
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">func</span> <span class="hljs-number">move</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">playlist</span>: <span class="hljs-built_in">Playlist</span>) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">await</span> playlist.remove(song: song)
    add(song: song)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">move</span>(<span class="hljs-built_in">song</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">to</span> <span class="hljs-built_in">playlist</span>: <span class="hljs-built_in">Playlist</span>) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> playlist.add(song: song)
    remove(song: song)
  }
}</pre>
<p class="calibre1">Here’s what’s changed:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1">The keyword <code class="calibre9">actor</code> replaces the keyword <code class="calibre9">class</code>.
</p></li>

<li class="calibre4">
<p class="calibre1">Both <code class="calibre9">move(song:from:)</code> and <code class="calibre9">move(song:to:)</code> have an additional <code class="calibre9">Playlist</code> as a parameter. This parameter means that they operate on two actors: <code class="calibre9">self</code> and <code class="calibre9">playlist</code>. You must use <code class="calibre9">await</code> to access <code class="calibre9">playlist</code> because the methods may have to wait their turn to get synchronized access to the <code class="calibre9">playlist</code> actor.
</p></li>

<li class="calibre4">
<p class="calibre1">Because <code class="calibre9">move(song:from:)</code> and <code class="calibre9">move(song:to:)</code> use <code class="calibre9">await</code> in their implementation, you must mark them as <code class="calibre9">async</code>. All actor methods are implicitly asynchronous already, but the implementation forces it to be explicit here.
</p></li>
</ol>

<h3 class="segment-title2">Making the code concurrent</h3>

<p class="calibre1">You can now safely use playlists in concurrent code:
</p><pre class="code-block"><span class="hljs-keyword">let</span> favorites <span class="hljs-operator">=</span> <span class="hljs-built_in">Playlist</span>(title: <span class="hljs-string">"Favorite songs"</span>, 
                         author: <span class="hljs-string">"Cosmin"</span>, 
                         songs: [<span class="hljs-string">"Nothing else matters"</span>])
<span class="hljs-keyword">let</span> partyPlaylist <span class="hljs-operator">=</span> <span class="hljs-built_in">Playlist</span>(title: <span class="hljs-string">"Party songs"</span>, 
                             author: <span class="hljs-string">"Ray"</span>, 
                             songs: [<span class="hljs-string">"Stairway to heaven"</span>])
<span class="hljs-built_in">Task</span> {
  <span class="hljs-keyword">await</span> favorites.move(song: <span class="hljs-string">"Stairway to heaven"</span>, from: partyPlaylist)
  <span class="hljs-keyword">await</span> favorites.move(song: <span class="hljs-string">"Nothing else matters"</span>, to: partyPlaylist)
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">print</span>(favorites.songs)
}</pre>
<p class="calibre1">You need to use <code class="calibre9">await</code> here to isolate the actor. The requirement to write <code class="calibre9">await</code> makes it obvious that the method could suspend if another piece of code is in the middle of accessing the <code class="calibre9">Playlist</code>. This means only one piece of code can access <code class="calibre9">Playlist</code> at any given time, making it safe. Notice that you call <code class="calibre9">add</code> and <code class="calibre9">remove</code> <i class="calibre2">without</i> using <code class="calibre9">await</code> inside the implementation of the <code class="calibre9">move</code> methods. This is because the compiler knows you already have exclusive access to the instance.
</p>
<p class="calibre1">The actor prepares two internal methods for every method of an actor: one version that needs to <code class="calibre9">await</code> and another, fast version that doesn’t. The compiler knows which internal method it needs to call to maximize performance safely.
</p>
<div class="note">
<p class="calibre10"><em class="calibre5">Note</em>: This code doesn’t work in Xcode 13.0 playgrounds yet, but you can try it out in an Xcode project.
</p></div>

<h3 class="segment-title2">Using the noninsulated keyword</h3>

<p class="calibre1">Actors, incidentally, are first-class types and can implement protocols, just like classes, structs and enums do:
</p><pre class="code-block"><span class="hljs-keyword">extension</span> <span class="hljs-number">Playlist</span>: <span class="hljs-number">CustomStringConvertible</span> {
  nonisolated <span class="hljs-keyword">var</span> description: <span class="hljs-built_in">String</span> {
    <span class="hljs-string">"<span class="hljs-subst">\(title)</span> by <span class="hljs-subst">\(author)</span>."</span>
  }
}

<span class="hljs-built_in">print</span>(favorites) <span class="hljs-comment">// "Favorite songs by Cosmin."</span></pre>
<p class="calibre1">Notice the <em class="calibre5">nonisolated</em> keyword. What’s that doing here?
</p>
<p class="calibre1">The <code class="calibre9">CustomStringConvertible</code> protocol requires a <i class="calibre2">synchronous</i> <code class="calibre9">description</code> property. However, like actor methods, actor properties are also implicitly <i class="calibre2">asynchronous</i>, so they don’t match the protocol requirement. The <code class="calibre9">nonisolated</code> keyword makes this property synchronous by disabling the actor’s synchronization features. This is called <em class="calibre5">actor isolation</em>.
</p>
<p class="calibre1">It’s safe to do that in this case because both <code class="calibre9">title</code> and <code class="calibre9">author</code> are constants. Therefore, the computed property only accesses immutable states.
</p>
<h2 class="segment-chapter1">Sendable</h2>

<p class="calibre1">Types conforming to the <em class="calibre5">Sendable</em> protocol are isolated from shared mutations, so they’re safe to use concurrently. These types have value semantics, which you read about in detail in Chapter 25, “Value Types &amp; Reference Types.” Actors only deal with <code class="calibre9">Sendable</code> types; in future versions of Swift, the compiler will enforce this.
</p>
<p class="calibre1">Actors and simple standard value types like <code class="calibre9">Int</code> and <code class="calibre9">String</code> are <code class="calibre9">Sendable</code> by default. Structures are also <code class="calibre9">Sendable</code>, as long as their stored properties are <code class="calibre9">Sendable</code>.
</p>
<p class="calibre1">Classes aren’t <i class="calibre2">usually</i> <code class="calibre9">Sendable</code> since they’re reference types, but they can be if you’re careful:
</p><pre class="code-block"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-number">BasicPlaylist</span> {
  <span class="hljs-keyword">let</span> title: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> author: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">title</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">author</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.title <span class="hljs-operator">=</span> title
    <span class="hljs-keyword">self</span>.author <span class="hljs-operator">=</span> author
  }
}

<span class="hljs-keyword">extension</span> <span class="hljs-number">BasicPlaylist</span>: <span class="hljs-number">Sendable</span> {}</pre>
<p class="calibre1">Here, <code class="calibre9">BasicPlaylist</code> is <code class="calibre9">Sendable</code> because it’s final, so it doesn’t support inheritance, and all of its stored properties are immutable and <code class="calibre9">Sendable</code>.
</p>
<p class="calibre1">Functions and closures can also conform to <code class="calibre9">Sendable</code>:
</p><pre class="code-block"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">func</span> <span class="hljs-number">execute</span>(<span class="hljs-built_in">task</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-number">@Sendable</span> () -&gt; <span class="hljs-built_in">Void</span>, 
             <span class="hljs-built_in">with</span> <span class="hljs-built_in">priority</span>: <span class="hljs-built_in">TaskPriority</span>? <span class="hljs-operator">=</span> <span class="hljs-keyword">nil</span>) {
  <span class="hljs-built_in">Task</span>(priority: priority, operation: task)
}

<span class="hljs-comment">// 2</span>
<span class="hljs-number">@Sendable</span> <span class="hljs-keyword">func</span> <span class="hljs-number">showRandomNumber</span>() {
  <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> <span class="hljs-built_in">Int</span>.random(in: <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span>)
  <span class="hljs-built_in">print</span>(number)
}

execute(task: showRandomNumber)</pre>
<p class="calibre1">Here’s what happens in the code above:
</p>
<ol start="1" class="calibre11">
<li class="calibre4">
<p class="calibre1"><code class="calibre9">execute(task:with:)</code> runs a task asynchronously with a certain priority. You mark <code class="calibre9">task</code> as both <code class="calibre9">escaping</code> and <code class="calibre9">Sendable</code> because <code class="calibre9">init(priority:operation:)</code> expects an escaping <code class="calibre9">Sendable</code> closure for <code class="calibre9">operation</code>. Recall from Chapter 24, “Memory Management”, that <code class="calibre9">@escaping</code> is required for closure parameters that you store and use at a later time.
</p></li>

<li class="calibre4">
<p class="calibre1"><code class="calibre9">showRandomNumber()</code> prints a random number between 1 and 10. You make it <code class="calibre9">Sendable</code>, since <code class="calibre9">execute(task:with:)</code> expects a <code class="calibre9">Sendable</code> function for <code class="calibre9">task</code>.
</p></li>
</ol>

<p class="calibre1">The requirement for <code class="calibre9">Sendable</code> is that the closure does not capture or modify shared mutable state.
</p>
<h2 class="segment-chapter1">Challenges</h2>

<p class="calibre1">Here’s the last set of challenges to test your concurrency knowledge. It’s best to try and solve them yourself, but solutions are available in the challenges download folder if you get stuck.
</p>
<h3 class="segment-title2">Challenge 1: Safe teams</h3>

<p class="calibre1">Using the above <code class="calibre9">Playlist</code> example as a guild, change the following class to make it safe to use in concurrent contexts:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">Team</span> {
  <span class="hljs-keyword">let</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">let</span> stadium: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> players: [<span class="hljs-built_in">String</span>]
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">stadium</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">players</span>: [<span class="hljs-built_in">String</span>]) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.stadium <span class="hljs-operator">=</span> stadium
    <span class="hljs-keyword">self</span>.players <span class="hljs-operator">=</span> players
  }
  
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-number">add</span>(<span class="hljs-built_in">player</span>: <span class="hljs-built_in">String</span>) {
    players.append(player)
  }
  
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-number">remove</span>(<span class="hljs-built_in">player</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>players.isEmpty, <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> players.firstIndex(of: player) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>
    }
    players.remove(at: index)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">buy</span>(<span class="hljs-built_in">player</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">from</span> <span class="hljs-built_in">team</span>: <span class="hljs-built_in">Team</span>) {
    team.remove(player: player)
    add(player: player)
  }
  
  <span class="hljs-keyword">func</span> <span class="hljs-number">sell</span>(<span class="hljs-built_in">player</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">to</span> <span class="hljs-built_in">team</span>: <span class="hljs-built_in">Team</span>) {
    team.add(player: player)
    remove(player: player)
  }
}</pre>
<h3 class="segment-title2">Challenge 2: Custom teams</h3>

<p class="calibre1">Conform the asynchronous-safe type from the previous challenge to <code class="calibre9">CustomStringConvertible</code>.
</p>
<h3 class="segment-title2">Challenge 3: <code class="calibre12">Sendable</code> teams</h3>

<p class="calibre1">Make the following class <code class="calibre9">Sendable</code>:
</p><pre class="code-block"><span class="hljs-keyword">class</span> <span class="hljs-number">BasicTeam</span> {
  <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span>
  <span class="hljs-keyword">var</span> stadium: <span class="hljs-built_in">String</span>
  
  <span class="hljs-keyword">init</span>(<span class="hljs-built_in">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-built_in">stadium</span>: <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name
    <span class="hljs-keyword">self</span>.stadium <span class="hljs-operator">=</span> stadium
  }
}</pre>
<h2 class="segment-chapter1">Key points</h2>

<p class="calibre1">Concurrent programming is a crucial topic. Future versions of Swift will likely refine the tools and approaches for writing robust concurrent programs.
</p>
<ul class="calibre3">
<li class="calibre4">
<p class="calibre1">The <em class="calibre5">Task</em> type lets you spin up a new task that executes code concurrently.
</p></li>

<li class="calibre4">
<p class="calibre1">Tasks support cancellation but require your cooperation to implement. This is <em class="calibre5">cooperative cancellation</em>.
</p></li>

<li class="calibre4">
<p class="calibre1">Asynchronous functions are marked with <em class="calibre5">async</em> and can suspend and resume after you call them.
</p></li>

<li class="calibre4">
<p class="calibre1">You can only call asynchronous functions in a <code class="calibre9">Task</code> context or within another async function. You can’t call them from the main actor.
</p></li>

<li class="calibre4">
<p class="calibre1">When you call an asynchronous function, you must use <code class="calibre9">await</code>, recognizing that your program could potentially suspend at that point.
</p></li>

<li class="calibre4">
<p class="calibre1">The standard library provides <em class="calibre5">asynchronous sequences</em> whenever getting the next element might require your program to suspend.
</p></li>

<li class="calibre4">
<p class="calibre1">Use <em class="calibre5">for try await in</em> to loop through asynchronous sequences.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Asynchronous bindings</em> allow you to spin up additional child tasks to work in parallel.
</p></li>

<li class="calibre4">
<p class="calibre1">Swift implements <em class="calibre5">structured concurrency</em> where tasks have a parent-child relationship, making it easier to reason about lifetime and cancellation.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Read</em><em class="calibre5">-</em><em class="calibre5">only</em> computed properties and subscripts can be marked asynchronous in addition to throwing.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Actors</em> are new reference types in Swift whose primary job is to protect the shared mutable state of the type.
</p></li>

<li class="calibre4">
<p class="calibre1"><em class="calibre5">Sendable</em> types are isolated from mutable shared state changes and can be safely shared between actors in your program.
</p></li>
</ul>
</div>

<div class="segment-title" id="calibre_link-14">


<h1 class="segment-chapter">Conclusion</h1>

<p class="calibre1">We hope you learned a lot about Swift in this book &mdash; and had some fun in the process! Swift is filled with language features and programming paradigms, and we hope you now feel comfortable enough with the language to move on to building bigger things.
</p>
<p class="calibre1">With the language fundamentals under your belt, you’re ready to explore advanced frameworks like SwiftUI and Combine to build iOS apps, macOS apps and more. You might want to explore Swift on the server or even look at how Swift is being used in bleeding edge machine learning research.
</p>
<p class="calibre1">If you have any questions or comments as you continue to use Swift, please stop by our forums at <a href="https://forums.raywenderlich.com" class="calibre6">https://forums.raywenderlich.com</a>.
</p>
<p class="calibre1">Thank you again for purchasing this book. Your continued support is what makes the tutorials, books, videos, conferences and other things we do at raywenderlich.com possible &mdash; we truly appreciate it!
</p>
<p class="calibre1">Wishing you all the best in your continued Swift adventures,
</p>
<p class="calibre1">&ndash; The <i class="calibre2">Swift Apprentice</i> team
</p></div>

</body></html>